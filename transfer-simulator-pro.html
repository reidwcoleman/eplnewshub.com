<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TVPLGM5QY9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-TVPLGM5QY9');
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Professional FPL Transfer Simulator with AI predictions, what-if scenarios, and advanced analytics">
    <meta name="keywords" content="FPL transfer simulator, Fantasy Premier League, transfer planner, AI predictions">
    <meta name="author" content="EPL News Hub">
    <title>Transfer Simulator Pro - Advanced FPL Transfer Planning | EPL News Hub</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="/mobile-master-optimize.css">
    <link rel="stylesheet" href="fpl-mobile-optimize.css">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6480210605786899" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Load FPL Data Service from player-data.html -->
    <script src="fpl-api.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            color: #333;
        }

        .pro-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .pro-header {
            background: linear-gradient(135deg, rgba(55, 0, 60, 0.95) 0%, rgba(111, 66, 193, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            color: white;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .pro-header h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 15px rgba(255,255,255,0.2);
        }

        .live-status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 50px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }

        .live-dot {
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px #00ff88;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .panel h2 {
            color: #37003c;
            margin-bottom: 20px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .squad-section {
            margin-bottom: 25px;
        }

        .squad-section h3 {
            color: #6f42c1;
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .player-slot {
            background: linear-gradient(135deg, #f8f9fa, #ffffff);
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .player-slot:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-color: #6f42c1;
        }

        .player-slot.selected {
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            border-color: #00ff88;
            color: white;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 3px;
        }

        .player-details {
            font-size: 0.85rem;
            color: #666;
        }

        .player-price {
            font-weight: 700;
            color: #37003c;
            font-size: 1.1rem;
        }

        .player-slot.selected .player-price {
            color: white;
        }

        .budget-tracker {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .budget-amount {
            font-size: 2.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 10px;
        }

        .budget-bar {
            background: rgba(255,255,255,0.3);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .budget-fill {
            background: white;
            height: 100%;
            transition: width 0.5s ease;
        }

        .player-market {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .market-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-group label {
            font-weight: 600;
            color: #37003c;
            font-size: 0.9rem;
        }

        .filter-group input,
        .filter-group select {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .filter-group input:focus,
        .filter-group select:focus {
            outline: none;
            border-color: #6f42c1;
            box-shadow: 0 0 0 3px rgba(111, 66, 193, 0.1);
        }

        .player-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .search-instructions {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            border: 2px dashed #6f42c1;
        }

        .search-prompt h3 {
            color: #37003c;
            font-size: 1.8rem;
            margin-bottom: 15px;
            font-weight: 700;
        }

        .search-prompt p {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .search-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.7;
        }

        .position-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .position-btn {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            color: white;
            border: none;
            padding: 20px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1rem;
        }

        .position-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(111, 66, 193, 0.3);
            background: linear-gradient(135deg, #37003c, #6f42c1);
        }

        .position-emoji {
            font-size: 2rem;
        }

        .position-btn span:last-child {
            font-size: 1rem;
        }

        .market-player-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .market-player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #37003c, #6f42c1);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .market-player-card:hover::before {
            transform: scaleX(1);
        }

        .market-player-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }

        .player-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .player-card-name {
            font-size: 1.2rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 5px;
        }

        .player-card-team {
            color: #666;
            font-size: 0.9rem;
        }

        .player-card-price {
            background: linear-gradient(135deg, #37003c, #6f42c1);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 700;
        }

        .player-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #37003c;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
            margin-top: 2px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #37003c, #6f42c1);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(55, 0, 60, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
        }

        .scenario-panel {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            color: white;
            padding: 25px;
            border-radius: 16px;
            margin-bottom: 30px;
        }

        .scenario-panel h2 {
            color: white;
            margin-bottom: 20px;
        }

        .scenario-item {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .scenario-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .scenario-title {
            font-weight: 700;
            margin-bottom: 5px;
        }

        .scenario-description {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .analytics-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .chart-container h3 {
            color: #37003c;
            margin-bottom: 15px;
        }

        .ai-recommendations {
            background: linear-gradient(135deg, #00d4ff, #00ff88);
            padding: 25px;
            border-radius: 16px;
            margin-bottom: 30px;
        }

        .ai-recommendations h2 {
            color: white;
            margin-bottom: 20px;
        }

        .recommendation-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .recommendation-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #37003c, #6f42c1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
        }

        .recommendation-content {
            flex: 1;
        }

        .recommendation-title {
            font-weight: 700;
            color: #333;
            margin-bottom: 5px;
        }

        .recommendation-details {
            color: #666;
            font-size: 0.9rem;
        }

        .transfer-history {
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 16px;
            margin-bottom: 30px;
        }

        .history-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .history-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 1.2rem;
        }

        .history-in {
            background: #d4edda;
            color: #155724;
        }

        .history-out {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .analytics-section {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .pro-container {
                padding: 10px;
            }
            
            .pro-header {
                padding: 25px 15px;
                border-radius: 12px;
            }
            
            .pro-header h1 {
                font-size: 1.8rem;
            }
            
            .pro-header p {
                font-size: 0.9rem;
            }
            
            .live-status {
                padding: 8px 15px;
                font-size: 0.8rem;
            }
            
            .main-grid {
                gap: 15px;
            }
            
            .panel {
                padding: 15px;
                border-radius: 12px;
            }
            
            .panel h2 {
                font-size: 1.2rem;
            }
            
            .squad-section h3 {
                font-size: 1rem;
            }
            
            .player-slot {
                padding: 10px;
                margin-bottom: 8px;
            }
            
            .player-name {
                font-size: 0.9rem;
            }
            
            .player-price {
                font-size: 0.95rem;
            }
            
            .budget-amount {
                font-size: 2rem;
            }
            
            .player-cards {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .search-instructions {
                padding: 25px 15px;
            }
            
            .search-prompt h3 {
                font-size: 1.4rem;
            }
            
            .search-prompt p {
                font-size: 1rem;
            }
            
            .search-icon {
                font-size: 3rem;
            }
            
            .position-buttons {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .position-btn {
                padding: 15px 10px;
                font-size: 0.9rem;
            }
            
            .position-emoji {
                font-size: 1.5rem;
            }
            
            .market-player-card {
                padding: 15px;
            }
            
            .player-card-name {
                font-size: 1.1rem;
            }
            
            .player-stats-grid {
                gap: 8px;
            }
            
            .stat-box {
                padding: 6px;
            }
            
            .stat-value {
                font-size: 1rem;
            }
            
            .stat-label {
                font-size: 0.65rem;
            }
            
            .market-filters {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .filter-group input,
            .filter-group select {
                width: 100%;
                padding: 10px;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .scenario-panel {
                padding: 20px 15px;
            }
            
            .scenario-item {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .scenario-title {
                font-size: 0.95rem;
            }
            
            .scenario-description {
                font-size: 0.85rem;
            }
            
            .recommendation-card {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .recommendation-icon {
                width: 40px;
                height: 40px;
                font-size: 1.2rem;
            }
            
            .recommendation-title {
                font-size: 0.9rem;
            }
            
            .recommendation-details {
                font-size: 0.85rem;
            }
            
            .history-item {
                padding: 12px;
                margin-bottom: 8px;
            }
            
            .history-icon {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }
        
        @media (max-width: 480px) {
            .pro-header h1 {
                font-size: 1.4rem;
            }
            
            .panel {
                padding: 12px;
            }
            
            .panel h2 {
                font-size: 1.1rem;
            }
            
            .squad-section h3 {
                font-size: 0.9rem;
            }
            
            .player-slot {
                padding: 8px;
            }
            
            .player-name {
                font-size: 0.85rem;
            }
            
            .player-details {
                font-size: 0.75rem;
            }
            
            .player-price {
                font-size: 0.9rem;
            }
            
            .budget-amount {
                font-size: 1.6rem;
            }
            
            .market-player-card {
                padding: 12px;
            }
            
            .player-card-name {
                font-size: 1rem;
            }
            
            .player-card-team {
                font-size: 0.8rem;
            }
            
            .player-card-price {
                padding: 4px 10px;
                font-size: 0.85rem;
            }
            
            .stat-value {
                font-size: 0.9rem;
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 0.85rem;
            }
            
            .action-buttons {
                flex-direction: column;
                gap: 8px;
            }
            
            .position-badge {
                padding: 2px 5px;
                font-size: 0.65rem;
            }
            
            .scenario-panel h2 {
                font-size: 1.1rem;
            }
            
            .ai-recommendations h2 {
                font-size: 1.1rem;
            }
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .position-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .badge-gkp { background: #ffd700; color: #333; }
        .badge-def { background: #00ff87; color: #333; }
        .badge-mid { background: #00d4ff; color: #333; }
        .badge-fwd { background: #ff1744; color: white; }

        .form-indicator {
            display: flex;
            gap: 3px;
            margin-top: 10px;
        }

        .form-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .form-good { background: #28a745; }
        .form-average { background: #ffc107; }
        .form-bad { background: #dc3545; }

        .scenario-result {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
        }

        .scenario-result.active {
            display: block;
        }

        .result-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .result-label {
            opacity: 0.9;
        }

        .result-value {
            font-weight: 700;
            color: #00ff88;
        }
        /* Transfer Statistics Section */
        .transfer-stats-section {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            margin: 30px 0;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .transfer-stats-section h2 {
            font-size: 2.5rem;
            color: #37003c;
            margin-bottom: 30px;
            text-align: center;
        }

        .stat-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 2px solid #f0f0f0;
        }

        .stat-panel h3 {
            color: #6f42c1;
            font-size: 1.3rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .spending-list {
            list-style: none;
        }

        .spending-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .spending-item:last-child {
            border-bottom: none;
        }

        .club-rank {
            font-size: 1.5rem;
            font-weight: bold;
            color: #6f42c1;
            margin-right: 15px;
            width: 30px;
        }

        .club-info {
            flex: 1;
        }

        .club-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .spending-bar {
            background: #f0f0f0;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .spending-fill {
            height: 100%;
            background: linear-gradient(90deg, #6f42c1, #00ff88);
            border-radius: 4px;
            transition: width 1s ease;
        }

        .spending-amount {
            font-size: 1.2rem;
            font-weight: bold;
            color: #37003c;
            margin-left: auto;
        }

        .trend-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .trend-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .trend-value {
            font-size: 2rem;
            font-weight: bold;
            color: #6f42c1;
            display: block;
            margin-bottom: 5px;
        }

        .trend-label {
            color: #666;
            font-size: 0.9rem;
        }

        .routes-chart {
            display: grid;
            gap: 15px;
        }

        .route-item {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .route-icon {
            font-size: 2rem;
        }

        .route-info {
            flex: 1;
        }

        .route-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .route-bar {
            background: #f0f0f0;
            height: 25px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .route-fill {
            height: 100%;
            background: linear-gradient(90deg, #37003c, #6f42c1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-weight: bold;
            transition: width 1s ease;
        }

        /* Fixture Difficulty Analysis */
        .fixture-analysis-section {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            margin: 30px 0;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }

        .fixture-analysis-section h2 {
            font-size: 2.2rem;
            color: #37003c;
            margin-bottom: 30px;
            text-align: center;
        }

        .fixture-filter {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .fixture-btn {
            padding: 12px 24px;
            border: 2px solid #6f42c1;
            background: transparent;
            color: #6f42c1;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .fixture-btn.active,
        .fixture-btn:hover {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(111, 66, 193, 0.3);
        }

        .fixture-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .team-fixture-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #f0f0f0;
            transition: all 0.3s ease;
        }

        .team-fixture-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-color: #6f42c1;
        }

        .team-name {
            font-size: 1.3rem;
            font-weight: 700;
            color: #37003c;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .fixture-list {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .fixture-opponent {
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            text-align: center;
            min-width: 45px;
        }

        .difficulty-1 { background: #28a745; }
        .difficulty-2 { background: #20c997; }
        .difficulty-3 { background: #ffc107; color: #333; }
        .difficulty-4 { background: #fd7e14; }
        .difficulty-5 { background: #dc3545; }

        .fixture-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: #37003c;
            margin-left: 15px;
        }

        /* Player Comparison Matrix */
        .comparison-section {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            margin: 30px 0;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }

        .comparison-section h2 {
            font-size: 2.2rem;
            color: #37003c;
            margin-bottom: 30px;
            text-align: center;
        }

        .comparison-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .comparison-controls select {
            padding: 12px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            background: white;
            color: #37003c;
            min-width: 150px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .comparison-controls select:focus {
            outline: none;
            border-color: #6f42c1;
            box-shadow: 0 0 0 3px rgba(111, 66, 193, 0.1);
        }

        .comparison-table {
            background: white;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #f0f0f0;
            overflow-x: auto;
        }

        .comparison-placeholder {
            text-align: center;
            color: #666;
            font-size: 1.1rem;
            padding: 40px;
        }

        .comparison-matrix {
            width: 100%;
            border-collapse: collapse;
        }

        .comparison-matrix th,
        .comparison-matrix td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #f0f0f0;
        }

        .comparison-matrix th {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            color: white;
            font-weight: 700;
            position: sticky;
            top: 0;
        }

        .comparison-matrix .stat-name {
            text-align: left;
            font-weight: 600;
            color: #37003c;
            background: #f8f9fa;
        }

        .stat-best {
            background: #d4edda;
            color: #155724;
            font-weight: 700;
        }

        /* Price Change Predictions */
        .price-change-section {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            margin: 30px 0;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }

        .price-change-section h2 {
            font-size: 2.2rem;
            color: #37003c;
            margin-bottom: 30px;
            text-align: center;
        }

        .price-change-tabs {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .price-tab {
            padding: 12px 24px;
            border: 2px solid #6f42c1;
            background: transparent;
            color: #6f42c1;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .price-tab.active,
        .price-tab:hover {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(111, 66, 193, 0.3);
        }

        .price-change-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .price-change-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #f0f0f0;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .price-change-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .price-change-card.riser::before {
            background: linear-gradient(90deg, #28a745, #20c997);
        }

        .price-change-card.faller::before {
            background: linear-gradient(90deg, #dc3545, #c82333);
        }

        .price-change-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-color: #6f42c1;
        }

        .price-player-name {
            font-size: 1.2rem;
            font-weight: 700;
            color: #37003c;
            margin-bottom: 5px;
        }

        .price-player-team {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        .price-change-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .current-price {
            font-size: 1.1rem;
            font-weight: 600;
            color: #37003c;
        }

        .price-prediction {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 700;
        }

        .price-prediction.rise {
            color: #28a745;
        }

        .price-prediction.fall {
            color: #dc3545;
        }

        .ownership-change {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
        }

        /* Captain Prediction */
        .captain-section {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            color: white;
            border-radius: 20px;
            padding: 40px;
            margin: 30px 0;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .captain-section h2 {
            font-size: 2.2rem;
            color: white;
            margin-bottom: 30px;
            text-align: center;
        }

        .captain-analysis {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .captain-card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            transition: all 0.3s ease;
        }

        .captain-card:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(10px);
        }

        .top-captain {
            background: rgba(255,215,0,0.2);
            border: 2px solid rgba(255,215,0,0.5);
        }

        .captain-rank {
            font-size: 2rem;
            font-weight: 800;
            color: #ffd700;
            min-width: 60px;
            text-align: center;
        }

        .captain-info {
            flex: 1;
        }

        .captain-name {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .captain-details {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .captain-stats {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .captain-confidence {
            font-size: 1.5rem;
            font-weight: 800;
            color: #ffd700;
            text-align: center;
            min-width: 80px;
        }

        .captain-alternatives {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        /* Responsive Design for New Features */
        @media (max-width: 768px) {
            .fixture-analysis-section,
            .comparison-section,
            .price-change-section,
            .captain-section {
                padding: 25px 15px;
                margin: 20px 0;
            }

            .fixture-analysis-section h2,
            .comparison-section h2,
            .price-change-section h2,
            .captain-section h2 {
                font-size: 1.8rem;
            }

            .fixture-filter,
            .price-change-tabs {
                flex-direction: column;
                align-items: center;
            }

            .fixture-btn,
            .price-tab {
                width: 200px;
            }

            .comparison-controls {
                flex-direction: column;
                align-items: center;
            }

            .comparison-controls select {
                width: 100%;
                max-width: 300px;
            }

            .fixture-grid,
            .price-change-grid {
                grid-template-columns: 1fr;
            }

            .captain-alternatives {
                grid-template-columns: 1fr;
            }

            .captain-card {
                flex-direction: column;
                text-align: center;
                gap: 15px;
            }

            .captain-stats {
                justify-content: center;
            }
        }
        /* 🚀 ADVANCED FEATURES STYLING */
        
        .advanced-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .advanced-modal-content {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,240,240,0.95));
            border-radius: 20px;
            padding: 40px;
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2rem;
            cursor: pointer;
            color: #666;
            transition: color 0.3s;
        }

        .close-modal:hover {
            color: #333;
        }

        .advanced-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .analysis-card {
            background: rgba(255,255,255,0.8);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 2px solid rgba(55,0,60,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .analysis-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .analysis-card.full-width {
            grid-column: 1 / -1;
        }

        .prediction-value {
            font-size: 2.5rem;
            font-weight: 800;
            color: #37003c;
            margin: 15px 0;
        }

        .confidence-meter {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .confidence-bar {
            height: 100%;
            background: linear-gradient(90deg, #dc3545, #ffc107, #28a745);
            transition: width 0.5s ease;
        }

        .difficulty-rating {
            font-size: 2rem;
            font-weight: 700;
            margin: 15px 0;
        }

        .risk-percentage {
            font-size: 2.5rem;
            font-weight: 800;
            margin: 15px 0;
        }

        .risk-percentage.low { color: #28a745; }
        .risk-percentage.medium { color: #ffc107; }
        .risk-percentage.high { color: #dc3545; }

        .sentiment-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            margin: 15px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sentiment-badge.bullish { background: #28a745; color: white; }
        .sentiment-badge.bearish { background: #dc3545; color: white; }
        .sentiment-badge.neutral { background: #6c757d; color: white; }
        .sentiment-badge.fomo { background: #ff6b35; color: white; }
        .sentiment-badge.value { background: #17a2b8; color: white; }

        .trend-indicator {
            font-size: 2rem;
            font-weight: 700;
            margin: 15px 0;
        }

        /* Advanced Features Panel */
        .advanced-features-panel {
            background: linear-gradient(135deg, rgba(55,0,60,0.95), rgba(111,66,193,0.95));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            color: white;
        }

        .advanced-features-panel h2 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2rem;
            background: linear-gradient(135deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .feature-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s, background 0.3s;
            cursor: pointer;
        }

        .feature-card:hover {
            transform: translateY(-5px);
            background: rgba(255,255,255,0.2);
        }

        .feature-icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        .feature-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .feature-description {
            font-size: 0.9rem;
            opacity: 0.9;
            line-height: 1.4;
        }

        /* Chemistry Display */
        .chemistry-display {
            background: linear-gradient(135deg, #00d4ff, #00ff88);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            color: white;
        }

        .chemistry-score {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 10px;
        }

        .synergy-bonuses {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .synergy-badge {
            background: rgba(255,255,255,0.2);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            backdrop-filter: blur(5px);
        }

        /* Market Sentiment Widget */
        .market-sentiment-widget {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .trending-players {
            display: grid;
            gap: 10px;
            margin-top: 15px;
        }

        .trending-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(55,0,60,0.05);
            border-radius: 8px;
        }

        .trending-change {
            font-weight: 600;
            color: #28a745;
        }

        /* Wildcard Planner */
        .wildcard-planner {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            border-radius: 15px;
            padding: 25px;
            color: white;
            margin: 20px 0;
        }

        .optimal-timing {
            text-align: center;
            margin-bottom: 20px;
        }

        .gameweek-recommendation {
            font-size: 2rem;
            font-weight: 800;
            color: #00ff88;
            margin: 10px 0;
        }

        .template-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .template-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .template-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .template-btn.active {
            background: rgba(255,255,255,0.4);
        }

        /* Enhanced Buttons */
        .btn-advanced {
            background: linear-gradient(135deg, #6f42c1, #37003c);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        .btn-advanced:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(111,66,193,0.4);
        }

        .btn-glow {
            box-shadow: 0 0 20px rgba(111,66,193,0.6);
            animation: glow-pulse 2s infinite;
        }

        @keyframes glow-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(111,66,193,0.6); }
            50% { box-shadow: 0 0 30px rgba(111,66,193,0.8); }
        }

        /* Responsive Updates for Advanced Features */
        /* Floating Action Button */
        .floating-menu {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
        }

        .fab-main {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
        }

        .fab-main:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .fab-menu {
            position: absolute;
            bottom: 70px;
            right: 0;
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .fab-menu.active {
            display: flex;
        }

        .fab-item {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: white;
            color: #37003c;
            border: 2px solid #667eea;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            position: relative;
        }

        .fab-item:hover {
            transform: scale(1.1);
            background: #667eea;
            color: white;
        }

        .fab-tooltip {
            position: absolute;
            right: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            white-space: nowrap;
            font-size: 0.9rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .fab-item:hover .fab-tooltip {
            opacity: 1;
        }

        /* Quick Feature Button Hover Effects */
        .quick-feature-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* Advanced Features Panel Enhancement */
        .advanced-features-panel {
            background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(240,240,255,0.98));
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: 2px solid #667eea;
        }

        .advanced-features-panel h2 {
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .advanced-modal-content {
                width: 95%;
                padding: 20px;
            }

            .advanced-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .feature-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }

            .prediction-value,
            .chemistry-score {
                font-size: 2rem;
            }

            .feature-icon {
                font-size: 2rem;
            }

            .template-selector {
                flex-direction: column;
                align-items: center;
            }

            .floating-menu {
                bottom: 20px;
                right: 20px;
            }

            .fab-main {
                width: 50px;
                height: 50px;
            }
        }
    </style>
    <!-- Tesseract.js for OCR -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <!-- Simple OCR Processing -->
    <script src="simple-ocr-processor.js"></script>
</head>
<body>
    <div class="header" include="./header.html"></div>
    
    <div class="pro-container">
        <div class="pro-header">
            <h1>⚡ Transfer Simulator Pro</h1>
            <p>Advanced AI-Powered Transfer Planning with What-If Scenarios</p>
            <div class="live-status">
                <span class="live-dot"></span>
                <span>LIVE FPL DATA</span>
                <span style="margin-left: 20px;">Last Update: <span id="lastUpdate">Loading...</span></span>
                <button onclick="refreshPlayerData()" style="margin-left: 20px; padding: 5px 15px; background: linear-gradient(135deg, #00ff88, #00c851); color: #333; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                    🔄 Refresh Data
                </button>
                <button onclick="forceLoadPlayerData()" style="margin-left: 10px; padding: 5px 15px; background: linear-gradient(135deg, #ff6b6b, #ee5a24); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                    ⚠️ Force Load
                </button>
            </div>
            
            <!-- NEW: Quick Access Advanced Features Hero -->
            <div class="advanced-features-hero" style="margin-top: 30px; padding: 20px; background: rgba(255,255,255,0.1); border-radius: 15px; backdrop-filter: blur(10px);">
                <h2 style="color: #00ff88; margin-bottom: 15px; font-size: 1.5rem;">🚀 Advanced AI Tools - Quick Access</h2>
                <button onclick="testAllFeatures(); alert('Check browser console for feature status')" style="position: absolute; top: 20px; right: 20px; padding: 5px 10px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; cursor: pointer; font-size: 0.8rem;">
                    🧪 Test Features
                </button>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <button onclick="showPriceTracker()" class="quick-feature-btn" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 12px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                        💹 Price Alerts
                    </button>
                    <button onclick="showCaptainOptimizer()" class="quick-feature-btn" style="background: linear-gradient(135deg, #f093fb, #f5576c); color: white; border: none; padding: 12px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                        👑 Captain AI
                    </button>
                    <button onclick="showSquadComparison()" class="quick-feature-btn" style="background: linear-gradient(135deg, #4facfe, #00f2fe); color: white; border: none; padding: 12px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                        ⚔️ Squad Compare
                    </button>
                    <button onclick="showStrategySimulator()" class="quick-feature-btn" style="background: linear-gradient(135deg, #43e97b, #38f9d7); color: white; border: none; padding: 12px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                        🎮 Transfer Plan
                    </button>
                    <button onclick="showXGStats()" class="quick-feature-btn" style="background: linear-gradient(135deg, #fa709a, #fee140); color: white; border: none; padding: 12px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                        📊 xG Stats
                    </button>
                    <button onclick="showChipOptimizer()" class="quick-feature-btn" style="background: linear-gradient(135deg, #30cfd0, #330867); color: white; border: none; padding: 12px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: transform 0.2s;">
                        🎯 Chip Strategy
                    </button>
                </div>
                <p style="color: #fff; opacity: 0.9; margin-top: 10px; font-size: 0.9rem;">Click any tool above or scroll down for all 16 advanced features</p>
            </div>
        </div>

        <!-- Main Grid Layout -->
        <div class="main-grid">
            <!-- Left Panel - Current Squad -->
            <div class="panel">
                <h2>📋 Current Squad</h2>
                
                <div class="budget-tracker">
                    <div class="budget-amount" id="remainingBudget">£100.0m</div>
                    <div style="text-align: center; opacity: 0.9;">Remaining Budget</div>
                    <div class="budget-bar">
                        <div class="budget-fill" id="budgetFill" style="width: 100%"></div>
                    </div>
                </div>

                <div class="squad-section">
                    <h3>Goalkeepers (2)</h3>
                    <div id="gkp-slots"></div>
                </div>

                <div class="squad-section">
                    <h3>Defenders (5)</h3>
                    <div id="def-slots"></div>
                </div>

                <div class="squad-section">
                    <h3>Midfielders (5)</h3>
                    <div id="mid-slots"></div>
                </div>

                <div class="squad-section">
                    <h3>Forwards (3)</h3>
                    <div id="fwd-slots"></div>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="optimizeTeam()" style="flex: 1;">
                        🤖 AI Optimize Squad
                    </button>
                    <button class="btn btn-danger" onclick="resetTeam()" style="flex: 1; background: linear-gradient(135deg, #dc3545, #c82333);">
                        🔄 Reset Team
                    </button>
                </div>
                
                <!-- Save/Load Team Feature -->
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="btn btn-success" onclick="saveCurrentTeam()" style="flex: 1; background: linear-gradient(135deg, #28a745, #218838); color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: 600;">
                        💾 Save Team
                    </button>
                    <button class="btn btn-info" onclick="showSavedTeams()" style="flex: 1; background: linear-gradient(135deg, #17a2b8, #138496); color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: 600;">
                        📂 Load Team
                    </button>
                </div>
                
                <!-- Image Upload Feature -->
                <div style="margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 10px;">
                    <h3 style="color: white; margin-bottom: 10px; font-size: 1rem;">📸 Import Your Team</h3>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button onclick="createManualTeamBuilder()" style="flex: 1; padding: 10px; background: white; color: #667eea; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            🏗️ Build Team Manually
                        </button>
                        <input type="file" id="teamImageUpload" accept="image/*" style="display: none;" onchange="processTeamImage(event)">
                        <button onclick="document.getElementById('teamImageUpload').click()" style="flex: 1; padding: 10px; background: rgba(255,255,255,0.9); color: #667eea; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            📷 Upload Screenshot
                        </button>
                    </div>
                    <div id="imageProcessingStatus" style="margin-top: 10px; color: white; font-size: 0.9rem; display: none;">
                        <div class="spinner" style="width: 20px; height: 20px; margin: 0 auto;"></div>
                        <p style="margin-top: 5px;">Processing image...</p>
                    </div>
                    <div style="margin-top: 10px;">
                        <button onclick="showManualPlayerEntry()" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; cursor: pointer; font-size: 0.9rem;">
                            ✏️ Or Enter Players Manually
                        </button>
                    </div>
                </div>
            </div>

            <!-- Center Panel - Player Market -->
            <div>
                <div class="player-market panel">
                    <h2>🏪 Transfer Market</h2>
                    
                    <div class="market-filters">
                        <div class="filter-group">
                            <label>Position</label>
                            <select id="positionFilter" onchange="filterPlayers()">
                                <option value="">All Positions</option>
                                <option value="1">Goalkeepers</option>
                                <option value="2">Defenders</option>
                                <option value="3">Midfielders</option>
                                <option value="4">Forwards</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Max Price</label>
                            <input type="range" id="priceFilter" min="40" max="150" value="150" onchange="filterPlayers()">
                            <span id="priceValue">£15.0m</span>
                        </div>
                        
                        <div class="filter-group">
                            <label>Min Form</label>
                            <input type="range" id="formFilter" min="0" max="10" value="0" step="0.5" onchange="filterPlayers()">
                            <span id="formValue">0.0</span>
                        </div>
                        
                        <div class="filter-group">
                            <label>Search Player</label>
                            <input type="text" id="searchPlayer" placeholder="Type player name..." onkeyup="filterPlayers()" style="padding: 8px; border: 2px solid #667eea; border-radius: 5px;">
                            <button onclick="searchAllPlayers()" style="margin-top: 5px; padding: 8px 15px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; width: 100%;">
                                🔍 Search All Players
                            </button>
                        </div>
                    </div>

                    <div class="search-instructions" id="searchInstructions">
                        <div class="search-prompt">
                            <div class="search-icon">🔍</div>
                            <h3>Search for Players to Add to Your Squad</h3>
                            <p>Use the search box above to find specific players, or click a position button below to browse by position:</p>
                            <div class="position-buttons">
                                <button class="position-btn" onclick="showPositionPlayers(1)">
                                    <span class="position-emoji">🥅</span>
                                    <span>Goalkeepers</span>
                                </button>
                                <button class="position-btn" onclick="showPositionPlayers(2)">
                                    <span class="position-emoji">🛡️</span>
                                    <span>Defenders</span>
                                </button>
                                <button class="position-btn" onclick="showPositionPlayers(3)">
                                    <span class="position-emoji">⚽</span>
                                    <span>Midfielders</span>
                                </button>
                                <button class="position-btn" onclick="showPositionPlayers(4)">
                                    <span class="position-emoji">⚡</span>
                                    <span>Forwards</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="player-cards" id="playerCards" style="display: none;">
                        <!-- Players will be loaded here after search -->
                    </div>
                </div>

                <!-- Analytics Section -->
                <div class="analytics-section">
                    <div class="chart-container">
                        <h3>📊 Squad Value Distribution</h3>
                        <canvas id="valueChart"></canvas>
                    </div>
                    
                    <div class="chart-container">
                        <h3>📈 Expected Points by Position</h3>
                        <canvas id="pointsChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Right Panel - What-If Scenarios -->
            <div>
                <div class="scenario-panel">
                    <h2>🎯 What-If Scenarios</h2>
                    
                    <div class="scenario-item" onclick="runScenario('wildcard')">
                        <div class="scenario-title">🃏 Wildcard Optimization</div>
                        <div class="scenario-description">Build the best possible team within budget</div>
                        <div class="scenario-result" id="wildcard-result"></div>
                    </div>
                    
                    <div class="scenario-item" onclick="runScenario('differential')">
                        <div class="scenario-title">🎲 Differential Team</div>
                        <div class="scenario-description">Low ownership, high potential players</div>
                        <div class="scenario-result" id="differential-result"></div>
                    </div>
                    
                    <div class="scenario-item" onclick="runScenario('budget')">
                        <div class="scenario-title">💰 Budget Team</div>
                        <div class="scenario-description">Maximum value for money</div>
                        <div class="scenario-result" id="budget-result"></div>
                    </div>
                    
                    <div class="scenario-item" onclick="runScenario('premium')">
                        <div class="scenario-title">⭐ Premium Heavy</div>
                        <div class="scenario-description">Focus on expensive star players</div>
                        <div class="scenario-result" id="premium-result"></div>
                    </div>
                    
                    <div class="scenario-item" onclick="runScenario('rotation')">
                        <div class="scenario-title">🔄 Rotation Strategy</div>
                        <div class="scenario-description">Optimize for fixture rotation</div>
                        <div class="scenario-result" id="rotation-result"></div>
                    </div>
                </div>

                <!-- Transfer History -->
                <div class="transfer-history panel">
                    <h2>📜 Transfer History</h2>
                    <div id="transferHistory">
                        <div class="history-item">
                            <div class="history-icon history-in">➕</div>
                            <div>
                                <div style="font-weight: 700;">No transfers yet</div>
                                <div style="color: #666; font-size: 0.9rem;">Start building your team</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Fixture Difficulty Analysis -->
        <div class="fixture-analysis-section">
            <h2>📅 Fixture Difficulty Analysis (Next 5 GWs)</h2>
            <div class="fixture-filter">
                <button class="fixture-btn active" onclick="showFixtures('all')">All Teams</button>
                <button class="fixture-btn" onclick="showFixtures('easy')">Easy Fixtures</button>
                <button class="fixture-btn" onclick="showFixtures('hard')">Hard Fixtures</button>
            </div>
            <div class="fixture-grid" id="fixtureGrid">
                <!-- Fixture difficulty will be loaded here -->
            </div>
        </div>

        <!-- Player Comparison Matrix -->
        <div class="comparison-section">
            <h2>⚖️ Player Comparison Matrix</h2>
            <div class="comparison-controls">
                <select id="comparePosition" onchange="updateComparisonPlayers()">
                    <option value="">Select Position</option>
                    <option value="1">Goalkeepers</option>
                    <option value="2">Defenders</option>
                    <option value="3">Midfielders</option>
                    <option value="4">Forwards</option>
                </select>
                <select id="comparePlayer1" onchange="updateComparison()">
                    <option value="">Player 1</option>
                </select>
                <select id="comparePlayer2" onchange="updateComparison()">
                    <option value="">Player 2</option>
                </select>
                <select id="comparePlayer3" onchange="updateComparison()">
                    <option value="">Player 3</option>
                </select>
            </div>
            <div class="comparison-table" id="comparisonTable">
                <div class="comparison-placeholder">Select position and players to compare</div>
            </div>
        </div>

        <!-- Price Change Predictions -->
        <div class="price-change-section">
            <h2>📈 Price Change Predictions</h2>
            <div class="price-change-tabs">
                <button class="price-tab active" onclick="showPriceChanges('risers')">🔥 Likely Risers</button>
                <button class="price-tab" onclick="showPriceChanges('fallers')">📉 Likely Fallers</button>
            </div>
            <div class="price-change-grid" id="priceChangeGrid">
                <!-- Price predictions will be loaded here -->
            </div>
        </div>

        <!-- Captain Prediction -->
        <div class="captain-section">
            <h2>👑 Captain Prediction Algorithm</h2>
            <div class="captain-analysis">
                <div class="captain-card top-captain">
                    <div class="captain-rank">#1</div>
                    <div class="captain-info">
                        <div class="captain-name">Erling Haaland</div>
                        <div class="captain-details">vs Southampton (H) • 89% confidence</div>
                        <div class="captain-stats">
                            <span>xPts: 12.4</span>
                            <span>Form: 9.2</span>
                            <span>Fixture: 2/5</span>
                        </div>
                    </div>
                    <div class="captain-confidence">89%</div>
                </div>
                <div class="captain-alternatives">
                    <div class="captain-card">
                        <div class="captain-rank">#2</div>
                        <div class="captain-info">
                            <div class="captain-name">Mohamed Salah</div>
                            <div class="captain-details">vs Brighton (A) • 76% confidence</div>
                        </div>
                        <div class="captain-confidence">76%</div>
                    </div>
                    <div class="captain-card">
                        <div class="captain-rank">#3</div>
                        <div class="captain-info">
                            <div class="captain-name">Cole Palmer</div>
                            <div class="captain-details">vs Wolves (H) • 68% confidence</div>
                        </div>
                        <div class="captain-confidence">68%</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI Recommendations -->
        <div class="ai-recommendations">
            <h2>🤖 AI Transfer Recommendations</h2>
            <div id="aiRecommendations">
                <div class="recommendation-card">
                    <div class="recommendation-icon">💡</div>
                    <div class="recommendation-content">
                        <div class="recommendation-title">Loading AI insights...</div>
                        <div class="recommendation-details">Analyzing player data and fixtures</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 🚀 ADVANCED FEATURES PANEL -->
        <div class="advanced-features-panel">
            <h2>🚀 Advanced Analytics Suite</h2>
            <div class="feature-grid">
                <div class="feature-card" onclick="showChemistryAnalysis()">
                    <div class="feature-icon">🧪</div>
                    <div class="feature-title">Squad Chemistry</div>
                    <div class="feature-description">Analyze team synergy and nationality bonuses</div>
                </div>
                
                <div class="feature-card" onclick="showMarketSentiment()">
                    <div class="feature-icon">📊</div>
                    <div class="feature-title">Market Sentiment</div>
                    <div class="feature-description">Real-time social buzz and trending players</div>
                </div>
                
                <div class="feature-card" onclick="showWildcardPlanner()">
                    <div class="feature-icon">🎯</div>
                    <div class="feature-title">Wildcard Planner</div>
                    <div class="feature-description">Optimal timing and template strategies</div>
                </div>
                
                <div class="feature-card" onclick="showInjuryRisk()">
                    <div class="feature-icon">🏥</div>
                    <div class="feature-title">Injury Risk</div>
                    <div class="feature-description">Assess player fitness and return dates</div>
                </div>
                
                <div class="feature-card" onclick="showHistoricalTrends()">
                    <div class="feature-icon">📈</div>
                    <div class="feature-title">Historical Analysis</div>
                    <div class="feature-description">Multi-season performance trends</div>
                </div>
                
                <div class="feature-card" onclick="showAdvancedOptimizer()">
                    <div class="feature-icon">🤖</div>
                    <div class="feature-title">AI Optimizer Pro</div>
                    <div class="feature-description">Next-gen team building with ML predictions</div>
                </div>
                
                <div class="feature-card" onclick="showPriceTracker()">
                    <div class="feature-icon">💹</div>
                    <div class="feature-title">Price Tracker</div>
                    <div class="feature-description">Real-time price alerts & predictions</div>
                </div>
                
                <div class="feature-card" onclick="showSquadComparison()">
                    <div class="feature-icon">⚔️</div>
                    <div class="feature-title">Squad Comparison</div>
                    <div class="feature-description">Compare with top managers & find differentials</div>
                </div>
                
                <div class="feature-card" onclick="showFDRAnalysis()">
                    <div class="feature-icon">📅</div>
                    <div class="feature-title">FDR Calculator</div>
                    <div class="feature-description">Advanced fixture difficulty analysis</div>
                </div>
                
                <div class="feature-card" onclick="showStrategySimulator()">
                    <div class="feature-icon">🎮</div>
                    <div class="feature-title">Strategy Simulator</div>
                    <div class="feature-description">Multi-week transfer planning</div>
                </div>
                
                <div class="feature-card" onclick="showXGStats()">
                    <div class="feature-icon">📊</div>
                    <div class="feature-title">xG Analytics</div>
                    <div class="feature-description">Expected goals & advanced metrics</div>
                </div>
                
                <div class="feature-card" onclick="showCompetitorAnalysis()">
                    <div class="feature-icon">🏆</div>
                    <div class="feature-title">League Analysis</div>
                    <div class="feature-description">Mini-league competitor tracking</div>
                </div>
                
                <div class="feature-card" onclick="showChipOptimizer()">
                    <div class="feature-icon">🎯</div>
                    <div class="feature-title">Chip Strategy</div>
                    <div class="feature-description">Optimize TC, BB, FH timing</div>
                </div>
                
                <div class="feature-card" onclick="showOwnershipHeatmap()">
                    <div class="feature-icon">🗺️</div>
                    <div class="feature-title">Ownership Map</div>
                    <div class="feature-description">Find hidden gems & differentials</div>
                </div>
                
                <div class="feature-card" onclick="showCaptainOptimizer()">
                    <div class="feature-icon">👑</div>
                    <div class="feature-title">Captain AI</div>
                    <div class="feature-description">ML-powered captaincy picks</div>
                </div>
            </div>
            
            <!-- Quick Analytics Display -->
            <div id="quickAnalytics" style="margin-top: 30px;">
                <div class="chemistry-display" style="display: none;" id="chemistryDisplay">
                    <h3>⚗️ Squad Chemistry Score</h3>
                    <div class="chemistry-score" id="chemistryScore">0</div>
                    <div class="synergy-bonuses" id="synergyBonuses"></div>
                </div>
                
                <div class="market-sentiment-widget" style="display: none;" id="sentimentWidget">
                    <h3>📊 Market Sentiment Dashboard</h3>
                    <div class="trending-players" id="trendingPlayers"></div>
                </div>
                
                <div class="wildcard-planner" style="display: none;" id="wildcardWidget">
                    <h3>🎯 Wildcard Strategy Planner</h3>
                    <div class="optimal-timing">
                        <div>Optimal Timing:</div>
                        <div class="gameweek-recommendation" id="optimalGW">GW 18</div>
                        <div>Based on fixture analysis and DGW schedule</div>
                    </div>
                    <div class="template-selector">
                        <button class="template-btn active" onclick="selectTemplate('balanced')">Balanced</button>
                        <button class="template-btn" onclick="selectTemplate('aggressive')">Aggressive</button>
                        <button class="template-btn" onclick="selectTemplate('defensive')">Defensive</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Transfer Market Statistics -->
        <div class="transfer-stats-section">
            <h2>📊 Transfer Market Statistics 2024/25</h2>
            
            <div class="stats-grid">
                <!-- Top Spending Clubs -->
                <div class="stat-panel">
                    <h3>💰 Top Spending Clubs</h3>
                    <div class="spending-list">
                        <div class="spending-item">
                            <div class="club-rank">1</div>
                            <div class="club-info">
                                <div class="club-name">Liverpool</div>
                                <div class="club-spending">£252.2M</div>
                            </div>
                            <div class="spending-bar" style="width: 100%;"></div>
                        </div>
                        <div class="spending-item">
                            <div class="club-rank">2</div>
                            <div class="club-info">
                                <div class="club-name">Chelsea</div>
                                <div class="club-spending">£240.2M</div>
                            </div>
                            <div class="spending-bar" style="width: 95%;"></div>
                        </div>
                        <div class="spending-item">
                            <div class="club-rank">3</div>
                            <div class="club-info">
                                <div class="club-name">Manchester United</div>
                                <div class="club-spending">£205.2M</div>
                            </div>
                            <div class="spending-bar" style="width: 81%;"></div>
                        </div>
                        <div class="spending-item">
                            <div class="club-rank">4</div>
                            <div class="club-info">
                                <div class="club-name">Arsenal</div>
                                <div class="club-spending">£192.8M</div>
                            </div>
                            <div class="spending-bar" style="width: 76%;"></div>
                        </div>
                        <div class="spending-item">
                            <div class="club-rank">5</div>
                            <div class="club-info">
                                <div class="club-name">Manchester City</div>
                                <div class="club-spending">£153.4M</div>
                            </div>
                            <div class="spending-bar" style="width: 61%;"></div>
                        </div>
                    </div>
                </div>

                <!-- Transfer Trends -->
                <div class="stat-panel">
                    <h3>📈 Transfer Trends</h3>
                    <div class="trend-stats">
                        <div class="trend-item">
                            <div class="trend-label">Average Transfer Fee</div>
                            <div class="trend-value">£42.3M</div>
                            <div class="trend-detail">for deals over £20M</div>
                        </div>
                        <div class="trend-item">
                            <div class="trend-label">Most Active Club</div>
                            <div class="trend-value">Burnley</div>
                            <div class="trend-detail">10 transfers</div>
                        </div>
                        <div class="trend-item">
                            <div class="trend-label">Biggest Sale</div>
                            <div class="trend-value">Mbeumo £71M</div>
                            <div class="trend-detail">Brentford → Liverpool</div>
                        </div>
                        <div class="trend-item">
                            <div class="trend-label">Free Transfers</div>
                            <div class="trend-value">12 Deals</div>
                            <div class="trend-detail">High-profile free agents</div>
                        </div>
                        <div class="trend-item">
                            <div class="trend-label">Loan Deals</div>
                            <div class="trend-value">31 Active</div>
                            <div class="trend-detail">Including buy options</div>
                        </div>
                    </div>
                </div>

                <!-- Transfer Routes -->
                <div class="stat-panel">
                    <h3>🌍 Transfer Routes</h3>
                    <div class="routes-chart">
                        <div class="route-item">
                            <div class="route-name">From Abroad</div>
                            <div class="route-bar-container">
                                <div class="route-bar" style="width: 43%;">
                                    <span>43%</span>
                                </div>
                            </div>
                        </div>
                        <div class="route-item">
                            <div class="route-name">Domestic</div>
                            <div class="route-bar-container">
                                <div class="route-bar" style="width: 38%;">
                                    <span>38%</span>
                                </div>
                            </div>
                        </div>
                        <div class="route-item">
                            <div class="route-name">To Saudi League</div>
                            <div class="route-bar-container">
                                <div class="route-bar saudi" style="width: 12%;">
                                    <span>12%</span>
                                </div>
                            </div>
                        </div>
                        <div class="route-item">
                            <div class="route-name">To MLS</div>
                            <div class="route-bar-container">
                                <div class="route-bar mls" style="width: 7%;">
                                    <span>7%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="route-legend">
                        <div class="legend-item">
                            <span class="legend-color" style="background: #37003c;"></span>
                            <span>Premier League</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #00c851;"></span>
                            <span>Saudi Pro League</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #ff4444;"></span>
                            <span>MLS</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="footer" include="./footer.html"></div>
    
    <div class="loading-overlay" id="loadingOverlay" style="display: none;">
        <div class="loading-spinner"></div>
    </div>

    <!-- Floating Action Button Menu -->
    <div class="floating-menu">
        <div class="fab-menu" id="fabMenu">
            <button class="fab-item" onclick="showCaptainOptimizer()">
                👑
                <span class="fab-tooltip">Captain AI</span>
            </button>
            <button class="fab-item" onclick="showPriceTracker()">
                💹
                <span class="fab-tooltip">Price Tracker</span>
            </button>
            <button class="fab-item" onclick="showSquadComparison()">
                ⚔️
                <span class="fab-tooltip">Squad Compare</span>
            </button>
            <button class="fab-item" onclick="showStrategySimulator()">
                🎮
                <span class="fab-tooltip">Transfer Plan</span>
            </button>
            <button class="fab-item" onclick="showXGStats()">
                📊
                <span class="fab-tooltip">xG Stats</span>
            </button>
        </div>
        <button class="fab-main" onclick="toggleFabMenu()">
            🚀
        </button>
    </div>

    <script src="./index.js"></script>
    <script>
        // Embedded FPL Data - Compressed version with essential fields only
        // This data is pre-loaded to avoid CORS issues and ensure immediate availability
        const EMBEDDED_FPL_DATA = {"p":[{"id":470,"f":"Martin","s":"Dúbravka","w":"Dúbravka","t":3,"e":1,"c":40,"p":0,"o":"0.0","x":"35.5","g":0,"a":0},{"id":220,"f":"Robert","s":"Lynch Sánchez","w":"Sánchez","t":7,"e":1,"c":50,"p":0,"o":"0.0","x":"25.6","g":0,"a":0},{"id":502,"f":"Matz","s":"Sels","w":"Sels","t":16,"e":1,"c":50,"p":0,"o":"0.0","x":"21.3","g":0,"a":0},{"id":1,"f":"David","s":"Raya Martín","w":"Raya","t":1,"e":1,"c":55,"p":0,"o":"0.0","x":"16.2","g":0,"a":0},{"id":101,"f":"Caoimhín","s":"Kelleher","w":"Kelleher","t":5,"e":1,"c":45,"p":0,"o":"0.0","x":"11.7","g":0,"a":0},{"id":287,"f":"Jordan","s":"Pickford","w":"Pickford","t":9,"e":1,"c":55,"p":0,"o":"0.0","x":"11.6","g":0,"a":0},{"id":366,"f":"Alisson","s":"Becker","w":"A.Becker","t":12,"e":1,"c":55,"p":0,"o":"0.0","x":"11.5","g":0,"a":0},{"id":139,"f":"Bart","s":"Verbruggen","w":"Verbruggen","t":6,"e":1,"c":45,"p":0,"o":"0.0","x":"8.1","g":0,"a":0},{"id":253,"f":"Dean","s":"Henderson","w":"Henderson","t":8,"e":1,"c":50,"p":0,"o":"0.0","x":"6.9","g":0,"a":0},{"id":600,"f":"Alphonse","s":"Areola","w":"Areola","t":19,"e":1,"c":45,"p":0,"o":"0.0","x":"4.9","g":0,"a":0},{"id":565,"f":"Guglielmo","s":"Vicario","w":"Vicario","t":18,"e":1,"c":50,"p":0,"o":"0.0","x":"4.2","g":0,"a":0},{"id":469,"f":"Nick","s":"Pope","w":"Pope","t":15,"e":1,"c":50,"p":0,"o":"0.0","x":"3.4","g":0,"a":0},{"id":341,"f":"Karl","s":"Darlow","w":"Darlow","t":11,"e":1,"c":40,"p":0,"o":"0.0","x":"3.3","g":0,"a":0},{"id":399,"f":"Ederson","s":"Santana de Moraes","w":"Ederson M.","t":13,"e":1,"c":55,"p":0,"o":"0.0","x":"3.2","g":0,"a":0},{"id":67,"f":"Đorđe","s":"Petrović","w":"Petrović","t":4,"e":1,"c":45,"p":0,"o":"0.0","x":"3.0","g":0,"a":0},{"id":567,"f":"Antonín","s":"Kinský","w":"Kinsky","t":18,"e":1,"c":40,"p":0,"o":"0.0","x":"2.3","g":0,"a":0},{"id":628,"f":"José","s":"Malheiro de Sá","w":"José Sá","t":20,"e":1,"c":45,"p":0,"o":"0.0","x":"2.1","g":0,"a":0},{"id":182,"f":"James","s":"Trafford","w":"Trafford","t":13,"e":1,"c":50,"p":0,"o":"0.0","x":"1.8","g":0,"a":0},{"id":675,"f":"Angus","s":"Gunn","w":"Gunn","t":16,"e":1,"c":40,"p":0,"o":"0.0","x":"1.8","g":0,"a":0},{"id":314,"f":"Bernd","s":"Leno","w":"Leno","t":10,"e":1,"c":50,"p":0,"o":"0.0","x":"1.6","g":0,"a":0},{"id":630,"f":"Tom","s":"King","w":"King","t":20,"e":1,"c":40,"p":0,"o":"0.0","x":"1.6","g":0,"a":0},{"id":105,"f":"Hákon Rafn","s":"Valdimarsson","w":"Valdimarsson","t":5,"e":1,"c":40,"p":0,"o":"0.0","x":"1.1","g":0,"a":0},{"id":2,"f":"Kepa","s":"Arrizabalaga Revuelta","w":"Arrizabalaga","t":1,"e":1,"c":45,"p":0,"o":"0.0","x":"1.0","g":0,"a":0},{"id":68,"f":"Will","s":"Dennis","w":"Dennis","t":4,"e":1,"c":40,"p":0,"o":"0.0","x":"1.0","g":0,"a":0},{"id":664,"f":"Benjamin","s":"Lecomte","w":"Lecomte","t":10,"e":1,"c":40,"p":0,"o":"0.0","x":"0.9","g":0,"a":0},{"id":370,"f":"Jeremie","s":"Frimpong","w":"Frimpong","t":12,"e":2,"c":60,"p":0,"o":"0.0","x":"31.8","g":0,"a":0},{"id":575,"f":"Micky","s":"van de Ven","w":"Van de Ven","t":18,"e":2,"c":45,"p":0,"o":"0.0","x":"27.9","g":0,"a":0},{"id":610,"f":"Aaron","s":"Wan-Bissaka","w":"Wan-Bissaka","t":19,"e":2,"c":45,"p":0,"o":"0.0","x":"26.2","g":0,"a":0},{"id":373,"f":"Virgil","s":"van Dijk","w":"Virgil","t":12,"e":2,"c":60,"p":0,"o":"0.0","x":"23.5","g":0,"a":0},{"id":38,"f":"Ezri","s":"Konsa Ngoyo","w":"Konsa","t":2,"e":2,"c":45,"p":0,"o":"0.0","x":"23.3","g":0,"a":0},{"id":568,"f":"Pedro","s":"Porro Sauceda","w":"Pedro Porro","t":18,"e":2,"c":55,"p":0,"o":"0.0","x":"22.9","g":0,"a":0},{"id":191,"f":"Maxime","s":"Estève","w":"Estève","t":3,"e":2,"c":40,"p":0,"o":"0.0","x":"21.0","g":0,"a":0},{"id":402,"f":"Rayan","s":"Aït-Nouri","w":"Aït-Nouri","t":13,"e":2,"c":60,"p":0,"o":"0.0","x":"20.8","g":0,"a":0},{"id":224,"f":"Marc","s":"Cucurella Saseta","w":"Cucurella","t":7,"e":2,"c":60,"p":0,"o":"0.0","x":"18.8","g":0,"a":0},{"id":5,"f":"Gabriel","s":"dos Santos Magalhães","w":"Gabriel","t":1,"e":2,"c":60,"p":0,"o":"0.0","x":"17.9","g":0,"a":0},{"id":507,"f":"Ola","s":"Aina","w":"Aina","t":16,"e":2,"c":50,"p":0,"o":"0.0","x":"15.3","g":0,"a":0},{"id":6,"f":"William","s":"Saliba","w":"Saliba","t":1,"e":2,"c":60,"p":0,"o":"0.0","x":"13.3","g":0,"a":0},{"id":260,"f":"Marc","s":"Guéhi","w":"Guéhi","t":8,"e":2,"c":45,"p":0,"o":"0.0","x":"12.6","g":0,"a":0},{"id":403,"f":"Joško","s":"Gvardiol","w":"Gvardiol","t":13,"e":2,"c":60,"p":0,"o":"0.0","x":"11.4","g":0,"a":0},{"id":508,"f":"Neco","s":"Williams","w":"N.Williams","t":16,"e":2,"c":50,"p":0,"o":"0.0","x":"10.9","g":0,"a":0},{"id":505,"f":"Nikola","s":"Milenković","w":"Milenković","t":16,"e":2,"c":55,"p":0,"o":"0.0","x":"10.5","g":0,"a":0},{"id":43,"f":"Álex","s":"Moreno Lopera","w":"Alex Moreno","t":2,"e":2,"c":40,"p":0,"o":"0.0","x":"10.3","g":0,"a":0},{"id":256,"f":"Daniel","s":"Muñoz Mejía","w":"Muñoz","t":8,"e":2,"c":55,"p":0,"o":"0.0","x":"8.6","g":0,"a":0},{"id":603,"f":"El Hadji Malick","s":"Diouf","w":"Diouf","t":19,"e":2,"c":45,"p":0,"o":"0.0","x":"8.1","g":0,"a":0},{"id":291,"f":"James","s":"Tarkowski","w":"Tarkowski","t":9,"e":2,"c":55,"p":0,"o":"0.0","x":"7.4","g":0,"a":0},{"id":506,"f":"Murillo","s":"Costa dos Santos","w":"Murillo","t":16,"e":2,"c":55,"p":0,"o":"0.0","x":"7.2","g":0,"a":0},{"id":371,"f":"Milos","s":"Kerkez","w":"Kerkez","t":12,"e":2,"c":60,"p":0,"o":"0.0","x":"7.1","g":0,"a":0},{"id":541,"f":"Reinildo","s":"Mandava","w":"Reinildo","t":17,"e":2,"c":40,"p":0,"o":"0.0","x":"7.1","g":0,"a":0},{"id":145,"f":"Maxim","s":"De Cuyper","w":"De Cuyper","t":6,"e":2,"c":45,"p":0,"o":"0.0","x":"6.7","g":0,"a":0},{"id":441,"f":"Patrick","s":"Dorgu","w":"Dorgu","t":14,"e":2,"c":45,"p":0,"o":"0.0","x":"6.7","g":0,"a":0},{"id":235,"f":"Cole","s":"Palmer","w":"Palmer","t":7,"e":3,"c":105,"p":0,"o":"0.0","x":"63.9","g":0,"a":0},{"id":381,"f":"Mohamed","s":"Salah","w":"M.Salah","t":12,"e":3,"c":145,"p":0,"o":"0.0","x":"55.0","g":0,"a":0},{"id":382,"f":"Florian","s":"Wirtz","w":"Wirtz","t":12,"e":3,"c":85,"p":0,"o":"0.0","x":"35.1","g":0,"a":0},{"id":582,"f":"Mohammed","s":"Kudus","w":"Kudus","t":18,"e":3,"c":65,"p":0,"o":"0.0","x":"25.2","g":0,"a":0},{"id":449,"f":"Bruno","s":"Borges Fernandes","w":"B.Fernandes","t":14,"e":3,"c":90,"p":0,"o":"0.0","x":"22.3","g":0,"a":0},{"id":427,"f":"Tijjani","s":"Reijnders","w":"Reijnders","t":13,"e":3,"c":55,"p":0,"o":"0.0","x":"19.2","g":0,"a":0},{"id":16,"f":"Bukayo","s":"Saka","w":"Saka","t":1,"e":3,"c":100,"p":0,"o":"0.0","x":"16.9","g":0,"a":0},{"id":119,"f":"Bryan","s":"Mbeumo","w":"Mbeumo","t":14,"e":3,"c":80,"p":0,"o":"0.0","x":"13.9","g":0,"a":0},{"id":299,"f":"Iliman","s":"Ndiaye","w":"Ndiaye","t":9,"e":3,"c":65,"p":0,"o":"0.0","x":"12.4","g":0,"a":0},{"id":413,"f":"Omar","s":"Marmoush","w":"Marmoush","t":13,"e":3,"c":85,"p":0,"o":"0.0","x":"11.5","g":0,"a":0},{"id":266,"f":"Eberechi","s":"Eze","w":"Eze","t":8,"e":3,"c":75,"p":0,"o":"0.0","x":"10.5","g":0,"a":0},{"id":211,"f":"Aaron","s":"Ramsey","w":"A.Ramsey","t":3,"e":3,"c":45,"p":0,"o":"0.0","x":"10.3","g":0,"a":0},{"id":47,"f":"Morgan","s":"Rogers","w":"Rogers","t":2,"e":3,"c":70,"p":0,"o":"0.0","x":"10.2","g":0,"a":0},{"id":486,"f":"Anthony","s":"Elanga","w":"Elanga","t":15,"e":3,"c":70,"p":0,"o":"0.0","x":"8.6","g":0,"a":0},{"id":417,"f":"Rayan","s":"Cherki","w":"Cherki","t":13,"e":3,"c":65,"p":0,"o":"0.0","x":"7.9","g":0,"a":0},{"id":450,"f":"Matheus","s":"Santos Carneiro da Cunha","w":"Cunha","t":14,"e":3,"c":80,"p":0,"o":"0.0","x":"7.8","g":0,"a":0},{"id":21,"f":"Declan","s":"Rice","w":"Rice","t":1,"e":3,"c":65,"p":0,"o":"0.0","x":"7.7","g":0,"a":0},{"id":157,"f":"Mitoma","s":"Kaoru","w":"Mitoma","t":6,"e":3,"c":65,"p":0,"o":"0.0","x":"7.4","g":0,"a":0},{"id":384,"f":"Cody","s":"Gakpo","w":"Gakpo","t":12,"e":3,"c":75,"p":0,"o":"0.0","x":"7.3","g":0,"a":0},{"id":517,"f":"Elliot","s":"Anderson","w":"Anderson","t":16,"e":3,"c":55,"p":0,"o":"0.0","x":"7.0","g":0,"a":0},{"id":241,"f":"Moisés","s":"Caicedo Corozo","w":"Caicedo","t":7,"e":3,"c":55,"p":0,"o":"0.0","x":"5.4","g":0,"a":0},{"id":267,"f":"Ismaïla","s":"Sarr","w":"Sarr","t":8,"e":3,"c":65,"p":0,"o":"0.0","x":"5.3","g":0,"a":0},{"id":515,"f":"Morgan","s":"Gibbs-White","w":"Gibbs-White","t":16,"e":3,"c":75,"p":0,"o":"0.0","x":"5.3","g":0,"a":0},{"id":242,"f":"Kiernan","s":"Dewsbury-Hall","w":"Dewsbury-Hall","t":9,"e":3,"c":50,"p":0,"o":"0.0","x":"5.0","g":0,"a":0},{"id":82,"f":"Antoine","s":"Semenyo","w":"Semenyo","t":4,"e":3,"c":70,"p":0,"o":"0.0","x":"4.9","g":0,"a":0},{"id":249,"f":"João Pedro","s":"Junqueira de Jesus","w":"João Pedro","t":7,"e":4,"c":75,"p":0,"o":"0.0","x":"57.0","g":0,"a":0},{"id":64,"f":"Ollie","s":"Watkins","w":"Watkins","t":2,"e":4,"c":90,"p":0,"o":"0.0","x":"28.1","g":0,"a":0},{"id":666,"f":"Viktor","s":"Gyökeres","w":"Gyökeres","t":1,"e":4,"c":90,"p":0,"o":"0.0","x":"25.8","g":0,"a":0},{"id":430,"f":"Erling","s":"Haaland","w":"Haaland","t":13,"e":4,"c":140,"p":0,"o":"0.0","x":"24.1","g":0,"a":0},{"id":252,"f":"Marc","s":"Guiu Paz","w":"Marc Guiu","t":17,"e":4,"c":45,"p":0,"o":"0.0","x":"20.9","g":0,"a":0},{"id":624,"f":"Jarrod","s":"Bowen","w":"Bowen","t":19,"e":4,"c":80,"p":0,"o":"0.0","x":"17.9","g":0,"a":0},{"id":661,"f":"Hugo","s":"Ekitiké","w":"Ekitiké","t":12,"e":4,"c":85,"p":0,"o":"0.0","x":"14.7","g":0,"a":0},{"id":525,"f":"Chris","s":"Wood","w":"Wood","t":16,"e":4,"c":75,"p":0,"o":"0.0","x":"13.3","g":0,"a":0},{"id":283,"f":"Jean-Philippe","s":"Mateta","w":"Mateta","t":8,"e":4,"c":75,"p":0,"o":"0.0","x":"9.4","g":0,"a":0},{"id":311,"f":"Norberto Bercique","s":"Gomes Betuncal","w":"Beto","t":9,"e":4,"c":55,"p":0,"o":"0.0","x":"9.0","g":0,"a":0},{"id":499,"f":"Alexander","s":"Isak","w":"Isak","t":15,"e":4,"c":105,"p":0,"o":"0.0","x":"8.8","g":0,"a":0},{"id":681,"f":"Benjamin","s":"Sesko","w":"Šeško","t":14,"e":4,"c":75,"p":0,"o":"0.0","x":"8.3","g":0,"a":0},{"id":596,"f":"Dominic","s":"Solanke-Mitchell","w":"Solanke","t":18,"e":4,"c":75,"p":0,"o":"0.0","x":"5.0","g":0,"a":0},{"id":654,"f":"Jørgen","s":"Strand Larsen","w":"Strand Larsen","t":20,"e":4,"c":65,"p":0,"o":"0.0","x":"5.0","g":0,"a":0},{"id":178,"f":"Danny","s":"Welbeck","w":"Welbeck","t":6,"e":4,"c":65,"p":0,"o":"0.0","x":"4.7","g":0,"a":0},{"id":250,"f":"Liam","s":"Delap","w":"Delap","t":7,"e":4,"c":65,"p":0,"o":"0.0","x":"4.2","g":0,"a":0},{"id":625,"f":"Niclas","s":"Füllkrug","w":"Füllkrug","t":19,"e":4,"c":60,"p":0,"o":"0.0","x":"3.9","g":0,"a":0},{"id":135,"f":"Yoane","s":"Wissa","w":"Wissa","t":5,"e":4,"c":75,"p":0,"o":"0.0","x":"2.8","g":0,"a":0},{"id":218,"f":"Ashley","s":"Barnes","w":"Barnes","t":3,"e":4,"c":45,"p":0,"o":"0.0","x":"2.6","g":0,"a":0},{"id":467,"f":"Chido","s":"Obi","w":"Obi","t":14,"e":4,"c":45,"p":0,"o":"0.0","x":"2.4","g":0,"a":0},{"id":337,"f":"Raúl","s":"Jiménez Rodríguez","w":"Raúl","t":10,"e":4,"c":65,"p":0,"o":"0.0","x":"2.3","g":0,"a":0},{"id":658,"f":"Nathan","s":"Fraser","w":"Fraser","t":20,"e":4,"c":45,"p":0,"o":"0.0","x":"2.3","g":0,"a":0},{"id":362,"f":"Joël","s":"Piroe","w":"Piroe","t":11,"e":4,"c":55,"p":0,"o":"0.0","x":"2.2","g":0,"a":0},{"id":363,"f":"Patrick","s":"Bamford","w":"Bamford","t":11,"e":4,"c":50,"p":0,"o":"0.0","x":"2.1","g":0,"a":0},{"id":97,"f":"Francisco Evanilson","s":"de Lima Barbosa","w":"Evanilson","t":4,"e":4,"c":70,"p":0,"o":"0.0","x":"1.9","g":0,"a":0}],"t":[{"id":1,"n":"Arsenal","s":"ARS"},{"id":2,"n":"Aston Villa","s":"AVL"},{"id":3,"n":"Burnley","s":"BUR"},{"id":4,"n":"Bournemouth","s":"BOU"},{"id":5,"n":"Brentford","s":"BRE"},{"id":6,"n":"Brighton","s":"BHA"},{"id":7,"n":"Chelsea","s":"CHE"},{"id":8,"n":"Crystal Palace","s":"CRY"},{"id":9,"n":"Everton","s":"EVE"},{"id":10,"n":"Fulham","s":"FUL"},{"id":11,"n":"Leeds","s":"LEE"},{"id":12,"n":"Liverpool","s":"LIV"},{"id":13,"n":"Man City","s":"MCI"},{"id":14,"n":"Man Utd","s":"MUN"},{"id":15,"n":"Newcastle","s":"NEW"},{"id":16,"n":"Nott'm Forest","s":"NFO"},{"id":17,"n":"Sunderland","s":"SUN"},{"id":18,"n":"Spurs","s":"TOT"},{"id":19,"n":"West Ham","s":"WHU"},{"id":20,"n":"Wolves","s":"WOL"}]};
        
        // Expand compressed data helper function
        function expandPlayerData(compressedData) {
            const expanded = {
                elements: [],
                teams: []
            };
            
            // Expand players
            if (compressedData.p) {
                expanded.elements = compressedData.p.map(p => ({
                    id: p.id,
                    first_name: p.f,
                    second_name: p.s,
                    web_name: p.w,
                    team: p.t,
                    element_type: p.e,
                    now_cost: p.c,
                    total_points: p.p,
                    form: p.o,
                    selected_by_percent: p.x,
                    goals_scored: p.g,
                    assists: p.a,
                    // Add default values for other fields
                    minutes: 0,
                    clean_sheets: 0,
                    bonus: 0,
                    influence: "0",
                    creativity: "0",
                    threat: "0",
                    expected_goals: "0",
                    expected_assists: "0",
                    starts: 0
                }));
            }
            
            // Expand teams
            if (compressedData.t) {
                expanded.teams = compressedData.t.map(t => ({
                    id: t.id,
                    name: t.n,
                    short_name: t.s
                }));
            }
            
            return expanded;
        }
        
        // Transfer Simulator Pro
        class TransferSimulatorPro {
            constructor() {
                this.currentSquad = {
                    1: [], // GKP
                    2: [], // DEF
                    3: [], // MID
                    4: []  // FWD
                };
                this.budget = 1000; // £100.0m in tenths
                this.allPlayers = [];
                this.teams = [];
                this.transferHistory = [];
                this.charts = {};
            }

            async init() {
                console.log('Initializing Transfer Simulator Pro...');
                await this.loadPlayerData(); // Properly await async data loading
                console.log(`Player data loaded: ${this.allPlayers ? this.allPlayers.length : 0} players available`);
                this.initializeSquadSlots();
                this.setupEventListeners();
                this.initializeCharts();
                this.updateDisplay();
                this.loadAIRecommendations();
                this.initializeFixtureAnalysis();
                this.initializePlayerComparison();
                this.initializePriceChanges();
                this.initializeAllAdvancedSystems();
            }

            async loadFullPlayerData() {
                // Try to load complete data from player-data-2.html in the background
                try {
                    const response = await fetch('player-data-2.html', {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.elements && data.elements.length > this.allPlayers.length) {
                            this.allPlayers = data.elements;
                            this.teams = data.teams;
                            
                            // Update teams lookup
                            this.teamsLookup = {};
                            if (data.teams) {
                                data.teams.forEach(team => {
                                    this.teamsLookup[team.id] = {
                                        name: team.name,
                                        short_name: team.short_name
                                    };
                                });
                            }
                            
                            // Process player data
                            this.allPlayers = this.allPlayers.map(player => ({
                                ...player,
                                team_name: this.teamsLookup[player.team]?.name || 'Unknown',
                                team_short: this.teamsLookup[player.team]?.short_name || 'UNK',
                                display_name: `${player.first_name} ${player.second_name}`,
                                position_name: ['GKP', 'DEF', 'MID', 'FWD'][player.element_type - 1] || 'Unknown'
                            }));
                            
                            console.log(`Background load: Updated to ${this.allPlayers.length} players`);
                            document.getElementById('lastUpdate').textContent = `All ${this.allPlayers.length} players loaded`;
                            this.updateDisplay();
                        }
                    }
                } catch (error) {
                    console.log('Background load of full data failed:', error);
                }
            }
            
            async loadPlayerData() {
                console.log('Loading player data...');
                
                // Try to load from player-data-2.html first
                try {
                    const response = await fetch('player-data-2.html');
                    if (response.ok) {
                        const text = await response.text();
                        const data = JSON.parse(text);
                        
                        if (data && data.elements && data.elements.length > 0) {
                            console.log('Successfully loaded data from player-data-2.html');
                            this.allPlayers = data.elements;
                            this.teams = data.teams || this.getFallbackTeams();
                            
                            // Create teams lookup
                            this.teamsLookup = {};
                            if (this.teams) {
                                this.teams.forEach(team => {
                                    this.teamsLookup[team.id] = {
                                        name: team.name,
                                        short_name: team.short_name
                                    };
                                });
                            }
                            
                            // Process player data
                            this.allPlayers = this.allPlayers.map(player => ({
                                ...player,
                                team_name: this.teamsLookup[player.team]?.name || 'Unknown',
                                team_short: this.teamsLookup[player.team]?.short_name || 'UNK',
                                display_name: `${player.first_name} ${player.second_name}`,
                                position_name: ['GKP', 'DEF', 'MID', 'FWD'][player.element_type - 1] || 'Unknown'
                            }));
                            
                            console.log(`Loaded ${this.allPlayers.length} players from player-data-2.html`);
                            document.getElementById('lastUpdate').textContent = `${this.allPlayers.length} players loaded`;
                            
                            if (this.showNotification) {
                                this.showNotification(`✅ Loaded ${this.allPlayers.length} players!`, 'success');
                            }
                            return;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load from player-data-2.html:', error);
                }
                
                // Use embedded data - this will ALWAYS work since it's hardcoded
                if (typeof EMBEDDED_FPL_DATA !== 'undefined' && EMBEDDED_FPL_DATA) {
                    console.log('Using embedded player data...');
                    const data = expandPlayerData(EMBEDDED_FPL_DATA);
                    
                    this.allPlayers = data.elements || [];
                    this.teams = data.teams || [];
                    
                    // Create teams lookup
                    this.teamsLookup = {};
                    if (this.teams && this.teams.length > 0) {
                        this.teams.forEach(team => {
                            this.teamsLookup[team.id] = {
                                name: team.name,
                                short_name: team.short_name
                            };
                        });
                    }
                    
                    // Process player data with additional fields
                    if (this.allPlayers && this.allPlayers.length > 0) {
                        this.allPlayers = this.allPlayers.map(player => ({
                            ...player,
                            team_name: this.teamsLookup[player.team]?.name || 'Unknown',
                            team_short: this.teamsLookup[player.team]?.short_name || 'UNK',
                            display_name: `${player.first_name} ${player.second_name}`,
                            position_name: ['GKP', 'DEF', 'MID', 'FWD'][player.element_type - 1] || 'Unknown'
                        }));
                    }
                    
                    console.log(`Loaded ${this.allPlayers.length} players from embedded data`);
                    
                    // Update status
                    const statusEl = document.getElementById('lastUpdate');
                    if (statusEl) {
                        statusEl.textContent = `${this.allPlayers.length} players loaded`;
                    }
                    
                    // Show notification
                    this.showNotification(`✅ ${this.allPlayers.length} players ready!`, 'success');
                    
                    // Try to load more data in background
                    setTimeout(() => this.loadFullPlayerData(), 2000);
                    return;
                }
                
                // PRIORITY 2: Load from player-data-2.html (local cached data)
                try {
                    const localResponse = await fetch('player-data-2.html', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        }
                    });
                    
                    if (localResponse.ok) {
                        const data = await localResponse.json();
                        
                        if (data && data.elements && data.elements.length > 0) {
                            console.log('Successfully loaded data from player-data-2.html');
                            
                            // Store raw data
                            this.allPlayers = data.elements;
                            this.teams = data.teams;
                            
                            // Create teams lookup
                            this.teamsLookup = {};
                            if (data.teams) {
                                data.teams.forEach(team => {
                                    this.teamsLookup[team.id] = {
                                        name: team.name,
                                        short_name: team.short_name
                                    };
                                });
                            }
                            
                            // Process player data with additional fields
                            this.allPlayers = this.allPlayers.map(player => ({
                                ...player,
                                team_name: this.teamsLookup[player.team]?.name || 'Unknown',
                                team_short: this.teamsLookup[player.team]?.short_name || 'UNK',
                                display_name: `${player.first_name} ${player.second_name}`,
                                position_name: ['GKP', 'DEF', 'MID', 'FWD'][player.element_type - 1] || 'Unknown'
                            }));
                            
                            console.log(`Loaded ${this.allPlayers.length} players from player-data-2.html`);
                            
                            // Update status
                            const now = new Date();
                            const timeString = now.toLocaleTimeString();
                            document.getElementById('lastUpdate').textContent = `Loaded at ${timeString} (${this.allPlayers.length} players)`;
                            
                            // Show notification
                            this.showNotification(`✅ Loaded ${this.allPlayers.length} players from local data!`, 'success');
                            return; // Success! Exit early
                        }
                    }
                } catch (localError) {
                    console.warn('Failed to load from player-data-2.html:', localError);
                }
                
                // FALLBACK: Try other methods if local file fails
                console.log('player-data-2.html not available, trying alternative methods...');
                
                // Ensure fetch is not overridden before we start
                if (window.originalFetch) {
                    window.fetch = window.originalFetch;
                    window.originalFetch = null;
                }
                
                try {
                    // Add timestamp to bypass cache
                    const timestamp = Date.now();
                    const cacheBuster = `?t=${timestamp}`;
                    
                    console.log('Attempting to load fresh player data from FPL API...');
                    
                    // Fetch directly from FPL API with cache busting
                    const response = await fetch(`https://fantasy.premierleague.com/api/bootstrap-static/${cacheBuster}`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        },
                        cache: 'no-store' // Force browser to not use cache
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data && data.elements && data.elements.length > 0) {
                        console.log('Successfully loaded LIVE FPL data (not cached)');
                        
                        // Store raw data
                        this.allPlayers = data.elements;
                        this.teams = data.teams;
                        
                        // Also store teams as lookup object for convenience
                        this.teamsLookup = {};
                        if (data.teams) {
                            data.teams.forEach(team => {
                                this.teamsLookup[team.id] = {
                                    name: team.name,
                                    short_name: team.short_name
                                };
                            });
                        }
                        
                        // Log player count for verification
                        console.log(`Loaded ${this.allPlayers.length} players from LIVE FPL API`);
                        
                        // Update status with current time
                        const now = new Date();
                        const timeString = now.toLocaleTimeString();
                        document.getElementById('lastUpdate').textContent = `Live data at ${timeString} (${this.allPlayers.length} players)`;
                        
                        // Show notification
                        this.showNotification(`🔴 LIVE: Loaded ${this.allPlayers.length} players from FPL!`, 'success');
                    } else {
                        throw new Error('Invalid data structure received');
                    }
                    
                } catch (error) {
                    console.error('Failed to load live data:', error);
                    
                    // Try CORS proxy as fallback
                    try {
                        console.log('Attempting to load via CORS proxy...');
                        const timestamp = Date.now();
                        const apiUrl = `https://fantasy.premierleague.com/api/bootstrap-static/`;
                        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl + '?t=' + timestamp)}`;
                        
                        const proxyResponse = await fetch(proxyUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json'
                            },
                            cache: 'no-store'
                        });
                        
                        if (proxyResponse.ok) {
                            const proxyData = await proxyResponse.json();
                            if (proxyData && proxyData.elements && proxyData.elements.length > 0) {
                                this.allPlayers = proxyData.elements;
                                this.teams = proxyData.teams;
                                
                                // Create teams lookup
                                this.teamsLookup = {};
                                if (proxyData.teams) {
                                    proxyData.teams.forEach(team => {
                                        this.teamsLookup[team.id] = {
                                            name: team.name,
                                            short_name: team.short_name
                                        };
                                    });
                                }
                                
                                console.log(`Loaded ${this.allPlayers.length} players via CORS proxy`);
                                this.showNotification(`✅ Loaded ${this.allPlayers.length} players via proxy!`, 'success');
                                return;
                            }
                        }
                    } catch (proxyError) {
                        console.error('CORS proxy failed:', proxyError);
                    }
                    
                    // Try alternative approach using FPLDataService without cache
                    try {
                        console.log('Attempting to load via FPLDataService...');
                        const fplService = new FPLDataService();
                        
                        // Store original fetch if not already stored
                        if (!window.originalFetch) {
                            window.originalFetch = window.fetch;
                        }
                        
                        // Override the fetch to bypass cache (but not for blob URLs)
                        window.fetch = function(url, options = {}) {
                            // Don't modify blob URLs, data URLs, or local files
                            if (typeof url === 'string' && (
                                url.startsWith('blob:') || 
                                url.startsWith('data:') ||
                                url.startsWith('file:') ||
                                url.includes('localhost') ||
                                !url.includes('fantasy.premierleague.com')
                            )) {
                                return window.originalFetch(url, options);
                            }
                            
                            const timestamp = Date.now();
                            const urlString = typeof url === 'string' ? url : url.toString();
                            const urlWithTimestamp = urlString.includes('?') ? `${urlString}&t=${timestamp}` : `${urlString}?t=${timestamp}`;
                            
                            return window.originalFetch(urlWithTimestamp, {
                                ...options,
                                headers: {
                                    ...options.headers,
                                    'Cache-Control': 'no-cache',
                                    'Pragma': 'no-cache'
                                },
                                cache: 'no-store'
                            });
                        };
                        
                        const data = await fplService.getBootstrapData();
                        
                        // Restore original fetch immediately
                        window.fetch = window.originalFetch;
                        
                        if (data && data.elements) {
                            this.allPlayers = data.elements;
                            this.teams = data.teams;
                            
                            this.teamsLookup = {};
                            if (data.teams) {
                                data.teams.forEach(team => {
                                    this.teamsLookup[team.id] = {
                                        name: team.name,
                                        short_name: team.short_name
                                    };
                                });
                            }
                            
                            const now = new Date();
                            const timeString = now.toLocaleTimeString();
                            document.getElementById('lastUpdate').textContent = `Live (retry) at ${timeString} (${this.allPlayers.length} players)`;
                            
                            this.showNotification(`🟡 Loaded ${this.allPlayers.length} players (alternative method)`, 'info');
                        } else {
                            throw new Error('No valid data available');
                        }
                    } catch (fallbackError) {
                        console.error('All methods failed, trying player-data-2.html:', fallbackError);
                        
                        // Try loading from player-data-2.html file
                        try {
                            const timestamp = Date.now();
                            const response = await fetch(`/player-data-2.html?t=${timestamp}`, {
                                headers: {
                                    'Cache-Control': 'no-cache',
                                    'Pragma': 'no-cache'
                                },
                                cache: 'no-store'
                            });
                            
                            if (response.ok) {
                                const text = await response.text();
                                const data = JSON.parse(text);
                                
                                if (data && data.elements && data.teams) {
                                    this.allPlayers = data.elements;
                                    this.teams = data.teams;
                                    
                                    this.teamsLookup = {};
                                    data.teams.forEach(team => {
                                        this.teamsLookup[team.id] = {
                                            name: team.name,
                                            short_name: team.short_name
                                        };
                                    });
                                    
                                    const now = new Date();
                                    const timeString = now.toLocaleTimeString();
                                    document.getElementById('lastUpdate').textContent = `Backup data at ${timeString} (${this.allPlayers.length} players)`;
                                    
                                    this.showNotification(`📂 Loaded ${this.allPlayers.length} players from backup file`, 'info');
                                    console.log('Successfully loaded data from player-data-2.html');
                                    return; // Exit early on success
                                }
                            }
                        } catch (fileError) {
                            console.error('Failed to load from player-data-2.html:', fileError);
                        }
                        
                        // Last resort: Use mock data from FPLDataService
                        const fplService = new FPLDataService();
                        const mockData = fplService.getMockBootstrapData();
                        
                        if (mockData) {
                            this.allPlayers = mockData.elements;
                            this.teams = mockData.teams;
                            
                            this.teamsLookup = {};
                            if (mockData.teams) {
                                mockData.teams.forEach(team => {
                                    this.teamsLookup[team.id] = {
                                        name: team.name,
                                        short_name: team.short_name
                                    };
                                });
                            }
                            
                            console.log(`Using fallback mock data: ${this.allPlayers.length} players`);
                            document.getElementById('lastUpdate').textContent = `Fallback data (${this.allPlayers.length} players) - Check connection`;
                            
                            // Silently use fallback data
                            console.log('Using fallback data - Live API unavailable');
                        } else {
                            // Silently log the issue
                            console.error('Failed to load any player data, app may have limited functionality');
                        }
                    }
                }
            }

            initializeSquadSlots() {
                const positions = {
                    1: { id: 'gkp-slots', count: 2 },
                    2: { id: 'def-slots', count: 5 },
                    3: { id: 'mid-slots', count: 5 },
                    4: { id: 'fwd-slots', count: 3 }
                };

                Object.entries(positions).forEach(([posType, config]) => {
                    const container = document.getElementById(config.id);
                    container.innerHTML = '';
                    
                    for (let i = 0; i < config.count; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'player-slot';
                        slot.dataset.position = posType;
                        slot.dataset.index = i;
                        slot.innerHTML = `
                            <div class="player-info">
                                <div class="player-name">Empty Slot</div>
                                <div class="player-details">Click to add player</div>
                            </div>
                            <div class="player-price">-</div>
                        `;
                        slot.onclick = () => this.selectSlot(posType, i);
                        container.appendChild(slot);
                    }
                });
            }

            setupEventListeners() {
                // Price filter
                document.getElementById('priceFilter').addEventListener('input', (e) => {
                    document.getElementById('priceValue').textContent = `£${(e.target.value / 10).toFixed(1)}m`;
                });

                // Form filter
                document.getElementById('formFilter').addEventListener('input', (e) => {
                    document.getElementById('formValue').textContent = e.target.value;
                });

                // Auto-refresh on tab focus
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.loadPlayerData();
                    }
                });

                window.addEventListener('focus', () => {
                    this.loadPlayerData();
                });
            }

            displayPlayers(page = 1) {
                const container = document.getElementById('playerCards');
                const instructionsContainer = document.getElementById('searchInstructions');
                
                const filteredPlayers = this.filterPlayers();
                
                // Check if there's an active search/filter
                const hasActiveSearch = this.hasActiveSearchOrFilter();
                
                if (!hasActiveSearch || filteredPlayers.length === 0) {
                    // Show instructions, hide results
                    container.style.display = 'none';
                    instructionsContainer.style.display = 'block';
                    if (hasActiveSearch && filteredPlayers.length === 0) {
                        this.showNoResultsMessage();
                    }
                    return;
                }
                
                // Show results, hide instructions
                container.style.display = 'grid';
                instructionsContainer.style.display = 'none';
                
                // Pagination settings
                const playersPerPage = 30;
                const startIndex = (page - 1) * playersPerPage;
                const endIndex = startIndex + playersPerPage;
                const paginatedPlayers = filteredPlayers.slice(startIndex, endIndex);
                const totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
                
                // Clear container and add player count
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; padding: 15px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border-radius: 10px; margin-bottom: 20px; text-align: center;">
                        <h3 style="margin: 0;">📊 Found ${filteredPlayers.length} Players</h3>
                        <p style="margin: 5px 0 0 0; opacity: 0.9;">Showing ${startIndex + 1}-${Math.min(endIndex, filteredPlayers.length)} of ${filteredPlayers.length} players</p>
                    </div>
                `;
                
                // Display players
                paginatedPlayers.forEach(player => {
                    const card = this.createPlayerCard(player);
                    container.appendChild(card);
                });
                
                // Add pagination controls if needed
                if (totalPages > 1) {
                    const paginationDiv = document.createElement('div');
                    paginationDiv.style.cssText = 'grid-column: 1 / -1; display: flex; justify-content: center; gap: 10px; margin-top: 20px; flex-wrap: wrap;';
                    
                    // Previous button
                    if (page > 1) {
                        const prevBtn = document.createElement('button');
                        prevBtn.textContent = '← Previous';
                        prevBtn.style.cssText = 'padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;';
                        prevBtn.onclick = () => this.displayPlayers(page - 1);
                        paginationDiv.appendChild(prevBtn);
                    }
                    
                    // Page numbers
                    const maxVisiblePages = 5;
                    let startPage = Math.max(1, page - Math.floor(maxVisiblePages / 2));
                    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                    
                    if (endPage - startPage < maxVisiblePages - 1) {
                        startPage = Math.max(1, endPage - maxVisiblePages + 1);
                    }
                    
                    for (let i = startPage; i <= endPage; i++) {
                        const pageBtn = document.createElement('button');
                        pageBtn.textContent = i;
                        pageBtn.style.cssText = `padding: 10px 15px; background: ${i === page ? '#37003c' : '#f0f0f0'}; color: ${i === page ? 'white' : '#333'}; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;`;
                        pageBtn.onclick = () => this.displayPlayers(i);
                        paginationDiv.appendChild(pageBtn);
                    }
                    
                    // Next button
                    if (page < totalPages) {
                        const nextBtn = document.createElement('button');
                        nextBtn.textContent = 'Next →';
                        nextBtn.style.cssText = 'padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;';
                        nextBtn.onclick = () => this.displayPlayers(page + 1);
                        paginationDiv.appendChild(nextBtn);
                    }
                    
                    // Load All button
                    const loadAllBtn = document.createElement('button');
                    loadAllBtn.textContent = `Load All ${filteredPlayers.length} Players`;
                    loadAllBtn.style.cssText = 'padding: 10px 20px; background: linear-gradient(135deg, #f093fb, #f5576c); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; margin-left: 10px;';
                    loadAllBtn.onclick = () => this.displayAllPlayers(filteredPlayers);
                    paginationDiv.appendChild(loadAllBtn);
                    
                    container.appendChild(paginationDiv);
                }
                
                // Store current page for reference
                this.currentPage = page;
            }
            
            displayAllPlayers(players) {
                const container = document.getElementById('playerCards');
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; padding: 15px; background: linear-gradient(135deg, #f093fb, #f5576c); color: white; border-radius: 10px; margin-bottom: 20px; text-align: center;">
                        <h3 style="margin: 0;">⚡ Showing All ${players.length} Players</h3>
                        <p style="margin: 5px 0 0 0; opacity: 0.9;">This may take a moment to load...</p>
                    </div>
                `;
                
                // Display all players
                players.forEach(player => {
                    const card = this.createPlayerCard(player);
                    container.appendChild(card);
                });
            }

            hasActiveSearchOrFilter() {
                const position = document.getElementById('positionFilter').value;
                const search = document.getElementById('searchPlayer').value.trim();
                const maxPrice = parseInt(document.getElementById('priceFilter').value);
                const minForm = parseFloat(document.getElementById('formFilter').value);
                
                return !!(position || search || maxPrice < 150 || minForm > 0);
            }

            showNoResultsMessage() {
                const container = document.getElementById('playerCards');
                container.style.display = 'block';
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px;">
                        <div style="font-size: 3rem; margin-bottom: 20px;">😔</div>
                        <h3 style="color: #37003c; margin-bottom: 10px;">No Players Found</h3>
                        <p style="color: #666;">Try adjusting your search criteria or browse by position.</p>
                        <button onclick="clearAllFilters()" style="margin-top: 15px; padding: 10px 20px; background: #6f42c1; color: white; border: none; border-radius: 8px; cursor: pointer;">
                            Clear All Filters
                        </button>
                    </div>
                `;
            }

            showPositionPlayers(position) {
                // Set the position filter
                document.getElementById('positionFilter').value = position;
                
                // Clear other filters to show all players of this position
                document.getElementById('searchPlayer').value = '';
                document.getElementById('priceFilter').value = 150;
                document.getElementById('formFilter').value = 0;
                document.getElementById('priceValue').textContent = '£15.0m';
                document.getElementById('formValue').textContent = '0.0';
                
                // Display players from page 1
                this.displayPlayers(1);
            }

            clearAllFilters() {
                document.getElementById('positionFilter').value = '';
                document.getElementById('searchPlayer').value = '';
                document.getElementById('priceFilter').value = 150;
                document.getElementById('formFilter').value = 0;
                document.getElementById('priceValue').textContent = '£15.0m';
                document.getElementById('formValue').textContent = '0.0';
                
                // Hide results and show instructions
                document.getElementById('playerCards').style.display = 'none';
                document.getElementById('searchInstructions').style.display = 'block';
            }

            filterPlayers() {
                const position = document.getElementById('positionFilter').value;
                const maxPrice = parseInt(document.getElementById('priceFilter').value);
                const minForm = parseFloat(document.getElementById('formFilter').value);
                const search = document.getElementById('searchPlayer').value.toLowerCase();

                return this.allPlayers.filter(player => {
                    const matchesPosition = !position || player.element_type == position;
                    const matchesPrice = player.now_cost <= maxPrice;
                    const matchesForm = parseFloat(player.form) >= minForm;
                    const matchesSearch = !search || 
                        `${player.first_name} ${player.second_name}`.toLowerCase().includes(search);
                    
                    return matchesPosition && matchesPrice && matchesForm && matchesSearch;
                }).sort((a, b) => b.total_points - a.total_points);
            }

            createPlayerCard(player) {
                const team = this.teams.find(t => t.id === player.team);
                const card = document.createElement('div');
                card.className = 'market-player-card';
                
                const positionBadges = ['', 'badge-gkp', 'badge-def', 'badge-mid', 'badge-fwd'];
                const positionNames = ['', 'GKP', 'DEF', 'MID', 'FWD'];
                
                card.innerHTML = `
                    <div class="player-card-header">
                        <div>
                            <div class="player-card-name">${player.first_name} ${player.second_name}</div>
                            <div class="player-card-team">
                                ${team?.name || 'Unknown'} • 
                                <span class="position-badge ${positionBadges[player.element_type]}">
                                    ${positionNames[player.element_type]}
                                </span>
                            </div>
                        </div>
                        <div class="player-card-price">£${(player.now_cost / 10).toFixed(1)}m</div>
                    </div>
                    
                    <div class="player-stats-grid">
                        <div class="stat-box">
                            <div class="stat-value">${player.total_points}</div>
                            <div class="stat-label">Points</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value">${player.form}</div>
                            <div class="stat-label">Form</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value">${player.selected_by_percent}%</div>
                            <div class="stat-label">TSB</div>
                        </div>
                    </div>
                    
                    <div class="form-indicator">
                        ${this.generateFormDots(parseFloat(player.form))}
                    </div>
                    
                    <div class="action-buttons">
                        <button class="btn btn-success" onclick="transferSimPro.addPlayer(${player.id})">
                            Add to Squad
                        </button>
                        <button class="btn btn-primary" onclick="transferSimPro.comparePlayer(${player.id})">
                            Compare
                        </button>
                        <button class="btn-advanced btn-glow" onclick="showPlayerAdvancedAnalysis(${player.id})">
                            🔬 Advanced Analysis
                        </button>
                    </div>
                `;
                
                return card;
            }

            generateFormDots(form) {
                let dots = '';
                for (let i = 0; i < 5; i++) {
                    const threshold = (i + 1) * 2;
                    let className = 'form-dot form-bad';
                    if (form >= threshold - 0.5) className = 'form-dot form-good';
                    else if (form >= threshold - 1.5) className = 'form-dot form-average';
                    dots += `<div class="${className}"></div>`;
                }
                return dots;
            }

            selectSlot(position, index) {
                // Highlight selected slot
                document.querySelectorAll('.player-slot').forEach(slot => {
                    slot.classList.remove('selected');
                });
                
                const slot = document.querySelector(`[data-position="${position}"][data-index="${index}"]`);
                slot.classList.add('selected');
                
                // Filter players for this position
                document.getElementById('positionFilter').value = position;
                this.displayPlayers();
            }

            addPlayer(playerId) {
                const player = this.allPlayers.find(p => p.id === playerId);
                if (!player) return;

                const position = player.element_type;
                const maxPlayers = { 1: 2, 2: 5, 3: 5, 4: 3 };
                
                // Check if position is full
                if (this.currentSquad[position].length >= maxPlayers[position]) {
                    this.showNotification('Position is full! Remove a player first.', 'error');
                    return;
                }

                // Check budget
                if (player.now_cost > this.budget) {
                    this.showNotification('Insufficient budget!', 'error');
                    return;
                }

                // Add player
                this.currentSquad[position].push(player);
                this.budget -= player.now_cost;
                
                // Add to transfer history
                this.addToHistory('in', player);
                
                // Update display
                this.updateSquadDisplay();
                this.updateDisplay();
                this.updateCharts();
                
                this.showNotification(`Added ${player.first_name} ${player.second_name}`, 'success');
            }

            addPlayerFromImage(player) {
                // Similar to addPlayer but doesn't show individual notifications
                if (!player) return false;

                const position = player.element_type;
                const maxPlayers = { 1: 2, 2: 5, 3: 5, 4: 3 };
                
                // Check if position is full
                if (this.currentSquad[position].length >= maxPlayers[position]) {
                    console.log(`Position ${position} is full, skipping ${player.second_name}`);
                    return false;
                }

                // Check budget
                if (player.now_cost > this.budget) {
                    console.log(`Insufficient budget for ${player.second_name}`);
                    return false;
                }

                // Check if player already in squad
                const alreadyInSquad = this.currentSquad[position].some(p => p.id === player.id);
                if (alreadyInSquad) {
                    console.log(`${player.second_name} already in squad`);
                    return false;
                }

                // Add player
                this.currentSquad[position].push(player);
                this.budget -= player.now_cost;
                
                // Add to transfer history
                this.addToHistory('in', player);
                
                // Update squad display immediately for visual feedback
                this.updateSquadDisplay();
                this.updateDisplay();
                
                console.log(`Added ${player.first_name} ${player.second_name} to squad`);
                return true;
            }

            removePlayer(playerId) {
                for (let position in this.currentSquad) {
                    const index = this.currentSquad[position].findIndex(p => p.id === playerId);
                    if (index >= 0) {
                        const player = this.currentSquad[position][index];
                        this.currentSquad[position].splice(index, 1);
                        this.budget += player.now_cost;
                        
                        this.addToHistory('out', player);
                        this.updateSquadDisplay();
                        this.updateDisplay();
                        this.updateCharts();
                        
                        this.showNotification(`Removed ${player.first_name} ${player.second_name}`, 'info');
                        break;
                    }
                }
            }

            updateSquadDisplay() {
                const positions = {
                    1: 'gkp-slots',
                    2: 'def-slots',
                    3: 'mid-slots',
                    4: 'fwd-slots'
                };

                Object.entries(positions).forEach(([posType, containerId]) => {
                    const container = document.getElementById(containerId);
                    const slots = container.querySelectorAll('.player-slot');
                    const players = this.currentSquad[posType];
                    
                    slots.forEach((slot, index) => {
                        if (players[index]) {
                            const player = players[index];
                            const team = this.teams.find(t => t.id === player.team);
                            slot.innerHTML = `
                                <div class="player-info">
                                    <div class="player-name">${player.second_name}</div>
                                    <div class="player-details">${team?.short_name} • ${player.total_points} pts</div>
                                </div>
                                <div class="player-price">£${(player.now_cost / 10).toFixed(1)}m</div>
                            `;
                            slot.onclick = () => this.removePlayer(player.id);
                            slot.style.background = 'linear-gradient(135deg, #d4edda, #ffffff)';
                        } else {
                            slot.innerHTML = `
                                <div class="player-info">
                                    <div class="player-name">Empty Slot</div>
                                    <div class="player-details">Click to add player</div>
                                </div>
                                <div class="player-price">-</div>
                            `;
                            slot.onclick = () => this.selectSlot(posType, index);
                            slot.style.background = '';
                        }
                    });
                });
            }

            updateDisplay() {
                // Update budget
                document.getElementById('remainingBudget').textContent = `£${(this.budget / 10).toFixed(1)}m`;
                document.getElementById('budgetFill').style.width = `${(this.budget / 1000) * 100}%`;
            }

            addToHistory(type, player) {
                const team = this.teams.find(t => t.id === player.team);
                const history = document.getElementById('transferHistory');
                
                if (history.querySelector('.history-item').textContent.includes('No transfers yet')) {
                    history.innerHTML = '';
                }
                
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <div class="history-icon history-${type}">${type === 'in' ? '➕' : '➖'}</div>
                    <div>
                        <div style="font-weight: 700;">${player.first_name} ${player.second_name}</div>
                        <div style="color: #666; font-size: 0.9rem;">
                            ${team?.name} • £${(player.now_cost / 10).toFixed(1)}m
                        </div>
                    </div>
                `;
                
                history.insertBefore(item, history.firstChild);
                
                // Keep only last 10 transfers
                while (history.children.length > 10) {
                    history.removeChild(history.lastChild);
                }
            }

            initializeCharts() {
                // Value Distribution Chart
                const valueCtx = document.getElementById('valueChart').getContext('2d');
                this.charts.value = new Chart(valueCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Goalkeepers', 'Defenders', 'Midfielders', 'Forwards'],
                        datasets: [{
                            data: [0, 0, 0, 0],
                            backgroundColor: ['#ffd700', '#00ff87', '#00d4ff', '#ff1744']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });

                // Points Chart
                const pointsCtx = document.getElementById('pointsChart').getContext('2d');
                this.charts.points = new Chart(pointsCtx, {
                    type: 'bar',
                    data: {
                        labels: ['GKP', 'DEF', 'MID', 'FWD'],
                        datasets: [{
                            label: 'Expected Points',
                            data: [0, 0, 0, 0],
                            backgroundColor: ['#ffd700', '#00ff87', '#00d4ff', '#ff1744']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            updateCharts() {
                // Calculate values and points by position
                const values = [0, 0, 0, 0];
                const points = [0, 0, 0, 0];
                
                for (let pos = 1; pos <= 4; pos++) {
                    this.currentSquad[pos].forEach(player => {
                        values[pos - 1] += player.now_cost / 10;
                        points[pos - 1] += player.total_points;
                    });
                }
                
                // Update charts
                this.charts.value.data.datasets[0].data = values;
                this.charts.value.update();
                
                this.charts.points.data.datasets[0].data = points;
                this.charts.points.update();
            }

            async runScenario(type) {
                const resultDiv = document.getElementById(`${type}-result`);
                resultDiv.innerHTML = '<div style="color: #00ff88;">Calculating...</div>';
                resultDiv.classList.add('active');
                
                // Simulate scenario calculation
                setTimeout(() => {
                    const results = this.calculateScenario(type);
                    resultDiv.innerHTML = `
                        <div class="result-stat">
                            <span class="result-label">Expected Points:</span>
                            <span class="result-value">${results.points} pts</span>
                        </div>
                        <div class="result-stat">
                            <span class="result-label">Team Value:</span>
                            <span class="result-value">£${results.value}m</span>
                        </div>
                        <div class="result-stat">
                            <span class="result-label">Success Rate:</span>
                            <span class="result-value">${results.success}%</span>
                        </div>
                    `;
                }, 1000);
            }

            calculateScenario(type) {
                const scenarios = {
                    wildcard: { points: 2456, value: 99.5, success: 87 },
                    differential: { points: 2234, value: 96.8, success: 72 },
                    budget: { points: 2089, value: 88.5, success: 91 },
                    premium: { points: 2678, value: 99.9, success: 68 },
                    rotation: { points: 2345, value: 97.2, success: 83 }
                };
                
                return scenarios[type] || { points: 0, value: 0, success: 0 };
            }

            async loadAIRecommendations() {
                const container = document.getElementById('aiRecommendations');
                
                // Simulate AI recommendations
                setTimeout(() => {
                    const recommendations = [
                        {
                            icon: '🔥',
                            title: 'Hot Transfer: Mohamed Salah',
                            details: 'Form: 9.2 • Ownership rising • Great fixtures'
                        },
                        {
                            icon: '💎',
                            title: 'Hidden Gem: Morgan Rogers',
                            details: 'Form: 7.8 • Low ownership 3.2% • Value pick'
                        },
                        {
                            icon: '⚠️',
                            title: 'Sell Alert: Injured Player',
                            details: 'Expected to miss 3 gameweeks • Price dropping'
                        },
                        {
                            icon: '📈',
                            title: 'Captain Pick: Erling Haaland',
                            details: 'Home vs Southampton • 89% captain confidence'
                        }
                    ];
                    
                    container.innerHTML = recommendations.map(rec => `
                        <div class="recommendation-card">
                            <div class="recommendation-icon">${rec.icon}</div>
                            <div class="recommendation-content">
                                <div class="recommendation-title">${rec.title}</div>
                                <div class="recommendation-details">${rec.details}</div>
                            </div>
                        </div>
                    `).join('');
                }, 1500);
            }

            optimizeTeam() {
                this.showNotification('🤖 AI is building your optimal squad...', 'info');
                
                // Reset current team first
                this.currentSquad = { 1: [], 2: [], 3: [], 4: [] };
                this.budget = 1000; // £100m
                
                // Calculate expected points for each player based on form, fixtures, and stats
                const playersWithExpectedPoints = this.allPlayers.map(player => {
                    const expectedPoints = this.calculateExpectedPointsForGameweek(player);
                    return { ...player, expectedPoints };
                }).sort((a, b) => b.expectedPoints - a.expectedPoints);
                
                // Build optimal team with formation 4-4-2 or 3-5-2 or 4-3-3
                const formations = [
                    { gkp: 2, def: 5, mid: 5, fwd: 3 }, // Standard balanced
                    { gkp: 2, def: 4, mid: 5, fwd: 4 }, // Attack heavy
                    { gkp: 2, def: 5, mid: 4, fwd: 4 }  // Balanced attack
                ];
                
                let bestTeam = null;
                let bestExpectedPoints = 0;
                
                // Try each formation to find the best
                for (const formation of formations) {
                    const team = this.buildOptimalTeamForFormation(playersWithExpectedPoints, formation);
                    const totalExpectedPoints = this.calculateTeamExpectedPoints(team);
                    
                    if (totalExpectedPoints > bestExpectedPoints) {
                        bestExpectedPoints = totalExpectedPoints;
                        bestTeam = team;
                    }
                }
                
                // Apply the best team
                if (bestTeam) {
                    this.currentSquad = bestTeam;
                    this.updateSquadDisplay();
                    this.updateDisplay();
                    this.updateCharts();
                    
                    // Show success message with details
                    const playerCount = Object.values(bestTeam).flat().length;
                    const squadValue = (1000 - this.budget) / 10;
                    this.showNotification(
                        `✅ Squad optimized! ${playerCount} players selected | Expected ${Math.round(bestExpectedPoints)} pts | Squad value: £${squadValue.toFixed(1)}m`,
                        'success'
                    );
                } else {
                    this.showNotification('❌ Unable to optimize team. Please try again.', 'error');
                }
            }
            
            calculateExpectedPointsForGameweek(player) {
                // Advanced expected points calculation for current gameweek
                const form = parseFloat(player.form) || 0;
                const totalPoints = player.total_points || 0;
                const gamesPlayed = player.starts || 1;
                const avgPoints = totalPoints / Math.max(gamesPlayed, 1);
                
                // Expected goals and assists contribute to attacking returns
                const xG = parseFloat(player.expected_goals) || 0;
                const xA = parseFloat(player.expected_assists) || 0;
                const xGI = (xG + xA) / Math.max(gamesPlayed, 1);
                
                // Position-based scoring potential
                const positionMultiplier = {
                    1: 0.8,  // GKP - consistent but lower ceiling
                    2: 1.0,  // DEF - clean sheets + occasional goals
                    3: 1.2,  // MID - goals, assists, clean sheets
                    4: 1.3   // FWD - highest goal threat
                }[player.element_type] || 1;
                
                // Calculate base expected points
                let expectedPoints = (
                    form * 0.45 +           // Recent form (45%)
                    avgPoints * 0.25 +      // Season average (25%)
                    xGI * 10 * 0.20 +       // Expected goal involvement (20%)
                    (player.bonus || 0) * 0.10  // Bonus point history (10%)
                ) * positionMultiplier;
                
                // Fixture difficulty adjustment (simplified - would need real fixture data)
                const fixtureBonus = Math.random() * 0.2 + 0.9; // 0.9 to 1.1 multiplier
                expectedPoints *= fixtureBonus;
                
                // Differential bonus for low ownership high performers
                if (player.selected_by_percent < 10 && expectedPoints > 5) {
                    expectedPoints *= 1.15;
                }
                
                // Penalty taker bonus
                if (player.penalties_order && player.penalties_order <= 1) {
                    expectedPoints *= 1.1;
                }
                
                return Math.max(expectedPoints, 2); // Minimum 2 points
            }
            
            buildOptimalTeamForFormation(sortedPlayers, formation) {
                const team = { 1: [], 2: [], 3: [], 4: [] };
                let remainingBudget = 1000;
                const usedPlayerIds = new Set();
                const maxPerTeam = 3; // FPL rule: max 3 players from same team
                const teamCounts = {};
                
                // Requirements for each position
                const requirements = {
                    1: formation.gkp,
                    2: formation.def,
                    3: formation.mid,
                    4: formation.fwd
                };
                
                // Fill each position with best available players
                for (let position = 1; position <= 4; position++) {
                    const needed = requirements[position];
                    const positionPlayers = sortedPlayers.filter(p => 
                        p.element_type === position && 
                        !usedPlayerIds.has(p.id)
                    );
                    
                    // Determine premium vs budget split
                    const premiumCount = position === 1 ? 1 : Math.min(Math.ceil(needed * 0.4), 2);
                    const budgetCount = needed - premiumCount;
                    
                    // Add premium players first (highest expected points)
                    let added = 0;
                    for (const player of positionPlayers) {
                        if (added >= premiumCount) break;
                        
                        const teamCount = teamCounts[player.team] || 0;
                        if (teamCount >= maxPerTeam) continue;
                        
                        if (player.now_cost <= remainingBudget) {
                            team[position].push(player);
                            remainingBudget -= player.now_cost;
                            usedPlayerIds.add(player.id);
                            teamCounts[player.team] = teamCount + 1;
                            added++;
                        }
                    }
                    
                    // Add value players (best points per million)
                    const valuePlayers = positionPlayers
                        .filter(p => !usedPlayerIds.has(p.id))
                        .map(p => ({
                            ...p,
                            value: p.expectedPoints / (p.now_cost / 10)
                        }))
                        .sort((a, b) => b.value - a.value);
                    
                    for (const player of valuePlayers) {
                        if (team[position].length >= needed) break;
                        
                        const teamCount = teamCounts[player.team] || 0;
                        if (teamCount >= maxPerTeam) continue;
                        
                        if (player.now_cost <= remainingBudget) {
                            team[position].push(player);
                            remainingBudget -= player.now_cost;
                            usedPlayerIds.add(player.id);
                            teamCounts[player.team] = teamCount + 1;
                        }
                    }
                    
                    // Fill remaining slots with cheapest valid players
                    if (team[position].length < needed) {
                        const cheapest = positionPlayers
                            .filter(p => {
                                const teamCount = teamCounts[p.team] || 0;
                                return !usedPlayerIds.has(p.id) && teamCount < maxPerTeam;
                            })
                            .sort((a, b) => a.now_cost - b.now_cost);
                        
                        for (const player of cheapest) {
                            if (team[position].length >= needed) break;
                            
                            const teamCount = teamCounts[player.team] || 0;
                            team[position].push(player);
                            remainingBudget -= player.now_cost;
                            usedPlayerIds.add(player.id);
                            teamCounts[player.team] = teamCount + 1;
                        }
                    }
                }
                
                return team;
            }
            
            calculateTeamExpectedPoints(team) {
                let total = 0;
                Object.values(team).forEach(position => {
                    position.forEach(player => {
                        total += this.calculateExpectedPointsForGameweek(player);
                    });
                });
                return total;
            }
            
            resetTeam() {
                // Clear all team data
                this.currentSquad = { 1: [], 2: [], 3: [], 4: [] };
                this.budget = 1000;
                
                // Clear transfer history
                const history = document.getElementById('transferHistory');
                if (history) {
                    history.innerHTML = '<div class="history-item" style="color: #666;">No transfers yet</div>';
                }
                
                // Re-render the squad display
                this.updateSquadDisplay();
                this.updateDisplay();
                this.updateCharts();
                
                // Show notification
                this.showNotification('🔄 Team has been reset!', 'info');
            }
            
            saveTeam(teamName) {
                if (!teamName) {
                    teamName = prompt('Enter a name for this team:');
                    if (!teamName) return;
                }
                
                // Get existing saved teams or initialize empty array
                let savedTeams = JSON.parse(localStorage.getItem('fplSavedTeams') || '[]');
                
                // Create team object with all necessary data
                const teamData = {
                    name: teamName,
                    date: new Date().toISOString(),
                    squad: JSON.parse(JSON.stringify(this.currentSquad)), // Deep copy
                    budget: this.budget,
                    totalValue: (1000 - this.budget) / 10,
                    playerCount: Object.values(this.currentSquad).flat().length,
                    expectedPoints: this.calculateTeamExpectedPoints(this.currentSquad),
                    formation: this.getFormation(),
                    transferHistory: [...this.transferHistory]
                };
                
                // Check if team with same name exists
                const existingIndex = savedTeams.findIndex(t => t.name === teamName);
                if (existingIndex >= 0) {
                    if (confirm(`Team "${teamName}" already exists. Overwrite?`)) {
                        savedTeams[existingIndex] = teamData;
                    } else {
                        return;
                    }
                } else {
                    savedTeams.push(teamData);
                }
                
                // Limit to 10 saved teams
                if (savedTeams.length > 10) {
                    savedTeams = savedTeams.slice(-10);
                }
                
                // Save to localStorage
                localStorage.setItem('fplSavedTeams', JSON.stringify(savedTeams));
                
                this.showNotification(`✅ Team "${teamName}" saved successfully!`, 'success');
            }
            
            loadTeam(teamData) {
                if (!teamData) return;
                
                // Load the squad
                this.currentSquad = JSON.parse(JSON.stringify(teamData.squad));
                this.budget = teamData.budget || 1000;
                this.transferHistory = teamData.transferHistory || [];
                
                // Update displays
                this.updateSquadDisplay();
                this.updateDisplay();
                this.updateCharts();
                
                // Update transfer history display
                const history = document.getElementById('transferHistory');
                if (history && this.transferHistory.length > 0) {
                    history.innerHTML = this.transferHistory.map(transfer => `
                        <div class="history-item">
                            <div class="history-icon ${transfer.type === 'in' ? 'history-in' : 'history-out'}">
                                ${transfer.type === 'in' ? '➕' : '➖'}
                            </div>
                            <div>
                                <div style="font-weight: 700;">${transfer.playerName}</div>
                                <div style="color: #666; font-size: 0.9rem;">
                                    £${(transfer.price / 10).toFixed(1)}m • ${transfer.timestamp}
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else if (history) {
                    history.innerHTML = '<div class="history-item" style="color: #666;">No transfers yet</div>';
                }
                
                this.showNotification(`✅ Team "${teamData.name}" loaded successfully!`, 'success');
            }
            
            getSavedTeams() {
                return JSON.parse(localStorage.getItem('fplSavedTeams') || '[]');
            }
            
            deleteSavedTeam(teamName) {
                let savedTeams = this.getSavedTeams();
                savedTeams = savedTeams.filter(t => t.name !== teamName);
                localStorage.setItem('fplSavedTeams', JSON.stringify(savedTeams));
                this.showNotification(`🗑️ Team "${teamName}" deleted`, 'info');
            }
            
            getFormation() {
                const def = this.currentSquad[2].length;
                const mid = this.currentSquad[3].length;
                const fwd = this.currentSquad[4].length;
                return `${def}-${mid}-${fwd}`;
            }

            comparePlayer(playerId) {
                const player = this.allPlayers.find(p => p.id === playerId);
                if (player) {
                    this.showNotification(`Comparing ${player.first_name} ${player.second_name}...`, 'info');
                }
            }

            initializeFixtureAnalysis() {
                // Initialize fixture data
                this.loadFixtureData();
            }

            loadFixtureData() {
                // Mock fixture data - in real implementation, this would come from FPL API
                const fixtures = [
                    { team: 'Arsenal', fixtures: [
                        { opponent: 'SOU', difficulty: 2, venue: 'H' },
                        { opponent: 'WHU', difficulty: 3, venue: 'A' },
                        { opponent: 'NEW', difficulty: 2, venue: 'H' },
                        { opponent: 'LIV', difficulty: 5, venue: 'A' },
                        { opponent: 'CHE', difficulty: 4, venue: 'H' }
                    ]},
                    { team: 'Man City', fixtures: [
                        { opponent: 'BHA', difficulty: 3, venue: 'H' },
                        { opponent: 'TOT', difficulty: 4, venue: 'A' },
                        { opponent: 'LEI', difficulty: 2, venue: 'H' },
                        { opponent: 'ARS', difficulty: 5, venue: 'H' },
                        { opponent: 'LIV', difficulty: 5, venue: 'A' }
                    ]},
                    { team: 'Liverpool', fixtures: [
                        { opponent: 'EVE', difficulty: 2, venue: 'A' },
                        { opponent: 'BRE', difficulty: 2, venue: 'H' },
                        { opponent: 'CHE', difficulty: 4, venue: 'A' },
                        { opponent: 'ARS', difficulty: 5, venue: 'H' },
                        { opponent: 'MCI', difficulty: 5, venue: 'H' }
                    ]},
                    { team: 'Chelsea', fixtures: [
                        { opponent: 'WOL', difficulty: 2, venue: 'H' },
                        { opponent: 'FUL', difficulty: 3, venue: 'A' },
                        { opponent: 'LIV', difficulty: 4, venue: 'H' },
                        { opponent: 'ARS', difficulty: 4, venue: 'A' },
                        { opponent: 'TOT', difficulty: 4, venue: 'H' }
                    ]},
                    { team: 'Newcastle', fixtures: [
                        { opponent: 'IPS', difficulty: 2, venue: 'H' },
                        { opponent: 'SOU', difficulty: 2, venue: 'A' },
                        { opponent: 'ARS', difficulty: 2, venue: 'A' },
                        { opponent: 'BRE', difficulty: 3, venue: 'H' },
                        { opponent: 'WHU', difficulty: 3, venue: 'A' }
                    ]},
                    { team: 'Brighton', fixtures: [
                        { opponent: 'MCI', difficulty: 3, venue: 'A' },
                        { opponent: 'LIV', difficulty: 4, venue: 'A' },
                        { opponent: 'IPS', difficulty: 2, venue: 'H' },
                        { opponent: 'EVE', difficulty: 2, venue: 'A' },
                        { opponent: 'WOL', difficulty: 2, venue: 'H' }
                    ]}
                ];

                this.fixtureData = fixtures;
                this.displayFixtures('all');
            }

            displayFixtures(filter) {
                const container = document.getElementById('fixtureGrid');
                if (!container) return;

                // Update button states
                document.querySelectorAll('.fixture-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[onclick="showFixtures('${filter}')"]`).classList.add('active');

                let filteredData = [...this.fixtureData];

                if (filter === 'easy') {
                    filteredData = filteredData.filter(team => {
                        const avgDifficulty = team.fixtures.reduce((sum, fix) => sum + fix.difficulty, 0) / team.fixtures.length;
                        return avgDifficulty <= 2.5;
                    });
                } else if (filter === 'hard') {
                    filteredData = filteredData.filter(team => {
                        const avgDifficulty = team.fixtures.reduce((sum, fix) => sum + fix.difficulty, 0) / team.fixtures.length;
                        return avgDifficulty >= 3.5;
                    });
                }

                container.innerHTML = filteredData.map(team => {
                    const avgDifficulty = (team.fixtures.reduce((sum, fix) => sum + fix.difficulty, 0) / team.fixtures.length).toFixed(1);
                    
                    return `
                        <div class="team-fixture-card">
                            <div class="team-name">
                                ${team.team}
                                <span class="fixture-score">${avgDifficulty}/5</span>
                            </div>
                            <div class="fixture-list">
                                ${team.fixtures.map(fixture => 
                                    `<div class="fixture-opponent difficulty-${fixture.difficulty}">
                                        ${fixture.opponent}${fixture.venue === 'H' ? '' : ' (A)'}
                                    </div>`
                                ).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            initializePlayerComparison() {
                // Initialize comparison functionality
                this.selectedComparisonPosition = null;
                this.comparisonPlayers = [];
            }

            updateComparisonPlayers() {
                const position = document.getElementById('comparePosition').value;
                if (!position) return;

                const positionPlayers = this.allPlayers
                    .filter(p => p.element_type == position)
                    .sort((a, b) => b.total_points - a.total_points)
                    .slice(0, 20); // Top 20 players

                // Update player dropdowns
                ['comparePlayer1', 'comparePlayer2', 'comparePlayer3'].forEach(selectId => {
                    const select = document.getElementById(selectId);
                    select.innerHTML = `<option value="">${selectId.replace('comparePlayer', 'Player ')}</option>`;
                    
                    positionPlayers.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.id;
                        option.textContent = `${player.first_name} ${player.second_name}`;
                        select.appendChild(option);
                    });
                });

                this.updateComparison();
            }

            updateComparison() {
                const player1Id = document.getElementById('comparePlayer1').value;
                const player2Id = document.getElementById('comparePlayer2').value;
                const player3Id = document.getElementById('comparePlayer3').value;

                const players = [player1Id, player2Id, player3Id]
                    .filter(id => id)
                    .map(id => this.allPlayers.find(p => p.id == id))
                    .filter(p => p);

                if (players.length < 2) {
                    document.getElementById('comparisonTable').innerHTML = 
                        '<div class="comparison-placeholder">Select at least 2 players to compare</div>';
                    return;
                }

                this.displayComparison(players);
            }

            displayComparison(players) {
                const stats = [
                    { key: 'total_points', label: 'Total Points' },
                    { key: 'form', label: 'Form' },
                    { key: 'now_cost', label: 'Price (£m)', transform: val => (val / 10).toFixed(1) },
                    { key: 'selected_by_percent', label: 'TSB (%)', transform: val => `${val}%` },
                    { key: 'points_per_game', label: 'Points/Game' },
                    { key: 'goals_scored', label: 'Goals' },
                    { key: 'assists', label: 'Assists' },
                    { key: 'clean_sheets', label: 'Clean Sheets' },
                    { key: 'bonus', label: 'Bonus Points' },
                    { key: 'bps', label: 'BPS' }
                ];

                const table = document.createElement('table');
                table.className = 'comparison-matrix';

                // Header row
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `
                    <th class="stat-name">Statistic</th>
                    ${players.map(p => `<th>${p.first_name} ${p.second_name}</th>`).join('')}
                `;
                table.appendChild(headerRow);

                // Data rows
                stats.forEach(stat => {
                    const row = document.createElement('tr');
                    const values = players.map(p => {
                        const value = p[stat.key] || 0;
                        return stat.transform ? stat.transform(value) : value;
                    });

                    // Find best value for highlighting
                    const numericValues = values.map(v => parseFloat(v.toString().replace(/[^\d.-]/g, '')));
                    const bestValue = Math.max(...numericValues);

                    row.innerHTML = `
                        <td class="stat-name">${stat.label}</td>
                        ${values.map((value, index) => {
                            const isiBest = numericValues[index] === bestValue && bestValue > 0;
                            return `<td class="${isiBest ? 'stat-best' : ''}">${value}</td>`;
                        }).join('')}
                    `;
                    table.appendChild(row);
                });

                document.getElementById('comparisonTable').innerHTML = '';
                document.getElementById('comparisonTable').appendChild(table);
            }

            initializePriceChanges() {
                this.loadPriceChangeData();
                this.initializeAdvancedFeatures();
            }

            // 🚀 ADVANCED FEATURES START HERE
            
            initializeAdvancedFeatures() {
                this.initializeFixtureDifficultyAnalyzer();
                this.initializePerformancePredictor();
                this.initializeChemistryCalculator();
                this.initializeMarketSentiment();
                this.initializeWildcardPlanner();
                this.initializeInjuryRiskAssessment();
                this.initializeHistoricalTrends();
            }

            // 1. Advanced Fixture Difficulty Analyzer
            initializeFixtureDifficultyAnalyzer() {
                this.fixtureAnalyzer = {
                    getDifficultyRating: (teamId, gameweeks = 5) => {
                        // Simulated fixture difficulty based on team strength
                        const teamStrengths = {
                            1: 8.5, 2: 6.2, 3: 7.8, 4: 5.1, 5: 6.8, 6: 9.2, 7: 7.5, 8: 4.9,
                            9: 5.7, 10: 6.3, 11: 8.9, 12: 4.2, 13: 5.9, 14: 7.1, 15: 6.5,
                            16: 4.8, 17: 5.3, 18: 3.9, 19: 4.1, 20: 3.2
                        };
                        
                        const fixtures = this.generateMockFixtures(teamId, gameweeks);
                        const totalDifficulty = fixtures.reduce((sum, fixture) => {
                            const opponentStrength = teamStrengths[fixture.opponent] || 5.0;
                            const homeBenefit = fixture.isHome ? 1.2 : 0.8;
                            return sum + (opponentStrength * homeBenefit);
                        }, 0);
                        
                        return Math.min(10, Math.max(1, totalDifficulty / gameweeks));
                    },
                    
                    getColorCode: (difficulty) => {
                        if (difficulty <= 3) return { color: '#28a745', label: 'Easy' };
                        if (difficulty <= 6) return { color: '#ffc107', label: 'Medium' };
                        return { color: '#dc3545', label: 'Hard' };
                    }
                };
            }

            // 2. Machine Learning Performance Predictor
            initializePerformancePredictor() {
                this.performancePredictor = {
                    predictPoints: (player, gameweeks = 3) => {
                        // Simulated ML prediction algorithm
                        const basePoints = parseFloat(player.points_per_game) || 4.0;
                        const form = parseFloat(player.form) || 5.0;
                        const ownership = parseFloat(player.selected_by_percent) || 10.0;
                        
                        // Factors affecting prediction
                        const formWeight = 0.4;
                        const ownershipWeight = 0.2;
                        const fixtureWeight = 0.3;
                        const randomWeight = 0.1;
                        
                        const fixtureScore = this.fixtureAnalyzer.getDifficultyRating(player.team);
                        const adjustedFixtureScore = 10 - fixtureScore; // Invert for easier fixtures = higher score
                        
                        const prediction = (
                            (basePoints * (1 + (form - 5) * 0.1)) * formWeight +
                            (basePoints * (1 + (ownership - 10) * 0.01)) * ownershipWeight +
                            (basePoints * (adjustedFixtureScore / 10)) * fixtureWeight +
                            (basePoints * (Math.random() * 0.4 - 0.2)) * randomWeight
                        ) * gameweeks;
                        
                        return Math.max(0, Math.round(prediction * 10) / 10);
                    },
                    
                    getConfidenceLevel: (player) => {
                        const consistency = parseFloat(player.consistency_rating) || 50;
                        const minutes = parseFloat(player.minutes) || 500;
                        const confidence = Math.min(95, (consistency + (minutes / 30)) / 2);
                        return Math.round(confidence);
                    }
                };
            }

            // 3. Dynamic Squad Chemistry & Synergy Calculator
            initializeChemistryCalculator() {
                this.chemistryCalculator = {
                    calculateTeamChemistry: () => {
                        let chemistry = 0;
                        const teamCounts = {};
                        const leagueCounts = {};
                        const nationalityCounts = {};
                        
                        Object.values(this.currentSquad).forEach(position => {
                            position.forEach(player => {
                                if (!player) return;
                                
                                // Team chemistry
                                teamCounts[player.team] = (teamCounts[player.team] || 0) + 1;
                                
                                // League chemistry (Premier League = 1)
                                leagueCounts[1] = (leagueCounts[1] || 0) + 1;
                                
                                // Nationality chemistry (simulated)
                                const nationality = this.getPlayerNationality(player);
                                nationalityCounts[nationality] = (nationalityCounts[nationality] || 0) + 1;
                            });
                        });
                        
                        // Calculate chemistry bonuses
                        Object.values(teamCounts).forEach(count => {
                            if (count >= 2) chemistry += count * 5; // Team synergy bonus
                        });
                        
                        Object.values(nationalityCounts).forEach(count => {
                            if (count >= 3) chemistry += count * 3; // National synergy bonus
                        });
                        
                        return Math.min(100, chemistry);
                    },
                    
                    getSynergyBonuses: () => {
                        const bonuses = [];
                        // Liverpool attacking trio bonus
                        const liverpoolPlayers = this.getSquadPlayersByTeam(6);
                        if (liverpoolPlayers.length >= 3) {
                            bonuses.push({ type: 'Team Stack', team: 'Liverpool', bonus: '+15% points' });
                        }
                        
                        // Arsenal defense bonus
                        const arsenalDefenders = this.getSquadPlayersByTeamAndPosition(1, 2);
                        if (arsenalDefenders.length >= 2) {
                            bonuses.push({ type: 'Defense Stack', team: 'Arsenal', bonus: '+10% clean sheets' });
                        }
                        
                        return bonuses;
                    }
                };
            }

            // 4. Real-time Market Sentiment Analysis
            initializeMarketSentiment() {
                this.marketSentiment = {
                    analyzeSentiment: (playerId) => {
                        // Simulated sentiment analysis
                        const sentiments = ['Bullish', 'Bearish', 'Neutral', 'FOMO Alert', 'Value Play'];
                        const trends = ['Rising', 'Falling', 'Stable', 'Volatile'];
                        
                        return {
                            sentiment: sentiments[Math.floor(Math.random() * sentiments.length)],
                            trend: trends[Math.floor(Math.random() * trends.length)],
                            confidence: Math.floor(Math.random() * 40) + 60,
                            volume: Math.floor(Math.random() * 50000) + 10000,
                            mentions: Math.floor(Math.random() * 5000) + 500
                        };
                    },
                    
                    getTrendingPlayers: () => {
                        return [
                            { name: 'Cole Palmer', sentiment: 'Bullish', change: '+23%', reason: 'Hat-trick vs Brighton' },
                            { name: 'Viktor Gyökeres', sentiment: 'FOMO Alert', change: '+45%', reason: 'Arsenal signing hype' },
                            { name: 'Bukayo Saka', sentiment: 'Rising', change: '+12%', reason: 'Fixture run analysis' },
                            { name: 'Alexander Isak', sentiment: 'Volatile', change: '+8%', reason: 'Injury concerns' }
                        ];
                    }
                };
            }

            // 5. Advanced Wildcard Strategy Planner
            initializeWildcardPlanner() {
                this.wildcardPlanner = {
                    calculateOptimalTiming: () => {
                        const gameweeks = this.generateGameweekAnalysis();
                        let bestGW = null;
                        let maxBenefit = 0;
                        
                        gameweeks.forEach(gw => {
                            const benefit = gw.dgwTeams * 3 + gw.easyFixtures * 2 - gw.blankGwTeams * 5;
                            if (benefit > maxBenefit) {
                                maxBenefit = benefit;
                                bestGW = gw;
                            }
                        });
                        
                        return bestGW;
                    },
                    
                    generateWildcardTemplate: (strategy = 'balanced') => {
                        const templates = {
                            aggressive: { gkp: 1, def: 3, mid: 5, fwd: 3, budget: 'High-risk, high-reward picks' },
                            balanced: { gkp: 2, def: 4, mid: 4, fwd: 2, budget: 'Mix of premium and value players' },
                            defensive: { gkp: 2, def: 5, mid: 3, fwd: 2, budget: 'Focus on clean sheet potential' }
                        };
                        
                        return templates[strategy];
                    }
                };
            }

            // 6. Injury Risk Assessment
            initializeInjuryRiskAssessment() {
                this.injuryRiskAssessment = {
                    assessRisk: (player) => {
                        // Simulated injury risk calculation
                        const age = this.getPlayerAge(player);
                        const minutes = parseFloat(player.minutes) || 0;
                        const position = player.element_type;
                        
                        let riskScore = 0;
                        
                        // Age factor
                        if (age > 30) riskScore += 15;
                        else if (age > 27) riskScore += 5;
                        
                        // Minutes played factor
                        if (minutes > 2500) riskScore += 10;
                        else if (minutes > 2000) riskScore += 5;
                        
                        // Position factor (forwards and defenders more prone)
                        if (position === 4 || position === 2) riskScore += 5;
                        
                        // Random factor for current form/fitness
                        riskScore += Math.random() * 20;
                        
                        const risk = Math.min(100, Math.max(0, riskScore));
                        
                        return {
                            percentage: Math.round(risk),
                            level: risk < 20 ? 'Low' : risk < 50 ? 'Medium' : 'High',
                            nextAssessment: '7 days',
                            factors: this.getInjuryFactors(player, age, minutes)
                        };
                    },
                    
                    getReturnDates: (playerId) => {
                        // Simulated injury return dates
                        const injuries = [
                            { type: 'Minor knock', return: '1-2 weeks', probability: '85%' },
                            { type: 'Muscle strain', return: '2-3 weeks', probability: '70%' },
                            { type: 'Ligament damage', return: '6-8 weeks', probability: '10%' }
                        ];
                        
                        return injuries[Math.floor(Math.random() * injuries.length)];
                    }
                };
            }

            // 7. Historical Performance Trend Analysis
            initializeHistoricalTrends() {
                this.historicalTrends = {
                    analyzePlayerTrend: (player) => {
                        // Simulated historical analysis
                        const seasons = ['2023/24', '2022/23', '2021/22'];
                        const metrics = ['goals', 'assists', 'points', 'minutes'];
                        
                        const trends = seasons.map(season => ({
                            season,
                            points: Math.floor(Math.random() * 100) + 50,
                            goals: Math.floor(Math.random() * 15) + 2,
                            assists: Math.floor(Math.random() * 12) + 1,
                            minutes: Math.floor(Math.random() * 1000) + 1500
                        }));
                        
                        const trajectory = this.calculateTrajectory(trends);
                        
                        return {
                            trends,
                            trajectory,
                            peakSeason: '2023/24',
                            consistency: Math.floor(Math.random() * 40) + 60,
                            prediction: this.generateSeasonPrediction(trends)
                        };
                    },
                    
                    calculateTrajectory: (trends) => {
                        const latest = trends[0]?.points || 0;
                        const previous = trends[1]?.points || 0;
                        const change = latest - previous;
                        
                        if (change > 20) return { direction: 'Rising Star', color: '#28a745' };
                        if (change > 0) return { direction: 'Improving', color: '#17a2b8' };
                        if (change > -20) return { direction: 'Stable', color: '#ffc107' };
                        return { direction: 'Declining', color: '#dc3545' };
                    }
                };
            }

            // Helper functions for advanced features
            generateMockFixtures(teamId, gameweeks) {
                const fixtures = [];
                for (let i = 0; i < gameweeks; i++) {
                    fixtures.push({
                        opponent: Math.floor(Math.random() * 20) + 1,
                        isHome: Math.random() > 0.5,
                        gameweek: i + 1
                    });
                }
                return fixtures;
            }

            getPlayerNationality(player) {
                const nationalities = ['England', 'Brazil', 'Argentina', 'France', 'Spain', 'Portugal'];
                return nationalities[Math.floor(Math.random() * nationalities.length)];
            }

            getSquadPlayersByTeam(teamId) {
                const players = [];
                Object.values(this.currentSquad).forEach(position => {
                    position.forEach(player => {
                        if (player && player.team === teamId) players.push(player);
                    });
                });
                return players;
            }

            getSquadPlayersByTeamAndPosition(teamId, positionType) {
                return this.currentSquad[positionType]?.filter(player => player && player.team === teamId) || [];
            }

            getPlayerAge(player) {
                // Simulated age based on player data
                return Math.floor(Math.random() * 15) + 18;
            }

            getInjuryFactors(player, age, minutes) {
                const factors = [];
                if (age > 30) factors.push('Age-related wear');
                if (minutes > 2500) factors.push('Heavy workload');
                if (Math.random() > 0.7) factors.push('Previous injury history');
                return factors;
            }

            generateGameweekAnalysis() {
                return Array.from({ length: 10 }, (_, i) => ({
                    gameweek: i + 15,
                    dgwTeams: Math.floor(Math.random() * 6),
                    easyFixtures: Math.floor(Math.random() * 8) + 2,
                    blankGwTeams: Math.floor(Math.random() * 3)
                }));
            }

            generateSeasonPrediction(trends) {
                const avgPoints = trends.reduce((sum, trend) => sum + trend.points, 0) / trends.length;
                return {
                    expectedPoints: Math.round(avgPoints * (0.9 + Math.random() * 0.2)),
                    confidence: Math.floor(Math.random() * 30) + 70
                };
            }

            // Enhanced UI Functions
            showAdvancedAnalysis(playerId) {
                const player = this.allPlayers.find(p => p.id === playerId);
                if (!player) return;

                const modal = document.createElement('div');
                modal.className = 'advanced-modal';
                
                const fixtureRating = this.fixtureAnalyzer.getDifficultyRating(player.team);
                const fixtureColor = this.fixtureAnalyzer.getColorCode(fixtureRating);
                const predictedPoints = this.performancePredictor.predictPoints(player);
                const confidence = this.performancePredictor.getConfidenceLevel(player);
                const injuryRisk = this.injuryRiskAssessment.assessRisk(player);
                const sentiment = this.marketSentiment.analyzeSentiment(playerId);
                const historicalData = this.historicalTrends.analyzePlayerTrend(player);

                modal.innerHTML = `
                    <div class="modal-content advanced-modal-content">
                        <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                        <h2>🔬 Advanced Analysis: ${player.first_name} ${player.second_name}</h2>
                        
                        <div class="advanced-grid">
                            <div class="analysis-card">
                                <h3>🎯 Performance Prediction</h3>
                                <div class="prediction-value">${predictedPoints} points</div>
                                <div class="confidence-meter">
                                    <div class="confidence-bar" style="width: ${confidence}%"></div>
                                </div>
                                <p>Confidence: ${confidence}%</p>
                            </div>
                            
                            <div class="analysis-card">
                                <h3>📅 Fixture Difficulty</h3>
                                <div class="difficulty-rating" style="color: ${fixtureColor.color}">
                                    ${fixtureRating.toFixed(1)}/10 - ${fixtureColor.label}
                                </div>
                                <p>Next 5 gameweeks analysis</p>
                            </div>
                            
                            <div class="analysis-card">
                                <h3>🏥 Injury Risk</h3>
                                <div class="risk-percentage ${injuryRisk.level.toLowerCase()}">${injuryRisk.percentage}%</div>
                                <p>Risk Level: ${injuryRisk.level}</p>
                                <small>${injuryRisk.factors.join(', ')}</small>
                            </div>
                            
                            <div class="analysis-card">
                                <h3>📊 Market Sentiment</h3>
                                <div class="sentiment-badge ${sentiment.sentiment.toLowerCase()}">${sentiment.sentiment}</div>
                                <p>Trend: ${sentiment.trend}</p>
                                <small>${sentiment.mentions.toLocaleString()} mentions</small>
                            </div>
                            
                            <div class="analysis-card full-width">
                                <h3>📈 Historical Trend</h3>
                                <div class="trend-indicator" style="color: ${historicalData.trajectory.color}">
                                    ${historicalData.trajectory.direction}
                                </div>
                                <p>Consistency Rating: ${historicalData.consistency}%</p>
                                <p>Season Prediction: ${historicalData.prediction.expectedPoints} points</p>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            // Enhanced optimization with new algorithms
            optimizeTeamAdvanced(strategy = 'balanced') {
                this.showNotification('🤖 Running advanced AI optimization...', 'info');
                
                const chemistry = this.chemistryCalculator.calculateTeamChemistry();
                const wildcardTiming = this.wildcardPlanner.calculateOptimalTiming();
                
                // Use new prediction algorithms
                const enhancedPlayers = this.allPlayers.map(player => ({
                    ...player,
                    predictedPoints: this.performancePredictor.predictPoints(player),
                    injuryRisk: this.injuryRiskAssessment.assessRisk(player),
                    fixtureRating: this.fixtureAnalyzer.getDifficultyRating(player.team)
                }));
                
                // Apply advanced optimization logic
                const optimizedTeam = this.buildAdvancedOptimalTeam(enhancedPlayers, strategy);
                
                if (optimizedTeam) {
                    this.currentSquad = optimizedTeam;
                    this.updateSquadDisplay();
                    
                    const newChemistry = this.chemistryCalculator.calculateTeamChemistry();
                    const improvement = newChemistry - chemistry;
                    
                    this.showNotification(
                        `✅ Advanced optimization complete! Chemistry improved by ${improvement}%`, 
                        'success'
                    );
                }
            }

            buildAdvancedOptimalTeam(enhancedPlayers, strategy) {
                // Enhanced team building with new metrics
                const team = { 1: [], 2: [], 3: [], 4: [] };
                let remainingBudget = 1000;
                
                // Sort by advanced scoring algorithm
                const scoredPlayers = enhancedPlayers.map(player => ({
                    ...player,
                    advancedScore: this.calculateAdvancedScore(player, strategy)
                })).sort((a, b) => b.advancedScore - a.advancedScore);
                
                // Fill positions with advanced logic
                const requirements = { 1: 2, 2: 5, 3: 5, 4: 3 };
                
                for (let position = 1; position <= 4; position++) {
                    const needed = requirements[position];
                    const positionPlayers = scoredPlayers.filter(p => p.element_type === position);
                    
                    for (let i = 0; i < needed && team[position].length < needed; i++) {
                        const player = positionPlayers.find(p => 
                            p.now_cost <= remainingBudget && 
                            !this.isPlayerInTeam(team, p.id)
                        );
                        
                        if (player) {
                            team[position].push(player);
                            remainingBudget -= player.now_cost;
                        }
                    }
                }
                
                return this.isValidTeam(team) ? team : null;
            }

            calculateAdvancedScore(player, strategy) {
                const baseScore = parseFloat(player.total_points) || 0;
                const predictedScore = player.predictedPoints || 0;
                const injuryRisk = player.injuryRisk?.percentage || 50;
                const fixtureRating = 10 - player.fixtureRating; // Invert for easier = better
                
                let score = (baseScore * 0.3) + (predictedScore * 0.4) + (fixtureRating * 0.2);
                
                // Apply injury risk penalty
                score *= (1 - (injuryRisk / 200));
                
                // Strategy modifiers
                if (strategy === 'aggressive') {
                    score *= player.predictedPoints > 8 ? 1.2 : 0.8;
                } else if (strategy === 'defensive') {
                    score *= injuryRisk < 30 ? 1.1 : 0.9;
                }
                
                return score;
            }

            // Helper functions for advanced team building
            isPlayerInTeam(team, playerId) {
                return Object.values(team).some(position => 
                    position.some(player => player && player.id === playerId)
                );
            }

            isValidTeam(team) {
                const requirements = { 1: 2, 2: 5, 3: 5, 4: 3 };
                
                for (let position = 1; position <= 4; position++) {
                    const playerCount = team[position] ? team[position].filter(p => p).length : 0;
                    if (playerCount < requirements[position]) {
                        return false;
                    }
                }
                
                // Check team limits (max 3 players from same team)
                const teamCounts = {};
                Object.values(team).forEach(position => {
                    position.forEach(player => {
                        if (player) {
                            teamCounts[player.team] = (teamCounts[player.team] || 0) + 1;
                        }
                    });
                });
                
                return Object.values(teamCounts).every(count => count <= 3);
            }

            // NEW ADVANCED FEATURES START HERE

            // Initialize all advanced features when class is created
            initializeAllAdvancedSystems() {
                try {
                    console.log('🚀 Initializing Advanced Systems...');
                    this.initializeAIPredictionEngine();
                    this.initializePriceTracker();
                    this.initializeSquadComparison();
                    this.initializeFDRCalculator();
                    this.initializeStrategySimulator();
                    this.initializeAdvancedStats();
                    this.initializeCompetitorAnalysis();
                    this.initializeChipOptimizer();
                    this.initializeOwnershipAnalysis();
                    this.initializeCaptainOptimizer();
                    console.log('✅ All Advanced Systems Initialized Successfully');
                } catch (error) {
                    console.error('Error initializing advanced systems:', error);
                    this.showNotification('Some advanced features may be limited', 'warning');
                }
            }

            // 1. AI Prediction Engine with Machine Learning
            initializeAIPredictionEngine() {
                this.aiPredictor = {
                    // Neural network simulation for player performance
                    neuralNetwork: {
                        layers: [10, 20, 15, 5, 1],
                        weights: [],
                        
                        predict: (player) => {
                            const features = [
                                parseFloat(player.form) / 10,
                                parseFloat(player.points_per_game) / 10,
                                parseFloat(player.selected_by_percent) / 100,
                                parseFloat(player.ict_index) / 100 || 0.5,
                                parseFloat(player.minutes) / 900 || 0.5,
                                (player.goals_scored || 0) / 20,
                                (player.assists || 0) / 15,
                                (player.clean_sheets || 0) / 20,
                                (player.bonus || 0) / 50,
                                Math.random() * 0.2
                            ];
                            
                            let output = features.reduce((sum, val) => sum + val, 0) / features.length;
                            output = output * 0.7 + Math.random() * 0.3;
                            
                            return {
                                predictedPoints: Math.round(output * 15),
                                confidence: Math.min(95, Math.round(70 + Math.random() * 25)),
                                riskLevel: output < 0.3 ? 'High' : output < 0.6 ? 'Medium' : 'Low'
                            };
                        }
                    },
                    
                    getAdvancedPrediction: (player) => {
                        const nn = this.aiPredictor.neuralNetwork.predict(player);
                        const fixtures = this.fixtureAnalyzer?.getDifficultyRating(player.team, 5) || 5;
                        
                        return {
                            ...nn,
                            fixtureImpact: fixtures < 4 ? '+15%' : fixtures < 7 ? '0%' : '-10%',
                            breakoutProbability: Math.random() > 0.7 ? 'High' : 'Low',
                            injuryRisk: Math.random() < 0.15 ? 'Elevated' : 'Normal'
                        };
                    }
                };
            }

            // 2. Real-time Price Tracking & Alerts
            initializePriceTracker() {
                this.priceTracker = {
                    priceAlerts: [],
                    priceHistory: {},
                    
                    trackPlayer: (playerId, targetPrice) => {
                        this.priceTracker.priceAlerts.push({
                            playerId,
                            targetPrice,
                            currentPrice: this.allPlayers.find(p => p.id === playerId)?.now_cost || 0,
                            timestamp: Date.now()
                        });
                    },
                    
                    getPriceTrend: (playerId) => {
                        const trends = [];
                        for (let i = 7; i >= 0; i--) {
                            trends.push({
                                day: i,
                                price: 50 + Math.random() * 10 - i * 0.5,
                                change: Math.random() > 0.5 ? '+0.1' : '-0.1'
                            });
                        }
                        return trends;
                    },
                    
                    getPredictedChange: (player) => {
                        const transfers = parseFloat(player.transfers_in_event) - parseFloat(player.transfers_out_event);
                        if (transfers > 100000) return { direction: '↑', probability: 85 };
                        if (transfers < -50000) return { direction: '↓', probability: 75 };
                        return { direction: '→', probability: 50 };
                    }
                };
            }

            // 3. Squad Comparison & Differential Analysis
            initializeSquadComparison() {
                this.squadComparison = {
                    compareWithTop: (percentile = 10) => {
                        const commonPlayers = Math.floor(Math.random() * 8) + 3;
                        const differentials = 15 - commonPlayers;
                        
                        return {
                            commonPlayers,
                            differentials,
                            uniqueScore: Math.round((differentials / 15) * 100),
                            riskRating: differentials > 10 ? 'High' : differentials > 5 ? 'Medium' : 'Low'
                        };
                    },
                    
                    findDifferentials: (maxOwnership = 5) => {
                        return this.allPlayers
                            .filter(p => parseFloat(p.selected_by_percent) < maxOwnership)
                            .filter(p => parseFloat(p.form) > 5)
                            .sort((a, b) => b.total_points - a.total_points)
                            .slice(0, 10);
                    }
                };
            }

            // 4. Advanced FDR Calculator
            initializeFDRCalculator() {
                this.fdrCalculator = {
                    calculate: (teamId, weeks = 6) => {
                        const fixtures = [];
                        for (let i = 0; i < weeks; i++) {
                            fixtures.push({
                                gameweek: 20 + i,
                                opponent: Math.floor(Math.random() * 20) + 1,
                                home: Math.random() > 0.5,
                                difficulty: Math.floor(Math.random() * 5) + 1
                            });
                        }
                        
                        const avgDifficulty = fixtures.reduce((sum, f) => sum + f.difficulty, 0) / weeks;
                        
                        return {
                            fixtures,
                            averageFDR: avgDifficulty.toFixed(2),
                            rating: avgDifficulty < 2.5 ? 'Excellent' : avgDifficulty < 3.5 ? 'Good' : 'Challenging',
                            recommendation: avgDifficulty < 3 ? 'Target players from this team' : 'Consider alternatives'
                        };
                    }
                };
            }

            // 5. Multi-week Transfer Strategy Simulator
            initializeStrategySimulator() {
                this.strategySimulator = {
                    simulateStrategy: (weeks = 4, transfersPerWeek = 1) => {
                        const strategy = [];
                        let totalCost = 0;
                        
                        for (let i = 0; i < weeks; i++) {
                            const suggestedTransfers = [];
                            for (let j = 0; j < transfersPerWeek; j++) {
                                const randomPlayer = this.allPlayers[Math.floor(Math.random() * 100)];
                                suggestedTransfers.push({
                                    out: 'Current Player',
                                    in: randomPlayer ? `${randomPlayer.first_name} ${randomPlayer.second_name}` : 'Unknown',
                                    cost: j === 0 ? 0 : 4,
                                    expectedGain: Math.floor(Math.random() * 15) + 5
                                });
                            }
                            
                            strategy.push({
                                gameweek: 20 + i,
                                transfers: suggestedTransfers,
                                hitCost: suggestedTransfers.reduce((sum, t) => sum + t.cost, 0)
                            });
                            
                            totalCost += strategy[strategy.length - 1].hitCost;
                        }
                        
                        return {
                            strategy,
                            totalHitsCost: totalCost,
                            expectedPoints: Math.floor(Math.random() * 50) + 30,
                            netGain: Math.floor(Math.random() * 50) + 30 - totalCost
                        };
                    }
                };
            }

            // 6. xG and Advanced Stats Integration
            initializeAdvancedStats() {
                this.advancedStats = {
                    getPlayerxG: (player) => {
                        const isAttacker = player.element_type >= 3;
                        const baseXG = isAttacker ? Math.random() * 0.8 : Math.random() * 0.3;
                        
                        return {
                            xG: baseXG.toFixed(2),
                            xA: (Math.random() * 0.5).toFixed(2),
                            xGI: (baseXG + Math.random() * 0.5).toFixed(2),
                            shots: Math.floor(Math.random() * 5),
                            keyPasses: Math.floor(Math.random() * 4),
                            bigChances: Math.floor(Math.random() * 3)
                        };
                    },
                    
                    getPerformanceMetrics: (player) => {
                        return {
                            overperforming: Math.random() > 0.5,
                            sustainabilityScore: Math.floor(Math.random() * 100),
                            luckIndex: (Math.random() * 2 - 1).toFixed(2),
                            consistencyRating: Math.floor(Math.random() * 5) + 1
                        };
                    }
                };
            }

            // 7. Mini-league Competitor Analysis
            initializeCompetitorAnalysis() {
                this.competitorAnalysis = {
                    analyzeRivals: (leagueSize = 10) => {
                        const rivals = [];
                        for (let i = 0; i < Math.min(leagueSize, 5); i++) {
                            rivals.push({
                                rank: i + 1,
                                name: `Manager ${i + 1}`,
                                points: 1200 - i * 50 + Math.floor(Math.random() * 20),
                                teamValue: 100.5 + Math.random() * 5,
                                captainSuccess: Math.floor(Math.random() * 40) + 40,
                                differentials: Math.floor(Math.random() * 5)
                            });
                        }
                        
                        return {
                            rivals,
                            yourRank: Math.floor(Math.random() * leagueSize) + 1,
                            pointsToLeader: Math.floor(Math.random() * 100),
                            catchProbability: Math.random() * 100
                        };
                    }
                };
            }

            // 8. Chip Strategy Optimizer
            initializeChipOptimizer() {
                this.chipOptimizer = {
                    optimizeChipTiming: () => {
                        const chips = ['Triple Captain', 'Bench Boost', 'Free Hit'];
                        const recommendations = {};
                        
                        chips.forEach(chip => {
                            const bestGW = Math.floor(Math.random() * 10) + 25;
                            recommendations[chip] = {
                                optimalGameweek: bestGW,
                                expectedPoints: Math.floor(Math.random() * 30) + 20,
                                confidence: Math.floor(Math.random() * 30) + 70,
                                reasoning: this.getChipReasoning(chip, bestGW)
                            };
                        });
                        
                        return recommendations;
                    },
                    
                    getChipReasoning: (chip, gw) => {
                        const reasons = {
                            'Triple Captain': `Double gameweek with premium assets having favorable fixtures`,
                            'Bench Boost': `Double gameweek with strong bench options expected to play`,
                            'Free Hit': `Blank gameweek with many regular starters not playing`
                        };
                        return reasons[chip] || 'Strategic timing based on fixtures';
                    }
                };
            }

            // 9. Ownership Heatmap & Differential Finder
            initializeOwnershipAnalysis() {
                this.ownershipAnalysis = {
                    generateHeatmap: () => {
                        const positions = ['GKP', 'DEF', 'MID', 'FWD'];
                        const heatmap = {};
                        
                        positions.forEach(pos => {
                            heatmap[pos] = {
                                high: Math.floor(Math.random() * 5) + 3,
                                medium: Math.floor(Math.random() * 5) + 5,
                                low: Math.floor(Math.random() * 5) + 2,
                                differential: Math.floor(Math.random() * 3) + 1
                            };
                        });
                        
                        return heatmap;
                    },
                    
                    findHiddenGems: () => {
                        return this.allPlayers
                            .filter(p => parseFloat(p.selected_by_percent) < 2)
                            .filter(p => parseFloat(p.points_per_game) > 4)
                            .sort((a, b) => b.points_per_game - a.points_per_game)
                            .slice(0, 5);
                    }
                };
            }

            // 10. Captain Pick Optimizer
            initializeCaptainOptimizer() {
                this.captainOptimizer = {
                    optimizeCaptaincy: (gameweek) => {
                        const candidates = this.currentSquad[3].concat(this.currentSquad[4])
                            .filter(p => p)
                            .map(player => {
                                const prediction = this.aiPredictor?.neuralNetwork.predict(player) || { predictedPoints: 5 };
                                const fixtures = this.fixtureAnalyzer?.getDifficultyRating(player.team, 1) || 5;
                                
                                return {
                                    player,
                                    expectedPoints: prediction.predictedPoints * (1 + (5 - fixtures) * 0.1),
                                    captaincyScore: Math.floor(Math.random() * 100),
                                    confidence: prediction.confidence || 75,
                                    effectiveOwnership: parseFloat(player.selected_by_percent) * 1.5
                                };
                            })
                            .sort((a, b) => b.expectedPoints - a.expectedPoints);
                        
                        return {
                            recommended: candidates[0],
                            viceCaptain: candidates[1],
                            differential: candidates.find(c => c.effectiveOwnership < 10),
                            safe: candidates.find(c => c.effectiveOwnership > 30)
                        };
                    }
                };
            }

            // Helper method for chip reasoning
            getChipReasoning(chip, gw) {
                const reasons = {
                    'Triple Captain': `Double gameweek with premium assets having favorable fixtures`,
                    'Bench Boost': `Double gameweek with strong bench options expected to play`,
                    'Free Hit': `Blank gameweek with many regular starters not playing`
                };
                return reasons[chip] || 'Strategic timing based on fixtures';
            }

            loadPriceChangeData() {
                // Mock price change data
                this.priceChangeData = {
                    risers: [
                        { name: 'Cole Palmer', team: 'Chelsea', currentPrice: 11.2, prediction: '+0.1', ownership: '+15.2%' },
                        { name: 'Bryan Mbeumo', team: 'Brentford', currentPrice: 7.8, prediction: '+0.1', ownership: '+22.8%' },
                        { name: 'Alexander Isak', team: 'Newcastle', currentPrice: 8.9, prediction: '+0.1', ownership: '+18.4%' },
                        { name: 'Mohamed Salah', team: 'Liverpool', currentPrice: 12.8, prediction: '+0.1', ownership: '+8.9%' },
                        { name: 'Bukayo Saka', team: 'Arsenal', currentPrice: 10.1, prediction: '+0.1', ownership: '+12.3%' }
                    ],
                    fallers: [
                        { name: 'Erling Haaland', team: 'Man City', currentPrice: 15.0, prediction: '-0.1', ownership: '-8.7%' },
                        { name: 'Son Heung-min', team: 'Tottenham', currentPrice: 9.8, prediction: '-0.1', ownership: '-12.4%' },
                        { name: 'Kevin De Bruyne', team: 'Man City', currentPrice: 9.4, prediction: '-0.1', ownership: '-15.6%' },
                        { name: 'Darwin Núñez', team: 'Liverpool', currentPrice: 7.9, prediction: '-0.1', ownership: '-18.2%' },
                        { name: 'Marcus Rashford', team: 'Man Utd', currentPrice: 6.8, prediction: '-0.1', ownership: '-22.1%' }
                    ]
                };

                this.displayPriceChanges('risers');
            }

            displayPriceChanges(type) {
                const container = document.getElementById('priceChangeGrid');
                if (!container) return;

                // Update button states
                document.querySelectorAll('.price-tab').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[onclick="showPriceChanges('${type}')"]`).classList.add('active');

                const data = this.priceChangeData[type] || [];

                container.innerHTML = data.map(player => `
                    <div class="price-change-card ${type === 'risers' ? 'riser' : 'faller'}">
                        <div class="price-player-name">${player.name}</div>
                        <div class="price-player-team">${player.team}</div>
                        <div class="price-change-info">
                            <div class="current-price">£${player.currentPrice}m</div>
                            <div class="price-prediction ${type === 'risers' ? 'rise' : 'fall'}">
                                ${player.prediction} ${type === 'risers' ? '⬆️' : '⬇️'}
                            </div>
                        </div>
                        <div class="ownership-change">TSB: ${player.ownership}</div>
                    </div>
                `).join('');
            }

            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    padding: 15px 25px;
                    border-radius: 10px;
                    color: white;
                    font-weight: 600;
                    z-index: 10000;
                    animation: slideIn 0.3s ease;
                `;
                
                const colors = {
                    success: 'linear-gradient(135deg, #28a745, #20c997)',
                    error: 'linear-gradient(135deg, #dc3545, #c82333)',
                    info: 'linear-gradient(135deg, #17a2b8, #138496)'
                };
                
                notification.style.background = colors[type] || colors.info;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        }

        // Global functions
        function filterPlayers() {
            if (window.transferSimPro) {
                window.transferSimPro.displayPlayers();
            }
        }
        
        function showPositionPlayers(position) {
            if (window.transferSimPro) {
                window.transferSimPro.showPositionPlayers(position);
            }
        }
        
        // Functions are made globally available after their definitions

        async function forceLoadPlayerData() {
            console.log('Force loading player data...');
            
            // Show loading indicator
            const loadingOverlay = document.createElement('div');
            loadingOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            loadingOverlay.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 30px; border-radius: 15px; text-align: center;">
                    <div style="font-size: 1.5rem; margin-bottom: 10px;">⚠️ Force Loading Data</div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">Loading from player-data-2.html...</div>
                    <div class="spinner" style="margin-top: 15px; width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 15px auto 0;"></div>
                </div>
            `;
            document.body.appendChild(loadingOverlay);
            
            try {
                // First try to load from player-data-2.html
                try {
                    const response = await fetch('player-data-2.html', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data && data.elements && data.elements.length > 0) {
                            window.transferSimPro.allPlayers = data.elements;
                            window.transferSimPro.teams = data.teams;
                            
                            // Create teams lookup
                            window.transferSimPro.teamsLookup = {};
                            if (data.teams) {
                                data.teams.forEach(team => {
                                    window.transferSimPro.teamsLookup[team.id] = {
                                        name: team.name,
                                        short_name: team.short_name
                                    };
                                });
                            }
                            
                            // Process player data
                            window.transferSimPro.allPlayers = window.transferSimPro.allPlayers.map(player => ({
                                ...player,
                                team_name: window.transferSimPro.teamsLookup[player.team]?.name || 'Unknown',
                                team_short: window.transferSimPro.teamsLookup[player.team]?.short_name || 'UNK',
                                display_name: `${player.first_name} ${player.second_name}`,
                                position_name: ['GKP', 'DEF', 'MID', 'FWD'][player.element_type - 1] || 'Unknown'
                            }));
                            
                            console.log(`Force loaded ${window.transferSimPro.allPlayers.length} players from player-data-2.html`);
                            window.transferSimPro.showNotification(`✅ Loaded ${window.transferSimPro.allPlayers.length} players from local data!`, 'success');
                            
                            // Update displays
                            window.transferSimPro.updateDisplay();
                            window.transferSimPro.updateCharts();
                            window.transferSimPro.updateSquadDisplay();
                            
                            // Update last update time
                            const now = new Date();
                            document.getElementById('lastUpdate').textContent = `Force loaded at ${now.toLocaleTimeString()}`;
                            
                            loadingOverlay.remove();
                            return;
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load from player-data-2.html:', e);
                }
                
                // First ensure we have a FPLDataService
                if (typeof FPLDataService === 'undefined') {
                    // Try to load the script again
                    const script = document.createElement('script');
                    script.src = 'fpl-api.js';
                    document.head.appendChild(script);
                    
                    // Wait for script to load
                    await new Promise(resolve => {
                        script.onload = resolve;
                        setTimeout(resolve, 2000); // Timeout after 2 seconds
                    });
                }
                
                // Try to get mock data as a fallback
                if (typeof FPLDataService !== 'undefined') {
                    const fplService = new FPLDataService();
                    const mockData = fplService.getMockBootstrapData();
                    
                    if (mockData && mockData.elements && mockData.elements.length > 0) {
                        window.transferSimPro.allPlayers = mockData.elements;
                        window.transferSimPro.teams = mockData.teams;
                        
                        // Create teams lookup
                        window.transferSimPro.teamsLookup = {};
                        if (mockData.teams) {
                            mockData.teams.forEach(team => {
                                window.transferSimPro.teamsLookup[team.id] = {
                                    name: team.name,
                                    short_name: team.short_name
                                };
                            });
                        }
                        
                        console.log(`Force loaded ${window.transferSimPro.allPlayers.length} players from mock data`);
                        window.transferSimPro.showNotification(`✅ Loaded ${window.transferSimPro.allPlayers.length} players (sample data)`, 'success');
                        
                        // Update displays
                        window.transferSimPro.updateDisplay();
                        window.transferSimPro.updateCharts();
                        
                        // Update last update time
                        document.getElementById('lastUpdate').textContent = 'Sample data loaded';
                    }
                }
                
            } catch (error) {
                console.error('Force load failed:', error);
                // Silently log error instead of showing alert
                console.log('Will continue with available data');
            } finally {
                // Remove loading overlay
                loadingOverlay.remove();
            }
        }
        
        function refreshPlayerData() {
            if (window.transferSimPro) {
                // Show loading indicator
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex';
                }
                
                // Force reload of player data without cache
                window.transferSimPro.loadPlayerData().then(() => {
                    // Hide loading indicator
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    
                    // Re-initialize displays
                    window.transferSimPro.updateDisplay();
                    window.transferSimPro.updateCharts();
                    
                    // Show success message
                    window.transferSimPro.showNotification('🔄 Data refreshed successfully!', 'success');
                }).catch(error => {
                    console.error('Failed to refresh data:', error);
                    if (loadingOverlay) {
                        loadingOverlay.style.display = 'none';
                    }
                    // Silently log instead of showing error notification
                    console.log('Data refresh failed, will retry later');
                });
            }
        }

        // Duplicate processTeamImage function removed - using the one defined later in the code

        function processOCRText(text, words, lines) {
            if (!window.transferSimPro || !window.transferSimPro.allPlayers) {
                console.error('Player data not loaded');
                return [];
            }
            
            const detectedPlayers = [];
            const allPlayers = window.transferSimPro.allPlayers;
            const matchedPlayerIds = new Set();
            
            // Define ignoredWords at the top of the function so it's available everywhere
            const ignoredWords = [
                // Team abbreviations (ALL Premier League teams)
                'ars', 'avl', 'bha', 'bre', 'bur', 'che', 'cry', 'eve', 'ful', 'liv', 
                'lut', 'mci', 'mun', 'new', 'nfo', 'shu', 'tot', 'whu', 'wol', 'lei',
                'bou', 'lee', 'sou', 'wat', 'nor', 'bri', 'mid', 'hul', 'ips', 'pne',
                'qpr', 'swa', 'car', 'sto', 'wba', 'der', 'rea', 'mnc', 'lfc', 'afc',
                'cfc', 'mufc', 'thfc', 'nufc', 'lufc', 'sufc', 'bfc', 'wfc', 'efc',
                
                // Position codes
                'gkp', 'def', 'mid', 'fwd', 'gk', 'goalkeeper', 'defender', 'midfielder', 'forward',
                
                // FPL UI words
                'fantasy', 'premier', 'league', 'fpl', 'points', 'team', 'squad', 'pick',
                'gameweek', 'gw', 'captain', 'vice', 'bench', 'triple', 'wildcard', 'chips',
                'transfers', 'bank', 'value', 'itb', 'overall', 'rank', 'score', 'total',
                'my', 'your', 'the', 'player', 'players', 'view', 'edit', 'save', 'cancel',
                'confirm', 'back', 'next', 'previous', 'home', 'fixtures', 'stats', 'help',
                'logout', 'login', 'register', 'password', 'email', 'username', 'account',
                'settings', 'profile', 'history', 'leagues', 'cup', 'head', 'mini', 'classic',
                'global', 'country', 'gameweek', 'deadline', 'live', 'bonus', 'bps', 'price',
                'rise', 'fall', 'locked', 'unlocked', 'available', 'unavailable', 'injured',
                'suspended', 'doubtful', 'chance', 'news', 'scout', 'selection', 'ownership',
                'effective', 'template', 'differential', 'essential', 'rotation', 'nailed',
                'minutes', 'played', 'starts', 'substitute', 'subbed', 'yellow', 'red', 'card',
                'clean', 'sheet', 'goal', 'assist', 'penalty', 'saved', 'missed', 'scored',
                'conceded', 'points', 'last', 'round', 'season', 'form', 'difficulty',
                'home', 'away', 'opponent', 'result', 'win', 'draw', 'loss', 'match',
                'pitch', 'list', 'boost', 'free', 'hit',
                
                // Numbers and symbols that aren't part of names
                '2024', '2025', '2023', 'pts', 'vs', 'fc', 'united', 'city', 'town',
                'albion', 'athletic', 'rovers', 'wanderers', 'hotspur', 'palace', 'villa',
                'forest', 'ham', 'bromwich', 'wednesday', 'saturday', 'sunday', 'monday',
                
                // Common OCR artifacts
                'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x',
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'w', 'y', 'z',
                
                // Price indicators
                '£', '$', 'm', 'mil', 'million', '.', ',', '-', '+', '=',
                
                // Days and months (often appear in fixtures)
                'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec',
                'january', 'february', 'march', 'april', 'june', 'july', 'august', 'september',
                'october', 'november', 'december', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'
            ];
            
            // Normalize text for better matching
            const normalizedText = text.toUpperCase().replace(/[^A-Z\s]/g, ' ');
            
            // Common OCR mistakes to fix
            const ocrCorrections = {
                '0': 'O', 'O': '0',  // O/0 confusion
                '1': 'I', 'I': '1', 'l': '1',  // I/1/l confusion
                '5': 'S', 'S': '5',  // S/5 confusion
                '8': 'B',  // 8/B confusion
                'rn': 'm', 'm': 'rn',  // rn/m confusion
                'vv': 'w', 'w': 'vv',  // w/vv confusion
            };
            
            // Create lookup maps for faster matching
            const playerLookup = {
                byFullName: {},
                byLastName: {},
                byWebName: {},
                byFirstName: {},
                byCommonName: {} // Add common variations
            };
            
            allPlayers.forEach(player => {
                const fullName = `${player.first_name} ${player.second_name}`.toLowerCase();
                const lastName = player.second_name.toLowerCase();
                const firstName = player.first_name.toLowerCase();
                const webName = (player.web_name || '').toLowerCase();
                
                playerLookup.byFullName[fullName] = player;
                playerLookup.byFullName[fullName.replace(/[^a-z]/g, '')] = player; // Without spaces/special chars
                
                playerLookup.byLastName[lastName] = playerLookup.byLastName[lastName] || [];
                playerLookup.byLastName[lastName].push(player);
                
                playerLookup.byFirstName[firstName] = playerLookup.byFirstName[firstName] || [];
                playerLookup.byFirstName[firstName].push(player);
                
                if (webName) {
                    playerLookup.byWebName[webName] = player;
                    playerLookup.byWebName[webName.replace(/[^a-z]/g, '')] = player; // Without special chars
                }
                
                // Add common name variations
                if (webName.includes('-')) {
                    // For hyphenated names, also index without hyphen
                    playerLookup.byCommonName[webName.replace('-', '')] = player;
                }
                
                // Special handling for web_name with initials like M.Salah
                if (webName.includes('.')) {
                    // Add variations without the dot
                    playerLookup.byCommonName[webName.replace('.', '')] = player;
                    playerLookup.byCommonName[webName.replace('.', ' ')] = player;
                    
                    // For M.Salah specifically
                    if (webName === 'm.salah') {
                        playerLookup.byCommonName['mo salah'] = player;
                        playerLookup.byCommonName['mosalah'] = player;
                        playerLookup.byCommonName['mohamed salah'] = player;
                        playerLookup.byCommonName['mohammed salah'] = player;
                        playerLookup.byCommonName['m salah'] = player;
                        playerLookup.byCommonName['salah'] = player;
                    }
                }
                
                // Add nickname variations for known players
                const nicknames = {
                    'alexander-arnold': ['taa', 'trent', 'alexander arnold'],
                    'van dijk': ['vvd', 'vandijk', 'virgil'],
                    'de bruyne': ['kdb', 'debruyne', 'kevin'],
                    'son': ['sonny', 'son heung-min', 'heung-min'],
                    'fernandes': ['bruno'],
                    'diogo j.': ['jota', 'diogo jota', 'diogo'],
                    'gabriel': ['gabriel m', 'gabriel magalhaes'],
                    'martinelli': ['gabriel martinelli', 'gabi'],
                    'salah': ['mo salah', 'mohamed salah', 'm.salah', 'mo', 'mohamed', 'm salah', 'mo.salah', 'm. salah', 'mosalah', 'msalah', 'mohammed salah'],
                    'haaland': ['erling', 'erling haaland'],
                    'saka': ['bukayo', 'bukayo saka'],
                    'palmer': ['cole', 'cole palmer'],
                    'watkins': ['ollie', 'ollie watkins'],
                    'foden': ['phil', 'phil foden'],
                    'rice': ['declan', 'declan rice'],
                    'havertz': ['kai', 'kai havertz'],
                    'rashford': ['marcus', 'marcus rashford'],
                    'isak': ['alexander', 'alex', 'alexander isak'],
                    'gordon': ['anthony', 'anthony gordon'],
                    'jackson': ['nicolas', 'nico', 'nicolas jackson'],
                    'nunez': ['darwin', 'darwin nunez'],
                    'eze': ['eberechi', 'ebere', 'eberechi eze'],
                    'madueke': ['noni', 'noni madueke'],
                    'mitoma': ['kaoru', 'kaoru mitoma'],
                    'mcginn': ['john', 'john mcginn'],
                    'odegaard': ['martin', 'martin odegaard'],
                };
                
                Object.entries(nicknames).forEach(([key, variations]) => {
                    if (webName.includes(key) || lastName.includes(key)) {
                        variations.forEach(nick => {
                            playerLookup.byCommonName[nick] = player;
                        });
                    }
                });
            });
            
            // Process structured OCR data if available
            const potentialNames = [];
            
            // Pattern to identify player-like text (starts with capital, has vowels)
            const isLikelyPlayerName = (text) => {
                // Must have at least one vowel
                if (!/[aeiouAEIOU]/.test(text)) return false;
                // Must start with a letter
                if (!/^[A-Za-z]/.test(text)) return false;
                // Should not be all uppercase (unless it's a known abbreviation)
                if (text.length > 3 && text === text.toUpperCase()) return false;
                // Should be reasonable length for a name
                if (text.length < 2 || text.length > 20) return false;
                return true;
            };
            
            // First try to use structured lines data
            if (lines && lines.length > 0) {
                lines.forEach(line => {
                    const lineText = line.text || '';
                    console.log('Processing line:', lineText);
                    
                    // Clean the line but handle special cases first
                    let cleaned = lineText;
                    
                    // Special handling for common patterns before cleaning
                    if (cleaned.match(/^(Mo|M)\s+Salah/i) || cleaned.match(/^M\.\s*Salah/i)) {
                        potentialNames.push('Mohamed Salah');
                    }
                    
                    cleaned = cleaned
                        .replace(/[0-9]+\.[0-9]+/g, '') // Remove prices like 11.5
                        .replace(/£/g, '')
                        .replace(/\$/g, '')
                        .replace(/\d+pts?/gi, '') // Remove points
                        .replace(/\([^)]*\)/g, '') // Remove content in parentheses
                        .replace(/\s+/g, ' ') // Normalize spaces
                        .trim();
                    
                    if (cleaned && cleaned.length > 2) {
                        potentialNames.push(cleaned);
                        
                        // Also extract individual words as potential single names
                        const words = cleaned.split(/[\s,;]+/).filter(word => word.length >= 3);
                        words.forEach(word => {
                            // Clean up the word
                            const cleanWord = word.replace(/[^a-zA-Z'-]/g, '').trim();
                            if (cleanWord.length >= 3) {
                                // Skip common non-name words and team abbreviations
                                const wordLower = cleanWord.toLowerCase();
                                
                                // Team abbreviations (3-letter codes)
                                const teamCodes = ['ars', 'avl', 'bha', 'bre', 'bur', 'che', 'cry', 'eve', 'ful', 'liv', 'lut', 'mci', 'mun', 'new', 'nfo', 'shu', 'tot', 'whu', 'wol', 'lei', 
                                                  // Also common variations
                                                  'bou', 'lee', 'sou', 'wat', 'nor', 'bri', 'mid', 'hul', 'ips', 'pne', 'qpr', 'swa', 'car', 'sto', 'wba', 'der', 'rea'];
                                
                                // Skip if it's a team code (especially 3-letter ones)
                                if (teamCodes.includes(wordLower) || 
                                    (cleanWord.length === 3 && cleanWord === cleanWord.toUpperCase())) {
                                    return; // Skip team codes (use return in forEach, not continue)
                                }
                                
                                if (!['the', 'and', 'for', 'with', 'from', 'bench', 'captain', 'vice', 'team', 'squad', 'points', 'player', 'game', 'week', 'total', 'your', 'free', 'hit', 'wildcard', 'boost', 'triple', 'chips', 'transfers', 'bank', 'gkp', 'def', 'mid', 'fwd'].includes(wordLower)) {
                                    potentialNames.push(cleanWord);
                                    // Also try without apostrophes or hyphens
                                    if (cleanWord.includes("'") || cleanWord.includes('-')) {
                                        potentialNames.push(cleanWord.replace(/['-]/g, ''));
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            // Also process individual words
            if (words && words.length > 0) {
                let currentName = '';
                words.forEach((word, index) => {
                    const text = (word.text || '').trim();
                    
                    // Skip numbers, prices, and short words
                    if (/^\d+$/.test(text) || /^[£$]/.test(text) || text.length < 2) {
                        if (currentName) {
                            potentialNames.push(currentName.trim());
                            currentName = '';
                        }
                        return;
                    }
                    
                    // Check if this could be part of a name (must look like a name)
                    if (/^[A-Za-z]/.test(text) && isLikelyPlayerName(text)) {
                        // Check if next word is also alphabetic (likely part of same name)
                        if (index < words.length - 1) {
                            const nextWord = words[index + 1].text || '';
                            if (/^[A-Za-z]/.test(nextWord) && !ignoredWords.includes(nextWord.toLowerCase())) {
                                currentName += text + ' ';
                            } else {
                                // This is likely a single-word name or last part
                                currentName += text;
                                if (isLikelyPlayerName(currentName.trim())) {
                                    potentialNames.push(currentName.trim());
                                }
                                currentName = '';
                            }
                        } else {
                            currentName += text;
                            if (isLikelyPlayerName(currentName.trim())) {
                                potentialNames.push(currentName.trim());
                            }
                            currentName = '';
                        }
                    } else if (currentName) {
                        potentialNames.push(currentName.trim());
                        currentName = '';
                    }
                });
                
                if (currentName) {
                    potentialNames.push(currentName.trim());
                }
            }
            
            // Also process raw text as fallback
            if (text) {
                const textLines = text.split('\n');
                textLines.forEach(line => {
                    // Extract potential names using regex
                    const namePattern = /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g;
                    const matches = line.match(namePattern);
                    if (matches) {
                        matches.forEach(match => {
                            if (match.length > 2) {
                                potentialNames.push(match);
                            }
                        });
                    }
                    
                    // Also try to extract individual words as potential single names
                    const words = line.split(/\s+/);
                    words.forEach(word => {
                        const cleaned = word.replace(/[^A-Za-z-']/g, '');
                        if (cleaned.length >= 3 && cleaned.length <= 20) {
                            // Skip common non-name words and team abbreviations
                            const cleanedLower = cleaned.toLowerCase();
                            
                            // Team abbreviations
                            const teamCodes = ['ars', 'avl', 'bha', 'bre', 'bur', 'che', 'cry', 'eve', 'ful', 'liv', 'lut', 'mci', 'mun', 'new', 'nfo', 'shu', 'tot', 'whu', 'wol', 'lei', 
                                              'bou', 'lee', 'sou', 'wat', 'nor', 'bri', 'mid', 'hul', 'ips', 'pne', 'qpr', 'swa', 'car', 'sto', 'wba', 'der', 'rea'];
                            
                            // Skip team codes and common words  
                            if (!teamCodes.includes(cleanedLower) && 
                                !(cleaned.length === 3 && cleaned === cleaned.toUpperCase()) &&
                                !['the', 'and', 'for', 'with', 'from', 'bench', 'captain', 'vice', 'team', 'squad', 'points', 'player', 'game', 'week', 'total', 'your', 'gkp', 'def', 'mid', 'fwd'].includes(cleanedLower)) {
                                potentialNames.push(cleaned);
                            }
                        }
                    });
                });
            }
            
            console.log('Potential player names found:', potentialNames);
            
            // Comprehensive function to apply OCR corrections
            function applyOCRCorrections(text) {
                let corrected = text;
                
                // Create a comprehensive correction map for ALL common players
                const playerCorrections = {
                    // Top players with common OCR errors
                    '0degaard|Odegaard|0degard|Ødegaard': 'Odegaard',
                    '5alah|Salah|Sa1ah|Saleh': 'Salah',
                    '5aka|Saka|Sake': 'Saka',
                    'Ha[al][al]and|Haaland|Haa1and|Ha1and': 'Haaland',
                    'Watk[il]ns|Watkins|Watk1ns': 'Watkins',
                    'R[il]ce|Rice|R1ce': 'Rice',
                    'Palm[ae]r|Palmer|Pa1mer': 'Palmer',
                    'F[0o]den|Foden|F0den': 'Foden',
                    'Mart[il]nez|Martinez|Mart1nez': 'Martinez',
                    'Gabr[il]el|Gabriel|Gabrie1': 'Gabriel',
                    'Tr[il]pp[il]er|Trippier|Tr1pp1er': 'Trippier',
                    'Rash[if]ord|Rashford': 'Rashford',
                    'Fernand[ae]s|Fernandes|Bruno': 'Fernandes',
                    'Kulu[sz]evsk[il]|Kulusevski': 'Kulusevski',
                    'Eze|Ez[ae]': 'Eze',
                    'Mad[uü]eke|Madueke': 'Madueke',
                    'Al[il]sson|Alisson|A11isson': 'Alisson',
                    'Ederson|Ed[ae]rson': 'Ederson',
                    'Pickford|P[il]ckford': 'Pickford',
                    'Raya|Ray[ae]': 'Raya',
                    'V[il]rg[il]l|Virgil|Van Dijk': 'Virgil',
                    'Sal[il]ba|Saliba|Sa11ba': 'Saliba',
                    'Wh[il]te|White|Wh1te': 'White',
                    'Z[il]nchenko|Zinchenko': 'Zinchenko',
                    'Gvard[il]ol|Gvardiol': 'Gvardiol',
                    'Konat[eé]|Konate': 'Konate',
                    'Jo[aã]o Pedro|João Pedro|Joao Pedro|Jodo Pedro': 'João Pedro',
                    'Mbeumo|Mbuemo|Mbeuma': 'Mbeumo',
                    'Gord[0o]n|Gordon': 'Gordon',
                    'S[0o]n|Son|5on': 'Son',
                    'D[il]az|Diaz|D1az': 'Diaz',
                    '[Il]sak|Isak|1sak': 'Isak',
                    'So1anke|Solanke': 'Solanke',
                    'Cunha|Cunh[ae]': 'Cunha',
                    'Bowen|Bow[ae]n': 'Bowen',
                    'Porro|P[0o]rro': 'Porro',
                    'Trent|Alexander-Arnold|TAA': 'Alexander-Arnold',
                    'Robertson|Rob[ae]rtson': 'Robertson',
                    'Cancelo|Canc[ae]lo': 'Cancelo',
                    'Gueh[il]|Guehi': 'Guehi',
                    'Ait-Nouri|A[il]t-Nour[il]': 'Ait-Nouri',
                    'Estupinan|Estup[il]nan': 'Estupinan',
                    'Dunk|D[uü]nk': 'Dunk',
                    'Romero|Rom[ae]ro': 'Romero',
                    'Ud[0o]gie|Udogie': 'Udogie',
                    'Mitr[0o]vic|Mitrovic': 'Mitrovic',
                    'Neto|N[ae]to': 'Neto',
                    'Sanchez|Sanch[ae]z': 'Sanchez',
                    'Onana|[0O]nana': 'Onana',
                    'Casemiro|Cas[ae]miro': 'Casemiro',
                    'Mount|M[0o]unt': 'Mount',
                    'Grealish|Gr[ae]alish': 'Grealish',
                    'Bernardo|B[ae]rnardo': 'Bernardo',
                    'De Bruyne|D[ae] Bruyne|KDB': 'De Bruyne',
                    'Sterling|St[ae]rling': 'Sterling',
                    'Jesus|J[ae]sus': 'Jesus',
                    'Nunez|N[uü]nez|Darwin': 'Nunez',
                    'Jota|J[0o]ta': 'Jota',
                    'Richarlison|R[il]charlison': 'Richarlison',
                    'Maddison|Madd[il]son': 'Maddison',
                    'Odoi|[0O]doi|Hudson-Odoi': 'Hudson-Odoi',
                    'Welbeck|W[ae]lbeck': 'Welbeck',
                    'Toney|T[0o]ney': 'Toney',
                    'Awoniyi|Aw[0o]niyi': 'Awoniyi',
                    'Jimenez|J[il]menez|Raul': 'Jimenez',
                    'Pedro|P[ae]dro': 'Pedro',
                    'Wilson|W[il]lson|Callum': 'Wilson',
                    'Mitrovic|M[il]trovic': 'Mitrovic',
                    'Mateta|Mat[ae]ta': 'Mateta',
                    'Edouard|[AE]douard': 'Edouard',
                    // Your specific team players
                    'Raya|Ray[ae]': 'Raya',
                    'Petrovic|P[ae]trovic': 'Petrovic',
                    'Gabr[il]el|Gabriel|Gabrie1': 'Gabriel',
                    'Gueh[il]|Guehi|Guhei': 'Guehi', // Common OCR: Guhei -> Guehi
                    'Munoz|Mun[0o]z': 'Muñoz',
                    'Gvard[il]ol|Gvardiol': 'Gvardiol',
                    'Moreno|Mor[ae]no|Alex Moreno': 'Moreno',
                    'Mbeumo|Mbuemo|Mbeuma': 'Mbeumo',
                    'Mitoma|M[il]toma': 'Mitoma',
                    'Palm[ae]r|Palmer|Pa1mer': 'Palmer',
                    'Mo Salah|M\.Salah|M Salah|Mohamed Salah|Salah': 'Salah',
                    'Arron Ramsey|Aaron Ramsey|A\.Ramsey|A Ramsey|Ramsey': 'Ramsey',
                    'Wood|W[0o]od': 'Wood',
                    'Jo[aã]o Pedro|João Pedro|Joao Pedro|Jodo Pedro': 'João Pedro',
                    'Redmond|R[ae]dmond': 'Redmond',
                    'Snapdragon': '', // Remove sponsor text that might appear
                };
                
                // Apply all corrections
                for (const [pattern, replacement] of Object.entries(playerCorrections)) {
                    const regex = new RegExp(pattern, 'gi');
                    corrected = corrected.replace(regex, replacement);
                }
                
                return corrected;
            }
            
            // Skip the duplicate code - REMOVED
            function skipDuplicateCode() {
                corrected = corrected.replace(/S[0o]n/gi, 'Son');
                corrected = corrected.replace(/Kulusevsk[il]/gi, 'Kulusevski');
                // Additional common OCR errors
                corrected = corrected.replace(/Jodo Pedro/gi, 'João Pedro');
                corrected = corrected.replace(/Joao Pedro/gi, 'João Pedro');
                corrected = corrected.replace(/Betano/gi, 'Beto');
                corrected = corrected.replace(/Rash[if]ord/gi, 'Rashford');
                corrected = corrected.replace(/Fernand[ae]s/gi, 'Fernandes');
                corrected = corrected.replace(/McG[il]nn/gi, 'McGinn');
                corrected = corrected.replace(/Mad[uü]eke/gi, 'Madueke');
                corrected = corrected.replace(/Eze/gi, 'Eze');
                corrected = corrected.replace(/Mitoma/gi, 'Mitoma');
                
                // Common OCR misreads for specific players
                corrected = corrected.replace(/Alisson/gi, 'Alisson');
                corrected = corrected.replace(/A[l1]isson/gi, 'Alisson');
                corrected = corrected.replace(/Ha[a@]land/gi, 'Haaland');
                corrected = corrected.replace(/Tr[il1]pp[il1]er/gi, 'Trippier');
                corrected = corrected.replace(/Wh[il1]te/gi, 'White');
                corrected = corrected.replace(/Cancelo/gi, 'Cancelo');
                corrected = corrected.replace(/Z[il1]nchenko/gi, 'Zinchenko');
                corrected = corrected.replace(/T[il1]mber/gi, 'Timber');
                corrected = corrected.replace(/Konat[eé]/gi, 'Konate');
                corrected = corrected.replace(/Gvard[il1]ol/gi, 'Gvardiol');
                corrected = corrected.replace(/Cucu?rella/gi, 'Cucurella');
                corrected = corrected.replace(/Estup[il1]nan/gi, 'Estupinan');
                corrected = corrected.replace(/Bot?man/gi, 'Botman');
                corrected = corrected.replace(/Sal[il1]ba/gi, 'Saliba');
                corrected = corrected.replace(/M[il1]ngs/gi, 'Mings');
                corrected = corrected.replace(/K[il1]lman/gi, 'Kilman');
                corrected = corrected.replace(/Gueh[il1]/gi, 'Guehi');
                corrected = corrected.replace(/D[il1]gne/gi, 'Digne');
                corrected = corrected.replace(/Rodr[il1]/gi, 'Rodri');
                corrected = corrected.replace(/Ca[il1]cedo/gi, 'Caicedo');
                corrected = corrected.replace(/Szoboszla[il1]/gi, 'Szoboszlai');
                corrected = corrected.replace(/Mad?dison/gi, 'Maddison');
                corrected = corrected.replace(/B[il1]ssouma/gi, 'Bissouma');
                corrected = corrected.replace(/T[il1]elemans/gi, 'Tielemans');
                corrected = corrected.replace(/Nd[il1]d[il1]/gi, 'Ndidi');
                corrected = corrected.replace(/Doucour[eé]/gi, 'Doucoure');
                corrected = corrected.replace(/Ba[il1]ley/gi, 'Bailey');
                corrected = corrected.replace(/Douglas Lu[il1]z/gi, 'Douglas Luiz');
                corrected = corrected.replace(/G[il1]bbs.?Wh[il1]te/gi, 'Gibbs-White');
                corrected = corrected.replace(/Johnson/gi, 'Johnson');
                corrected = corrected.replace(/Elanga/gi, 'Elanga');
                corrected = corrected.replace(/W[il1]lson/gi, 'Wilson');
                corrected = corrected.replace(/Vardy/gi, 'Vardy');
                corrected = corrected.replace(/Jesus/gi, 'Jesus');
                corrected = corrected.replace(/F[il1]rm[il1]no/gi, 'Firmino');
                corrected = corrected.replace(/Nunez/gi, 'Nunez');
                corrected = corrected.replace(/N[uú]n?ez/gi, 'Nunez');
                corrected = corrected.replace(/Gakpo/gi, 'Gakpo');
                corrected = corrected.replace(/Toney/gi, 'Toney');
                corrected = corrected.replace(/W[il1]ssa/gi, 'Wissa');
                corrected = corrected.replace(/Bamford/gi, 'Bamford');
                corrected = corrected.replace(/Rodr[il1]go/gi, 'Rodrigo');
                corrected = corrected.replace(/Greenwood/gi, 'Greenwood');
                corrected = corrected.replace(/Sancho/gi, 'Sancho');
                corrected = corrected.replace(/Antony/gi, 'Antony');
                corrected = corrected.replace(/Garnacho/gi, 'Garnacho');
                corrected = corrected.replace(/Mart[il1]al/gi, 'Martial');
                corrected = corrected.replace(/Sterl[il1]ng/gi, 'Sterling');
                corrected = corrected.replace(/Mudryk/gi, 'Mudryk');
                corrected = corrected.replace(/Z[il1]yech/gi, 'Ziyech');
                corrected = corrected.replace(/Pul[il1]s[il1]c/gi, 'Pulisic');
                corrected = corrected.replace(/R[il1]charl[il1]son/gi, 'Richarlison');
                corrected = corrected.replace(/Per[il1]s[il1]c/gi, 'Perisic');
                corrected = corrected.replace(/Solomon/gi, 'Solomon');
                corrected = corrected.replace(/Werner/gi, 'Werner');
                corrected = corrected.replace(/[AÁ]lvarez/gi, 'Alvarez');
                corrected = corrected.replace(/Greal[il1]sh/gi, 'Grealish');
                corrected = corrected.replace(/Doku/gi, 'Doku');
                corrected = corrected.replace(/Bernardo/gi, 'Bernardo');
                corrected = corrected.replace(/Mahrez/gi, 'Mahrez');
                corrected = corrected.replace(/Bowen/gi, 'Bowen');
                corrected = corrected.replace(/Anton[il1]o/gi, 'Antonio');
                corrected = corrected.replace(/Benrahma/gi, 'Benrahma');
                corrected = corrected.replace(/Paquet[aá]/gi, 'Paqueta');
                corrected = corrected.replace(/Kudus/gi, 'Kudus');
                corrected = corrected.replace(/Ward.?Prowse/gi, 'Ward-Prowse');
                corrected = corrected.replace(/[Il1]ngs/gi, 'Ings');
                corrected = corrected.replace(/Zaha/gi, 'Zaha');
                corrected = corrected.replace(/Ol[il1]se/gi, 'Olise');
                corrected = corrected.replace(/Ayew/gi, 'Ayew');
                corrected = corrected.replace(/[EÉ]douard/gi, 'Edouard');
                corrected = corrected.replace(/Mateta/gi, 'Mateta');
                
                // Handle Mo Salah and M.Salah variations
                corrected = corrected.replace(/M\.\s*Salah/gi, 'Mohamed Salah');
                corrected = corrected.replace(/Mo\s+Salah/gi, 'Mohamed Salah');
                corrected = corrected.replace(/M\s+Salah/gi, 'Mohamed Salah');
                corrected = corrected.replace(/A\.\s*Ramsey/gi, 'Aaron Ramsey');
                corrected = corrected.replace(/J\.\s*Ramsey/gi, 'Jacob Ramsey');
                
                // Fix spacing issues
                corrected = corrected.replace(/\s+/g, ' ').trim();
                
                // This duplicate code has been removed - keeping for reference only
            }
            
            // ignoredWords already defined at the top of the function
            
            const uniqueNames = [...new Set(potentialNames)].filter(name => {
                const nameLower = name.toLowerCase().trim();
                
                // Filter out all ignored words (teams, UI elements, etc.)
                if (ignoredWords.includes(nameLower)) {
                    console.log(`Filtered out: "${name}" (ignored word)`);
                    return false;
                }
                
                // Filter out pure numbers or prices (e.g., "5.5", "10.0", "100")
                if (name.match(/^[\d.]+$/)) {
                    console.log(`Filtered out: "${name}" (number/price)`);
                    return false;
                }
                
                // Filter out single letters
                if (name.length === 1) {
                    console.log(`Filtered out: "${name}" (single letter)`);
                    return false;
                }
                
                // Filter out 3-letter uppercase codes UNLESS they're known player initials
                const knownPlayerInitials = ['SON', 'CHO', 'AWB', 'TAA', 'DCL', 'JWP', 'KDB', 'ESR', 'ASM'];
                if (name.length === 3 && name === name.toUpperCase() && !knownPlayerInitials.includes(name)) {
                    console.log(`Filtered out: "${name}" (3-letter code)`);
                    return false;
                }
                
                // Filter out 2-letter codes
                if (name.length === 2 && name === name.toUpperCase()) {
                    console.log(`Filtered out: "${name}" (2-letter code)`);
                    return false;
                }
                
                // Filter out currency/price indicators
                if (name.includes('£') || name.includes('$') || name.includes('€') || name.includes('%')) {
                    console.log(`Filtered out: "${name}" (currency/symbol)`);
                    return false;
                }
                
                // Keep valid player names
                console.log(`Keeping potential player name: "${name}"`);
                return true;
            });
            
            console.log('Total unique names to check (after filtering team codes):', uniqueNames.length);
            console.log('Sample names:', uniqueNames.slice(0, 20));
            
            // FIRST: Try direct search for known player names in the raw text
            const directMatches = [];
            const textLower = (text || '').toLowerCase();
            
            // Search for each player's name directly in the text with more flexible matching
            allPlayers.forEach(player => {
                const lastName = player.second_name.toLowerCase();
                const webName = (player.web_name || '').toLowerCase();
                const firstName = player.first_name.toLowerCase();
                
                // Create variations for matching
                const nameVariations = [
                    lastName,
                    webName,
                    firstName,
                    `${firstName.charAt(0)}.${lastName}`, // e.g., "A.Ramsey"
                    `${firstName} ${lastName}`,
                    lastName.replace(/[^a-z]/g, ''), // Remove special chars
                ];
                
                // Special cases for commonly abbreviated names and your team
                if (lastName === 'alexander-arnold') {
                    nameVariations.push('taa', 't.a.a', 'alexander arnold', 'trent');
                }
                if (lastName === 'wan-bissaka') {
                    nameVariations.push('awb', 'a.w.b', 'wan bissaka', 'bissaka');
                }
                if (webName === 'joão pedro' || lastName === 'pedro') {
                    nameVariations.push('joao pedro', 'jodo pedro', 'j.pedro', 'pedro', 'joão');
                }
                if (lastName === 'guehi') {
                    nameVariations.push('guhei', 'gueh', 'guehi'); // Common OCR mistake
                }
                if (lastName === 'muñoz' || lastName === 'munoz') {
                    nameVariations.push('munoz', 'muñoz', 'munos');
                }
                if (lastName === 'moreno') {
                    nameVariations.push('alex moreno', 'a.moreno', 'moreno');
                }
                if (webName === 'salah' || lastName === 'salah') {
                    nameVariations.push('mo salah', 'm.salah', 'mohamed salah', 'm salah', 'salah');
                }
                if (lastName === 'ramsey') {
                    nameVariations.push('arron ramsey', 'aaron ramsey', 'a.ramsey', 'a ramsey');
                }
                if (lastName === 'wood') {
                    nameVariations.push('c.wood', 'chris wood', 'wood');
                }
                
                // Check each variation
                for (const variation of nameVariations) {
                    if (variation && variation.length >= 3 && textLower.includes(variation)) {
                        if (!matchedPlayerIds.has(player.id)) {
                            matchedPlayerIds.add(player.id);
                            detectedPlayers.push(player);
                            directMatches.push(variation);
                            console.log(`Direct match found: ${player.first_name} ${player.second_name} (matched: "${variation}")`);
                            break; // Stop checking variations once we find a match
                        }
                    }
                }
            });
            
            console.log(`Direct search found ${directMatches.length} players:`, directMatches);
            
            // If we found enough players directly, we can skip the complex processing
            if (detectedPlayers.length >= 11) {
                console.log('Found full team through direct search!');
                return detectedPlayers.slice(0, 15); // Return max 15 players
            }
            
            // Create a comprehensive player name index for better matching
            const playerIndex = {};
            allPlayers.forEach(player => {
                const lastName = player.second_name.toLowerCase();
                const firstName = player.first_name.toLowerCase();
                const webName = (player.web_name || '').toLowerCase();
                const fullName = `${firstName} ${lastName}`;
                
                // Index by various name formats
                playerIndex[lastName] = player;
                playerIndex[firstName] = player;
                playerIndex[webName] = player;
                playerIndex[fullName] = player;
                
                // Also index by last name only (most common in FPL)
                if (lastName.length > 3) {
                    playerIndex[lastName.substring(0, 4)] = player;
                }
            });
            
            // Match potential names with actual players
            uniqueNames.forEach(name => {
                if (!name || name.length < 2) return;
                
                // Apply OCR corrections to the name
                let correctedName = applyOCRCorrections(name);
                
                // Additional character corrections - only if it looks like OCR errors
                if (correctedName.match(/[0-9!@#$%^&*()\[\]{}|]/)) {
                    correctedName = correctedName
                        .replace(/0([a-z])/gi, 'O$1')  // 0 before letter -> O
                        .replace(/([a-z])0/gi, '$1o')  // 0 after letter -> o
                        .replace(/1([a-z])/gi, 'l$1')  // 1 before letter -> l
                        .replace(/([a-z])1/gi, '$1i')  // 1 after letter -> i
                        .replace(/5([a-z])/gi, 'S$1')  // 5 before letter -> S
                        .replace(/([a-z])5/gi, '$1s')  // 5 after letter -> s
                        .replace(/[!|]/g, 'i')  // ! or | -> i
                        .replace(/[@]/g, 'a')  // @ -> a
                        .replace(/[\[\]\{\}\(\)]/g, '')  // Remove brackets
                        .replace(/[_]/g, ' ')  // Underscore to space
                        .trim();
                }
                
                const nameLower = correctedName.toLowerCase().trim();
                const nameNoSpaces = nameLower.replace(/[^a-z]/g, '');
                let matched = false;
                
                // Handle abbreviated names like "A.Ramsey" or "M.Salah"
                if (nameLower.match(/^[a-z]\..*/) || nameLower.includes('.')) {
                    const parts = nameLower.split('.');
                    if (parts.length === 2) {
                        const initial = parts[0].trim();
                        const lastName = parts[1].trim();
                        
                        // Find players with matching initial and last name
                        const matchingPlayers = allPlayers.filter(p => {
                            const firstInitial = p.first_name.charAt(0).toLowerCase();
                            const lastNameLower = p.second_name.toLowerCase();
                            return firstInitial === initial && lastNameLower === lastName;
                        });
                        
                        if (matchingPlayers.length === 1) {
                            const player = matchingPlayers[0];
                            if (!matchedPlayerIds.has(player.id)) {
                                matchedPlayerIds.add(player.id);
                                detectedPlayers.push(player);
                                console.log(`Matched by initial.lastname: ${name} -> ${player.first_name} ${player.second_name}`);
                                matched = true;
                            }
                        } else if (matchingPlayers.length > 1) {
                            // Pick the most popular one
                            const best = matchingPlayers.sort((a, b) => 
                                parseFloat(b.selected_by_percent) - parseFloat(a.selected_by_percent)
                            )[0];
                            if (!matchedPlayerIds.has(best.id)) {
                                matchedPlayerIds.add(best.id);
                                detectedPlayers.push(best);
                                console.log(`Matched by initial.lastname (best): ${name} -> ${best.first_name} ${best.second_name}`);
                                matched = true;
                            }
                        }
                    }
                }
                
                if (matched) return; // Skip other matching if we found via initial.lastname
                
                // 1. Try exact full name match (with and without spaces)
                if (playerLookup.byFullName[nameLower] || playerLookup.byFullName[nameNoSpaces]) {
                    const player = playerLookup.byFullName[nameLower] || playerLookup.byFullName[nameNoSpaces];
                    if (!matchedPlayerIds.has(player.id)) {
                        matchedPlayerIds.add(player.id);
                        detectedPlayers.push(player);
                        console.log(`Matched by full name: ${name} -> ${player.first_name} ${player.second_name}`);
                        matched = true;
                    }
                }
                
                // 2. Try common name variations
                if (!matched && playerLookup.byCommonName[nameLower]) {
                    const player = playerLookup.byCommonName[nameLower];
                    if (!matchedPlayerIds.has(player.id)) {
                        matchedPlayerIds.add(player.id);
                        detectedPlayers.push(player);
                        console.log(`Matched by common name: ${name} -> ${player.first_name} ${player.second_name}`);
                        matched = true;
                    }
                }
                
                // 3. Try web name match (with and without spaces)
                if (!matched && (playerLookup.byWebName[nameLower] || playerLookup.byWebName[nameNoSpaces])) {
                    const player = playerLookup.byWebName[nameLower] || playerLookup.byWebName[nameNoSpaces];
                    if (!matchedPlayerIds.has(player.id)) {
                        matchedPlayerIds.add(player.id);
                        detectedPlayers.push(player);
                        console.log(`Matched by web name: ${name} -> ${player.web_name}`);
                        matched = true;
                    }
                }
                
                // 4. Try single name matching (prioritize last names)
                if (!matched && nameLower.length >= 3) {
                    // Try last name match FIRST (most reliable)
                    if (playerLookup.byLastName[nameLower]) {
                        const candidates = playerLookup.byLastName[nameLower];
                        // If only one player with this last name, match it immediately
                        if (candidates.length === 1) {
                            const player = candidates[0];
                            if (!matchedPlayerIds.has(player.id)) {
                                matchedPlayerIds.add(player.id);
                                detectedPlayers.push(player);
                                console.log(`Matched by unique last name: ${name} -> ${player.first_name} ${player.second_name}`);
                                matched = true;
                            }
                        } else if (candidates.length > 1) {
                            // Multiple players with same last name, pick the one with highest ownership
                            const best = candidates.sort((a, b) => {
                                // Prioritize by ownership percentage (more likely to be in someone's team)
                                const ownershipDiff = parseFloat(b.selected_by_percent) - parseFloat(a.selected_by_percent);
                                if (Math.abs(ownershipDiff) > 2) return ownershipDiff;
                                // Then by total points
                                return b.total_points - a.total_points;
                            })[0];
                            // Very low threshold - accept any player that matches last name
                            // Since we're matching from OCR text, we should trust the match
                            if (!matchedPlayerIds.has(best.id)) {
                                matchedPlayerIds.add(best.id);
                                detectedPlayers.push(best);
                                console.log(`Matched by last name (best): ${name} -> ${best.first_name} ${best.second_name} (${best.selected_by_percent}% owned)`);
                                matched = true;
                            }
                        }
                    }
                    
                    // Try first name match if not matched yet
                    if (!matched && playerLookup.byFirstName[nameLower]) {
                        const candidates = playerLookup.byFirstName[nameLower];
                        if (candidates.length === 1) {
                            const player = candidates[0];
                            if (!matchedPlayerIds.has(player.id)) {
                                matchedPlayerIds.add(player.id);
                                detectedPlayers.push(player);
                                console.log(`Matched by unique first name: ${name} -> ${player.first_name} ${player.second_name}`);
                                matched = true;
                            }
                        } else if (candidates.length > 1) {
                            // Sort by ownership and points
                            const sorted = candidates.sort((a, b) => {
                                const ownershipDiff = parseFloat(b.selected_by_percent) - parseFloat(a.selected_by_percent);
                                if (Math.abs(ownershipDiff) > 2) return ownershipDiff;
                                return b.total_points - a.total_points;
                            });
                            
                            const best = sorted[0];
                            const secondBest = sorted[1];
                            
                            // Check if there's a clear winner
                            const bestOwnership = parseFloat(best.selected_by_percent);
                            const secondOwnership = parseFloat(secondBest?.selected_by_percent || 0);
                            
                            // Accept if:
                            // 1. Popular player (5%+ ownership)
                            // 2. OR significantly more popular than second choice
                            // 3. OR unique popular first name
                            // 4. OR any reasonable points/ownership
                            const popularFirstNames = ['erling', 'bukayo', 'mohamed', 'mo', 'virgil', 'heung-min', 'ollie', 'cole', 'phil', 'declan', 'bruno', 'kai', 'marcus', 'ivan', 'james', 'jack', 'harry', 'luis', 'pedro', 'david'];
                            
                            if (bestOwnership > 5 || 
                                bestOwnership > secondOwnership * 1.5 || 
                                (popularFirstNames.includes(nameLower) && bestOwnership > 2) ||
                                best.total_points > 20 ||
                                (bestOwnership > 1 && !secondBest)) {
                                if (!matchedPlayerIds.has(best.id)) {
                                    matchedPlayerIds.add(best.id);
                                    detectedPlayers.push(best);
                                    console.log(`Matched by first name: ${name} -> ${best.first_name} ${best.second_name} (${bestOwnership}% owned)`);
                                    matched = true;
                                }
                            }
                        }
                    }
                }
                
                // 5. Try partial/substring matching for any part of the name
                if (!matched && nameLower.length >= 3) {
                    // Check if the input is a substring of any player name
                    const substringMatches = allPlayers.filter(player => {
                        const fullName = `${player.first_name} ${player.second_name}`.toLowerCase();
                        const lastName = player.second_name.toLowerCase();
                        const firstName = player.first_name.toLowerCase();
                        const webName = (player.web_name || '').toLowerCase().replace('.', '');
                        
                        // Check if input matches part of any name
                        return lastName.includes(nameLower) || 
                               firstName.includes(nameLower) || 
                               fullName.includes(nameLower) ||
                               webName.includes(nameLower) ||
                               nameLower.includes(lastName) ||
                               nameLower.includes(firstName);
                    });
                    
                    if (substringMatches.length === 1) {
                        const player = substringMatches[0];
                        if (!matchedPlayerIds.has(player.id)) {
                            matchedPlayerIds.add(player.id);
                            detectedPlayers.push(player);
                            console.log(`Matched by substring: ${name} -> ${player.first_name} ${player.second_name}`);
                            matched = true;
                        }
                    } else if (substringMatches.length > 1 && substringMatches.length <= 5) {
                        // Pick best by ownership
                        const best = substringMatches.sort((a, b) => {
                            const ownershipDiff = parseFloat(b.selected_by_percent) - parseFloat(a.selected_by_percent);
                            if (Math.abs(ownershipDiff) > 1) return ownershipDiff;
                            return b.total_points - a.total_points;
                        })[0];
                        
                        if (parseFloat(best.selected_by_percent) > 1 || best.total_points > 5) {
                            if (!matchedPlayerIds.has(best.id)) {
                                matchedPlayerIds.add(best.id);
                                detectedPlayers.push(best);
                                console.log(`Matched by substring (best): ${name} -> ${best.first_name} ${best.second_name}`);
                                matched = true;
                            }
                        }
                    }
                }
                
                // 6. Try fuzzy matching for close matches (more aggressive)
                if (!matched && nameLower.length >= 3) {
                    const fuzzyMatches = allPlayers.filter(player => {
                        const fullName = `${player.first_name} ${player.second_name}`.toLowerCase();
                        const webName = (player.web_name || '').toLowerCase();
                        const lastName = player.second_name.toLowerCase();
                        
                        // Skip if name is too short for reliable fuzzy matching
                        if (lastName.length < 3) return false;
                        
                        // Check if the corrected name contains the last name (exact substring)
                        if (nameLower.includes(lastName) && lastName.length >= 4) {
                            return true;
                        }
                        
                        // Check Levenshtein distance but be more strict
                        const lastNameDistance = levenshteinDistance(nameLower, lastName);
                        const webNameDistance = levenshteinDistance(nameLower, webName);
                        
                        // Allow reasonable character differences
                        const maxDistance = nameLower.length <= 4 ? 1 : nameLower.length <= 6 ? 2 : 3;
                        
                        if (lastNameDistance <= maxDistance || webNameDistance <= maxDistance) {
                            return true;
                        }
                        
                        return false;
                    });
                    
                    if (fuzzyMatches.length === 1) {
                        // Only one fuzzy match - likely correct
                        const best = fuzzyMatches[0];
                        if (!matchedPlayerIds.has(best.id)) {
                            matchedPlayerIds.add(best.id);
                            detectedPlayers.push(best);
                            console.log(`Fuzzy matched (single): ${name} -> ${best.first_name} ${best.second_name}`);
                        }
                    } else if (fuzzyMatches.length > 1 && fuzzyMatches.length <= 3) {
                        // Multiple fuzzy matches - pick based on ownership (more likely to be in a team)
                        fuzzyMatches.sort((a, b) => {
                            // Heavy weight on ownership for disambiguation
                            return (parseFloat(b.selected_by_percent) * 100 + b.total_points) - 
                                   (parseFloat(a.selected_by_percent) * 100 + a.total_points);
                        });
                        
                        const best = fuzzyMatches[0];
                        const secondBest = fuzzyMatches[1];
                        
                        // Only accept if there's a clear winner (significantly higher ownership)
                        if (parseFloat(best.selected_by_percent) > parseFloat(secondBest.selected_by_percent) * 2) {
                            if (!matchedPlayerIds.has(best.id)) {
                                matchedPlayerIds.add(best.id);
                                detectedPlayers.push(best);
                                console.log(`Fuzzy matched (best of ${fuzzyMatches.length}): ${name} -> ${best.first_name} ${best.second_name}`);
                            }
                        } else {
                            console.log(`Skipping ambiguous fuzzy match for: ${name} (${fuzzyMatches.length} candidates)`);
                        }
                    } else if (fuzzyMatches.length > 3) {
                        // Too many matches - likely unreliable
                        console.log(`Too many fuzzy matches for: ${name} (${fuzzyMatches.length} candidates) - skipping`);
                    }
                }
            });
            
            // Sort detected players by position and points
            detectedPlayers.sort((a, b) => {
                if (a.element_type !== b.element_type) {
                    return a.element_type - b.element_type;
                }
                return b.total_points - a.total_points;
            });
            
            // 7. ULTIMATE FALLBACK - If we still have no matches, try the most popular players
            if (detectedPlayers.length === 0 && uniqueNames.length > 0) {
                console.log('No matches found, trying ultimate fallback...');
                
                // Get most popular players
                const popularPlayers = allPlayers
                    .filter(p => parseFloat(p.selected_by_percent) > 10)
                    .sort((a, b) => parseFloat(b.selected_by_percent) - parseFloat(a.selected_by_percent));
                
                // Try to match any word with any part of popular player names
                for (const name of uniqueNames) {
                    if (name.length < 3) continue;
                    const nameLower = name.toLowerCase();
                    
                    for (const player of popularPlayers) {
                        const lastName = player.second_name.toLowerCase();
                        const firstName = player.first_name.toLowerCase();
                        const webName = (player.web_name || '').toLowerCase().replace('.', '');
                        
                        // Very loose matching - any 3+ character match
                        if ((nameLower.length >= 3 && lastName.includes(nameLower.substring(0, 3))) ||
                            (nameLower.length >= 3 && firstName.includes(nameLower.substring(0, 3))) ||
                            (nameLower.length >= 3 && webName.includes(nameLower.substring(0, 3))) ||
                            (lastName.length >= 3 && nameLower.includes(lastName.substring(0, 3)))) {
                            
                            if (!matchedPlayerIds.has(player.id)) {
                                matchedPlayerIds.add(player.id);
                                detectedPlayers.push(player);
                                console.log(`Ultimate fallback match: ${name} -> ${player.first_name} ${player.second_name}`);
                                break;
                            }
                        }
                    }
                    
                    // Stop after finding 15 players
                    if (detectedPlayers.length >= 15) break;
                }
            }
            
            console.log(`Final detected players (${detectedPlayers.length}):`, 
                detectedPlayers.map(p => `${p.first_name} ${p.second_name} (${p.element_type})`));
            
            return detectedPlayers;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        function extractPotentialPlayerNames(text, words, lines) {
            const names = [];
            
            // Extract from lines (most structured)
            if (lines && lines.length > 0) {
                lines.forEach(line => {
                    const lineText = (line.text || '').trim();
                    // Skip obvious non-player text
                    if (lineText.length > 2 && lineText.length < 30 && 
                        !lineText.toLowerCase().includes('gameweek') &&
                        !lineText.toLowerCase().includes('deadline') &&
                        !lineText.toLowerCase().includes('fantasy') &&
                        !lineText.toLowerCase().includes('pitch') &&
                        !lineText.toLowerCase().includes('bench') &&
                        !lineText.toLowerCase().includes('captain') &&
                        /[a-zA-Z]/.test(lineText)) {
                        
                        // Split by common separators and add each part
                        const parts = lineText.split(/[\s,\/]+/);
                        parts.forEach(part => {
                            const cleaned = part.trim();
                            if (cleaned.length > 2 && /^[A-Za-z]/.test(cleaned)) {
                                names.push(cleaned);
                            }
                        });
                    }
                });
            }
            
            // Remove duplicates and return
            return [...new Set(names)];
        }
        
        function showSmartPlayerPicker(ocrNames, detectedPlayers) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                backdrop-filter: blur(5px);
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 20px;
                padding: 30px;
                max-width: 900px;
                width: 90%;
                max-height: 85vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                color: white;
            `;
            
            modalContent.innerHTML = `
                <h2 style="margin-bottom: 20px; font-size: 24px;">🎯 Confirm Your Team</h2>
                <p style="margin-bottom: 20px; opacity: 0.9;">We found these names in your screenshot. Search and select the correct players:</p>
                
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 20px;">
                    <div>
                        <h3 style="font-size: 18px; margin-bottom: 10px;">📋 Detected Text</h3>
                        <div id="ocrNamesList" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto;">
                            ${ocrNames.length > 0 ? ocrNames.map(name => `<div style="padding: 5px;">${name}</div>`).join('') : '<div>No names detected</div>'}
                        </div>
                    </div>
                    
                    <div>
                        <h3 style="font-size: 18px; margin-bottom: 10px;">✅ Selected Players (<span id="selectedCount">0</span>/15)</h3>
                        <div id="selectedPlayersList" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto;">
                            <div style="opacity: 0.7;">No players selected yet</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 18px; margin-bottom: 10px;">🔍 Search and Add Players</h3>
                    <div style="position: relative;">
                        <input type="text" id="playerSearchInput" placeholder="Type player name (e.g., Salah, Haaland, Palmer)" 
                            style="width: 100%; padding: 12px; border-radius: 8px; border: none; background: white; color: #333; font-size: 16px;">
                        <div id="searchSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border-radius: 8px; margin-top: 5px; max-height: 300px; overflow-y: auto; display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.2); z-index: 1000;"></div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 18px; margin-bottom: 10px;">⚡ Quick Add Popular Players</h3>
                    <div id="popularPlayers" style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <!-- Will be populated with popular player buttons -->
                    </div>
                </div>
                
                <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                    <button onclick="clearSelectedPlayers()" style="padding: 12px 24px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 16px;">
                        🗑️ Clear All
                    </button>
                    <div>
                        <button onclick="this.closest('.advanced-modal').remove()" style="padding: 12px 24px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer; font-size: 16px; margin-right: 10px;">
                            Cancel
                        </button>
                        <button onclick="confirmSelectedPlayers()" style="padding: 12px 24px; background: white; color: #667eea; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">
                            ✅ Add to Squad
                        </button>
                    </div>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Initialize the smart picker
            initializeSmartPicker(ocrNames, detectedPlayers);
        }
        
        let selectedPlayersForPicker = [];
        
        function initializeSmartPicker(ocrNames, detectedPlayers) {
            // Sort detected players by confidence if available
            const sortedPlayers = [...detectedPlayers].sort((a, b) => {
                const confA = a.matchConfidence || 0.5;
                const confB = b.matchConfidence || 0.5;
                return confB - confA;
            });
            
            selectedPlayersForPicker = sortedPlayers;
            updateSelectedPlayersList();
            
            // Add popular players buttons
            const popularPlayersDiv = document.getElementById('popularPlayers');
            const popularPlayers = window.transferSimPro.allPlayers
                .filter(p => parseFloat(p.selected_by_percent) > 20)
                .sort((a, b) => parseFloat(b.selected_by_percent) - parseFloat(a.selected_by_percent))
                .slice(0, 15);
            
            popularPlayers.forEach(player => {
                const btn = document.createElement('button');
                btn.textContent = `${player.web_name || player.second_name} (${player.selected_by_percent}%)`;
                btn.style.cssText = 'padding: 8px 12px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer; font-size: 14px;';
                btn.onclick = () => addPlayerToPicker(player);
                popularPlayersDiv.appendChild(btn);
            });
            
            // Setup search functionality
            const searchInput = document.getElementById('playerSearchInput');
            const suggestionsDiv = document.getElementById('searchSuggestions');
            
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase().trim();
                if (query.length < 2) {
                    suggestionsDiv.style.display = 'none';
                    return;
                }
                
                // Search players
                const matches = window.transferSimPro.allPlayers
                    .filter(p => {
                        const fullName = `${p.first_name} ${p.second_name}`.toLowerCase();
                        const webName = (p.web_name || '').toLowerCase();
                        return fullName.includes(query) || 
                               webName.includes(query) || 
                               p.second_name.toLowerCase().includes(query) ||
                               p.first_name.toLowerCase().includes(query);
                    })
                    .slice(0, 10);
                
                if (matches.length > 0) {
                    suggestionsDiv.innerHTML = matches.map(player => `
                        <div onclick="addPlayerToPicker(${player.id})" style="padding: 10px; cursor: pointer; border-bottom: 1px solid #eee; color: #333; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${player.first_name} ${player.second_name}</strong>
                                <span style="color: #666; font-size: 12px; margin-left: 10px;">${['GKP', 'DEF', 'MID', 'FWD'][player.element_type - 1]}</span>
                            </div>
                            <div style="text-align: right;">
                                <span style="color: #667eea; font-weight: 600;">£${(player.now_cost / 10).toFixed(1)}m</span>
                                <span style="color: #999; font-size: 12px; margin-left: 10px;">${player.selected_by_percent}%</span>
                            </div>
                        </div>
                    `).join('');
                    suggestionsDiv.style.display = 'block';
                } else {
                    suggestionsDiv.innerHTML = '<div style="padding: 10px; color: #999;">No players found</div>';
                    suggestionsDiv.style.display = 'block';
                }
            });
            
            // Click outside to close suggestions
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !suggestionsDiv.contains(e.target)) {
                    suggestionsDiv.style.display = 'none';
                }
            });
            
            // Try to auto-match OCR names to players
            ocrNames.forEach(name => {
                const player = findBestPlayerMatch(name);
                if (player && !selectedPlayersForPicker.find(p => p.id === player.id)) {
                    selectedPlayersForPicker.push(player);
                }
            });
            
            updateSelectedPlayersList();
        }
        
        function findBestPlayerMatch(name) {
            const nameLower = name.toLowerCase().trim();
            const players = window.transferSimPro.allPlayers;
            
            // Try exact last name match
            let match = players.find(p => p.second_name.toLowerCase() === nameLower);
            if (match) return match;
            
            // Try web name match
            match = players.find(p => (p.web_name || '').toLowerCase() === nameLower);
            if (match) return match;
            
            // Try partial match
            match = players.find(p => p.second_name.toLowerCase().includes(nameLower) || nameLower.includes(p.second_name.toLowerCase()));
            if (match) return match;
            
            return null;
        }
        
        function addPlayerToPicker(playerOrId) {
            const player = typeof playerOrId === 'number' 
                ? window.transferSimPro.allPlayers.find(p => p.id === playerOrId)
                : playerOrId;
            
            if (!player) return;
            
            // Check if already selected
            if (selectedPlayersForPicker.find(p => p.id === player.id)) {
                alert('Player already selected!');
                return;
            }
            
            // Check max players
            if (selectedPlayersForPicker.length >= 15) {
                alert('Maximum 15 players allowed!');
                return;
            }
            
            selectedPlayersForPicker.push(player);
            updateSelectedPlayersList();
            
            // Clear search
            document.getElementById('playerSearchInput').value = '';
            document.getElementById('searchSuggestions').style.display = 'none';
        }
        
        function updateSelectedPlayersList() {
            const listDiv = document.getElementById('selectedPlayersList');
            const countSpan = document.getElementById('selectedCount');
            
            if (selectedPlayersForPicker.length === 0) {
                listDiv.innerHTML = '<div style="opacity: 0.7;">No players selected yet</div>';
            } else {
                // Group by position
                const byPosition = {1: [], 2: [], 3: [], 4: []};
                selectedPlayersForPicker.forEach(p => {
                    byPosition[p.element_type].push(p);
                });
                
                let html = '';
                const posNames = ['GKP', 'DEF', 'MID', 'FWD'];
                [1, 2, 3, 4].forEach(pos => {
                    if (byPosition[pos].length > 0) {
                        html += `<div style="margin-bottom: 10px;"><strong>${posNames[pos - 1]}:</strong> `;
                        html += byPosition[pos].map(p => {
                            const confidence = p.matchConfidence ? ` (${(p.matchConfidence * 100).toFixed(0)}%)` : '';
                            const bgColor = p.matchConfidence ? 
                                `rgba(255,255,255,${Math.max(0.1, p.matchConfidence * 0.3)})` : 
                                'rgba(255,255,255,0.2)';
                            return `<span style="display: inline-block; margin: 2px; padding: 3px 8px; background: ${bgColor}; border-radius: 4px; font-size: 14px;" title="${p.matchReason || 'Manual selection'}">
                                ${p.web_name || p.second_name}${confidence}
                                <span onclick="removePlayerFromPicker(${p.id})" style="margin-left: 5px; cursor: pointer;">❌</span>
                            </span>`;
                        }).join('');
                        html += '</div>';
                    }
                });
                listDiv.innerHTML = html;
            }
            
            countSpan.textContent = selectedPlayersForPicker.length;
        }
        
        function removePlayerFromPicker(playerId) {
            selectedPlayersForPicker = selectedPlayersForPicker.filter(p => p.id !== playerId);
            updateSelectedPlayersList();
        }
        
        function clearSelectedPlayers() {
            selectedPlayersForPicker = [];
            updateSelectedPlayersList();
        }
        
        function confirmSelectedPlayers() {
            if (selectedPlayersForPicker.length === 0) {
                alert('Please select at least one player!');
                return;
            }
            
            // Add players to squad
            populateSquadFromImage(selectedPlayersForPicker);
            
            // Close modal
            document.querySelector('.advanced-modal').remove();
            
            // Show success message
            if (window.transferSimPro && window.transferSimPro.showNotification) {
                window.transferSimPro.showNotification(`✅ Added ${selectedPlayersForPicker.length} players to your squad!`, 'success');
            }
        }
        
        // Make functions globally available
        window.addPlayerToPicker = addPlayerToPicker;
        window.removePlayerFromPicker = removePlayerFromPicker;
        window.clearSelectedPlayers = clearSelectedPlayers;
        window.confirmSelectedPlayers = confirmSelectedPlayers;
        
        // Process team image upload with OCR
        async function processTeamImage(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const statusDiv = document.getElementById('imageProcessingStatus');
            if (statusDiv) {
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; margin: 0 auto;"></div><p style="color: white; margin-top: 10px;">Processing screenshot...</p>';
            }
            
            // Create image element to display
            const img = new Image();
            const reader = new FileReader();
            
            reader.onload = async function(e) {
                img.src = e.target.result;
                
                // Wait for image to load
                await new Promise(resolve => {
                    img.onload = resolve;
                });
                
                try {
                    // Initialize Tesseract worker - simple setup
                    const worker = await Tesseract.createWorker('eng');
                    
                    try {
                        // Perform OCR with minimal configuration
                        const { data } = await worker.recognize(img.src);
                        console.log('OCR Result:', data.text);
                        
                        // Update status
                        if (statusDiv) {
                            statusDiv.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; margin: 0 auto;"></div><p style="color: white; margin-top: 10px;">Matching players...</p>';
                        }
                        
                        // Use simple OCR processor
                        let detectedPlayers;
                        if (typeof simpleProcessOCR === 'function') {
                            console.log('Using simple OCR processing...');
                            detectedPlayers = simpleProcessOCR(data.text, data.words, data.lines);
                        } else {
                            // Fallback to original processing
                            console.log('Using standard OCR processing...');
                            detectedPlayers = processOCRText(data.text, data.words, data.lines);
                        }
                        
                        // Extract potential names for display
                        const detectedNames = extractPotentialPlayerNames(data.text, data.words, data.lines);
                        
                        // Show the smart player picker dialog
                        showSmartPlayerPicker(detectedNames, detectedPlayers);
                        
                    } finally {
                        await worker.terminate();
                    }
                } catch (error) {
                    console.error('OCR Error:', error);
                    alert('Failed to process image. Please try again or enter players manually.');
                } finally {
                    if (statusDiv) {
                        statusDiv.style.display = 'none';
                    }
                    // Reset file input
                    event.target.value = '';
                }
            };
            
            reader.readAsDataURL(file);
        }
        
        // Make it globally available
        window.processTeamImage = processTeamImage;
        
        function showManualPlayerEntry() {
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content" style="max-width: 600px;">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>✏️ Enter Player Names</h2>
                    <p style="margin-bottom: 20px;">Enter player names (one per line). You can use last names only for unique players.</p>
                    
                    <textarea id="manualPlayerNames" style="width: 100%; height: 300px; padding: 10px; font-size: 14px; border: 2px solid #667eea; border-radius: 5px;" placeholder="Example:
Salah
Haaland
Alexander-Arnold
Saka
Palmer
Martinez
Gabriel
Watkins
Rice
Solanke
Gordon
Raya
Colwill
Lewis
Mbeumo"></textarea>
                    
                    <div style="margin-top: 20px; display: flex; gap: 10px;">
                        <button onclick="processManualPlayers()" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            ✅ Add Players to Squad
                        </button>
                        <button onclick="this.closest('.advanced-modal').remove()" style="flex: 1; padding: 10px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            Cancel
                        </button>
                    </div>
                    
                    <div id="manualEntryStatus" style="margin-top: 15px; display: none;">
                        <p style="color: #667eea; font-weight: 600;">Processing...</p>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus on textarea
            setTimeout(() => {
                document.getElementById('manualPlayerNames')?.focus();
            }, 100);
        }

        function processManualPlayers() {
            const textarea = document.getElementById('manualPlayerNames');
            const statusDiv = document.getElementById('manualEntryStatus');
            
            if (!textarea || !window.transferSimPro) return;
            
            const playerNames = textarea.value
                .split('\n')
                .map(name => name.trim())
                .filter(name => name.length > 0);
            
            if (playerNames.length === 0) {
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = '<p style="color: #dc3545;">Please enter at least one player name.</p>';
                return;
            }
            
            statusDiv.style.display = 'block';
            statusDiv.innerHTML = '<p style="color: #667eea;">Matching players...</p>';
            
            // Use the same OCR text processing function but with manual names
            const manualText = playerNames.join('\n');
            const detectedPlayers = processOCRText(manualText, null, null);
            
            if (detectedPlayers.length > 0) {
                populateSquadFromImage(detectedPlayers);
                statusDiv.innerHTML = `<p style="color: #28a745;">✅ Added ${detectedPlayers.length} players to squad!</p>`;
                
                // Close modal after 2 seconds
                setTimeout(() => {
                    document.querySelector('.advanced-modal')?.remove();
                }, 2000);
            } else {
                statusDiv.innerHTML = '<p style="color: #dc3545;">❌ No matching players found. Try using exact player names.</p>';
            }
        }

        function populateSquadFromImage(detectedPlayers) {
            if (!window.transferSimPro) {
                console.error('Transfer simulator not initialized');
                return;
            }
            
            console.log(`Starting to populate squad with ${detectedPlayers.length} detected players`);
            
            // Reset current squad first
            window.transferSimPro.resetTeam();
            
            // Sort players by position and points
            const playersByPosition = {
                1: [], // GKP
                2: [], // DEF
                3: [], // MID
                4: []  // FWD
            };
            
            detectedPlayers.forEach(player => {
                if (playersByPosition[player.element_type]) {
                    playersByPosition[player.element_type].push(player);
                }
            });
            
            // Sort each position by total points
            Object.keys(playersByPosition).forEach(pos => {
                playersByPosition[pos].sort((a, b) => b.total_points - a.total_points);
            });
            
            // Add players to squad respecting formation limits
            const limits = { 1: 2, 2: 5, 3: 5, 4: 3 };
            let totalAdded = 0;
            let successfullyAdded = [];
            
            Object.keys(playersByPosition).forEach(pos => {
                const posNum = parseInt(pos);
                const players = playersByPosition[pos];
                const limit = limits[posNum];
                
                console.log(`Adding ${players.length} players for position ${posNum} (limit: ${limit})`);
                
                for (let i = 0; i < Math.min(players.length, limit); i++) {
                    if (totalAdded < 15) { // Max squad size
                        const added = window.transferSimPro.addPlayerFromImage(players[i]);
                        if (added) {
                            totalAdded++;
                            successfullyAdded.push(players[i]);
                        }
                    }
                }
            });
            
            // Final update to ensure everything is displayed
            if (totalAdded > 0) {
                // Force a complete refresh of displays
                window.transferSimPro.updateSquadDisplay();
                window.transferSimPro.updateDisplay();
                window.transferSimPro.updateCharts();
                
                // Show detailed notification
                const playerNames = successfullyAdded.slice(0, 5).map(p => p.second_name).join(', ');
                const moreText = successfullyAdded.length > 5 ? ` and ${successfullyAdded.length - 5} more` : '';
                
                window.transferSimPro.showNotification(
                    `📸 Added ${totalAdded} players: ${playerNames}${moreText}`,
                    'success'
                );
                
                console.log(`Successfully added ${totalAdded} players to squad`);
            } else {
                window.transferSimPro.showNotification(
                    '❌ Could not add any players to squad',
                    'error'
                );
                console.log('Failed to add any players to squad');
            }
        }

        function optimizeTeam() {
            if (window.transferSimPro) {
                window.transferSimPro.optimizeTeam();
            }
        }

        function resetTeam() {
            if (window.transferSimPro) {
                window.transferSimPro.resetTeam();
            }
        }
        
        function saveCurrentTeam() {
            if (window.transferSimPro) {
                window.transferSimPro.saveTeam();
            }
        }
        
        function showSavedTeams() {
            if (!window.transferSimPro) return;
            
            const savedTeams = window.transferSimPro.getSavedTeams();
            
            if (savedTeams.length === 0) {
                alert('No saved teams found. Save your current team first!');
                return;
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                animation: slideUp 0.3s ease;
            `;
            
            modalContent.innerHTML = `
                <h2 style="margin-bottom: 20px; color: #333;">📂 Saved Teams</h2>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    ${savedTeams.map(team => `
                        <div style="border: 2px solid #e0e0e0; border-radius: 10px; padding: 15px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; color: #333;">${team.name}</h3>
                                    <p style="margin: 5px 0; color: #666; font-size: 0.9rem;">
                                        Formation: ${team.formation || 'N/A'} | 
                                        Players: ${team.playerCount || 0} | 
                                        Value: £${team.totalValue ? team.totalValue.toFixed(1) : '0.0'}m
                                    </p>
                                    <p style="margin: 5px 0; color: #666; font-size: 0.85rem;">
                                        Expected Points: ${team.expectedPoints ? Math.round(team.expectedPoints) : 'N/A'}
                                    </p>
                                    <p style="margin: 5px 0; color: #999; font-size: 0.8rem;">
                                        Saved: ${new Date(team.date).toLocaleDateString()}
                                    </p>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button onclick="loadSavedTeam('${team.name}')" style="padding: 8px 16px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                                        Load
                                    </button>
                                    <button onclick="deleteSavedTeam('${team.name}')" style="padding: 8px 16px; background: linear-gradient(135deg, #dc3545, #c82333); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <button onclick="closeSavedTeamsModal()" style="margin-top: 20px; width: 100%; padding: 12px; background: #333; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                    Close
                </button>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Store modal reference for closing
            window.savedTeamsModal = modal;
        }
        
        function closeSavedTeamsModal() {
            if (window.savedTeamsModal) {
                window.savedTeamsModal.remove();
                window.savedTeamsModal = null;
            }
        }
        
        function loadSavedTeam(teamName) {
            if (window.transferSimPro) {
                const savedTeams = window.transferSimPro.getSavedTeams();
                const team = savedTeams.find(t => t.name === teamName);
                if (team) {
                    window.transferSimPro.loadTeam(team);
                    closeSavedTeamsModal();
                }
            }
        }
        
        function deleteSavedTeam(teamName) {
            if (confirm(`Are you sure you want to delete team "${teamName}"?`)) {
                if (window.transferSimPro) {
                    window.transferSimPro.deleteSavedTeam(teamName);
                    closeSavedTeamsModal();
                    showSavedTeams(); // Refresh the modal
                }
            }
        }

        function runScenario(type) {
            if (window.transferSimPro) {
                window.transferSimPro.runScenario(type);
            }
        }

        function showFixtures(filter) {
            if (window.transferSimPro) {
                window.transferSimPro.displayFixtures(filter);
            }
        }

        function updateComparisonPlayers() {
            if (window.transferSimPro) {
                window.transferSimPro.updateComparisonPlayers();
            }
        }

        function updateComparison() {
            if (window.transferSimPro) {
                window.transferSimPro.updateComparison();
            }
        }

        function showPriceChanges(type) {
            if (window.transferSimPro) {
                window.transferSimPro.displayPriceChanges(type);
            }
        }

        // Removed duplicate - already defined above
        
        function searchAllPlayers() {
            if (window.transferSimPro) {
                // Clear position filter to search all players
                document.getElementById('positionFilter').value = '';
                // Trigger search
                window.transferSimPro.displayPlayers(1);
            }
        }
        
        function filterPlayers() {
            if (window.transferSimPro) {
                window.transferSimPro.displayPlayers(1);
            }
        }
        
        function showPositionPlayers(position) {
            if (window.transferSimPro) {
                // Set the position filter
                document.getElementById('positionFilter').value = position;
                // Display players for that position
                window.transferSimPro.displayPlayers(1);
            }
        }
        
        // Make functions globally available
        window.filterPlayers = filterPlayers;
        window.showPositionPlayers = showPositionPlayers;
        window.processTeamImage = processTeamImage;

        // Add animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // 🚀 ADVANCED FEATURES UI FUNCTIONS
        
        function showChemistryAnalysis() {
            if (!window.transferSimPro) return;
            
            const chemistry = window.transferSimPro.chemistryCalculator.calculateTeamChemistry();
            const bonuses = window.transferSimPro.chemistryCalculator.getSynergyBonuses();
            
            // Hide other widgets
            document.querySelectorAll('#quickAnalytics > div').forEach(el => el.style.display = 'none');
            
            // Show chemistry display
            const display = document.getElementById('chemistryDisplay');
            display.style.display = 'block';
            
            // Update chemistry score with animation
            const scoreEl = document.getElementById('chemistryScore');
            let currentScore = 0;
            const targetScore = chemistry;
            const increment = targetScore / 30;
            
            const animateScore = () => {
                currentScore += increment;
                if (currentScore >= targetScore) {
                    scoreEl.textContent = Math.round(targetScore);
                    return;
                }
                scoreEl.textContent = Math.round(currentScore);
                requestAnimationFrame(animateScore);
            };
            animateScore();
            
            // Update synergy bonuses
            const bonusesEl = document.getElementById('synergyBonuses');
            bonusesEl.innerHTML = bonuses.map(bonus => 
                `<div class="synergy-badge">${bonus.type}: ${bonus.team} ${bonus.bonus}</div>`
            ).join('') || '<div class="synergy-badge">No active synergies</div>';
        }

        function showMarketSentiment() {
            if (!window.transferSimPro) return;
            
            const trending = window.transferSimPro.marketSentiment.getTrendingPlayers();
            
            // Hide other widgets
            document.querySelectorAll('#quickAnalytics > div').forEach(el => el.style.display = 'none');
            
            // Show sentiment widget
            const widget = document.getElementById('sentimentWidget');
            widget.style.display = 'block';
            
            // Update trending players
            const trendingEl = document.getElementById('trendingPlayers');
            trendingEl.innerHTML = trending.map(player => `
                <div class="trending-player">
                    <div>
                        <strong>${player.name}</strong>
                        <div style="font-size: 0.8rem; color: #666;">${player.reason}</div>
                    </div>
                    <div>
                        <span class="sentiment-badge ${player.sentiment.toLowerCase().replace(' ', '-')}">${player.sentiment}</span>
                        <div class="trending-change">${player.change}</div>
                    </div>
                </div>
            `).join('');
        }

        function showWildcardPlanner() {
            if (!window.transferSimPro) return;
            
            const optimalTiming = window.transferSimPro.wildcardPlanner.calculateOptimalTiming();
            
            // Hide other widgets
            document.querySelectorAll('#quickAnalytics > div').forEach(el => el.style.display = 'none');
            
            // Show wildcard widget
            const widget = document.getElementById('wildcardWidget');
            widget.style.display = 'block';
            
            // Update optimal gameweek
            if (optimalTiming) {
                document.getElementById('optimalGW').textContent = `GW ${optimalTiming.gameweek}`;
            }
        }

        function showInjuryRisk() {
            if (!window.transferSimPro) return;
            
            const squad = window.transferSimPro.currentSquad;
            let totalRisk = 0;
            let playerCount = 0;
            let highRiskPlayers = [];
            
            Object.values(squad).forEach(position => {
                position.forEach(player => {
                    if (player) {
                        const risk = window.transferSimPro.injuryRiskAssessment.assessRisk(player);
                        totalRisk += risk.percentage;
                        playerCount++;
                        
                        if (risk.percentage > 60) {
                            highRiskPlayers.push({
                                name: `${player.first_name} ${player.second_name}`,
                                risk: risk.percentage,
                                level: risk.level
                            });
                        }
                    }
                });
            });
            
            const avgRisk = playerCount > 0 ? Math.round(totalRisk / playerCount) : 0;
            
            // Show modal with injury risk analysis
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>🏥 Squad Injury Risk Analysis</h2>
                    
                    <div class="advanced-grid">
                        <div class="analysis-card">
                            <h3>Average Squad Risk</h3>
                            <div class="risk-percentage ${avgRisk < 30 ? 'low' : avgRisk < 60 ? 'medium' : 'high'}">${avgRisk}%</div>
                            <p>Based on age, minutes, and position factors</p>
                        </div>
                        
                        <div class="analysis-card">
                            <h3>High Risk Players</h3>
                            <div style="text-align: left;">
                                ${highRiskPlayers.length > 0 ? 
                                    highRiskPlayers.map(p => `<div>${p.name}: ${p.risk}% (${p.level})</div>`).join('') :
                                    '<div>No high-risk players detected</div>'
                                }
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showHistoricalTrends() {
            if (!window.transferSimPro) return;
            
            // Show modal with historical analysis
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>📈 Historical Performance Trends</h2>
                    
                    <div class="advanced-grid">
                        <div class="analysis-card full-width">
                            <h3>Trend Analysis Coming Soon</h3>
                            <p>Multi-season analysis, consistency ratings, and peak performance identification will be available in the next update.</p>
                            <div style="margin: 20px 0;">
                                <div class="trend-indicator" style="color: #28a745;">Rising Stars Detection</div>
                                <div class="trend-indicator" style="color: #ffc107;">Consistency Tracking</div>
                                <div class="trend-indicator" style="color: #17a2b8;">Peak Season Identification</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showAdvancedOptimizer() {
            if (!window.transferSimPro) return;
            
            // Show strategy selection modal
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>🤖 AI Optimizer Pro</h2>
                    
                    <div class="advanced-grid">
                        <div class="analysis-card" onclick="runAdvancedOptimization('aggressive'); this.closest('.advanced-modal').remove();">
                            <h3 style="color: #dc3545;">⚡ Aggressive Strategy</h3>
                            <p>High-risk, high-reward picks focusing on explosive potential</p>
                            <div style="margin: 10px 0; color: #dc3545; font-weight: 600;">Risk Level: High</div>
                        </div>
                        
                        <div class="analysis-card" onclick="runAdvancedOptimization('balanced'); this.closest('.advanced-modal').remove();">
                            <h3 style="color: #28a745;">⚖️ Balanced Strategy</h3>
                            <p>Mix of premium and value players with optimal risk distribution</p>
                            <div style="margin: 10px 0; color: #28a745; font-weight: 600;">Risk Level: Medium</div>
                        </div>
                        
                        <div class="analysis-card" onclick="runAdvancedOptimization('defensive'); this.closest('.advanced-modal').remove();">
                            <h3 style="color: #17a2b8;">🛡️ Defensive Strategy</h3>
                            <p>Safe picks with low injury risk and consistent returns</p>
                            <div style="margin: 10px 0; color: #17a2b8; font-weight: 600;">Risk Level: Low</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function runAdvancedOptimization(strategy) {
            if (!window.transferSimPro) return;
            window.transferSimPro.optimizeTeamAdvanced(strategy);
        }

        function selectTemplate(template) {
            // Update active template button
            document.querySelectorAll('.template-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update template display
            if (window.transferSimPro) {
                const templateConfig = window.transferSimPro.wildcardPlanner.generateWildcardTemplate(template);
                console.log(`Selected ${template} template:`, templateConfig);
            }
        }

        // Enhanced player card interactions
        function showPlayerAdvancedAnalysis(playerId) {
            if (!window.transferSimPro) return;
            window.transferSimPro.showAdvancedAnalysis(playerId);
        }

        // NEW ADVANCED FEATURE FUNCTIONS
        
        function showPriceTracker() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure price tracker is initialized
            if (!window.transferSimPro.priceTracker) {
                window.transferSimPro.initializePriceTracker();
            }
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            
            // Get sample players for predictions
            const samplePlayers = window.transferSimPro.allPlayers && window.transferSimPro.allPlayers.length > 0 
                ? window.transferSimPro.allPlayers.slice(0, 6)
                : [
                    {first_name: 'Mohamed', second_name: 'Salah', transfers_in_event: 150000, transfers_out_event: 50000},
                    {first_name: 'Erling', second_name: 'Haaland', transfers_in_event: 200000, transfers_out_event: 30000},
                    {first_name: 'Cole', second_name: 'Palmer', transfers_in_event: 180000, transfers_out_event: 20000},
                    {first_name: 'Bukayo', second_name: 'Saka', transfers_in_event: 90000, transfers_out_event: 60000},
                    {first_name: 'Son', second_name: 'Heung-min', transfers_in_event: 40000, transfers_out_event: 80000},
                    {first_name: 'Bruno', second_name: 'Fernandes', transfers_in_event: 60000, transfers_out_event: 70000}
                ];
            
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()" style="position: absolute; top: 20px; right: 20px; font-size: 2rem; cursor: pointer; color: #666;">&times;</span>
                    <h2>💹 Real-time Price Tracker</h2>
                    
                    <div class="price-tracker-content">
                        <h3>🔔 Price Alerts</h3>
                        <div class="alert-list" style="background: #f9f9f9; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                            ${window.transferSimPro.priceTracker && window.transferSimPro.priceTracker.priceAlerts && window.transferSimPro.priceTracker.priceAlerts.length > 0 ? 
                                window.transferSimPro.priceTracker.priceAlerts.map(alert => `
                                    <div class="alert-item" style="padding: 10px; background: white; margin: 5px 0; border-radius: 5px;">
                                        Player ID: ${alert.playerId} | Target: £${(alert.targetPrice/10).toFixed(1)}m
                                    </div>
                                `).join('') : '<p style="color: #666;">No active price alerts. Add players to track their prices!</p>'
                            }
                        </div>
                        
                        <h3 style="margin-top: 20px;">📈 Price Predictions</h3>
                        <div class="prediction-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                            ${samplePlayers.map(player => {
                                const prediction = window.transferSimPro.priceTracker.getPredictedChange(player);
                                return `
                                    <div class="prediction-card" style="background: white; padding: 15px; border-radius: 10px; text-align: center; border: 2px solid ${prediction.direction === '↑' ? '#28a745' : prediction.direction === '↓' ? '#dc3545' : '#ffc107'};">
                                        <div style="font-weight: 600; margin-bottom: 10px;">${player.first_name} ${player.second_name}</div>
                                        <div style="font-size: 2rem; color: ${prediction.direction === '↑' ? '#28a745' : prediction.direction === '↓' ? '#dc3545' : '#ffc107'};">${prediction.direction}</div>
                                        <div style="color: #666;">Probability: ${prediction.probability}%</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: #e8f5e9; border-radius: 10px;">
                            <p style="margin: 0; color: #2e7d32;"><strong>💡 Tip:</strong> Players with high transfer activity (↑) are likely to rise in price soon!</p>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showSquadComparison() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure squad comparison is initialized
            if (!window.transferSimPro.squadComparison) {
                window.transferSimPro.initializeSquadComparison();
            }
            
            const comparison = window.transferSimPro.squadComparison.compareWithTop();
            const differentials = window.transferSimPro.squadComparison.findDifferentials();
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>⚔️ Squad Comparison Analysis</h2>
                    
                    <div class="comparison-stats">
                        <h3>📊 Comparison with Top 10%</h3>
                        <div class="stat-grid">
                            <div class="stat-item">
                                <div class="stat-label">Common Players</div>
                                <div class="stat-value">${comparison.commonPlayers}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Differentials</div>
                                <div class="stat-value">${comparison.differentials}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Unique Score</div>
                                <div class="stat-value">${comparison.uniqueScore}%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Risk Rating</div>
                                <div class="stat-value" style="color: ${comparison.riskRating === 'High' ? '#dc3545' : comparison.riskRating === 'Medium' ? '#ffc107' : '#28a745'}">
                                    ${comparison.riskRating}
                                </div>
                            </div>
                        </div>
                        
                        <h3 style="margin-top: 20px;">💎 Top Differential Picks</h3>
                        <div class="differential-list">
                            ${differentials.slice(0, 5).map(player => `
                                <div class="differential-item">
                                    <div>${player.first_name} ${player.second_name}</div>
                                    <div>TSB: ${player.selected_by_percent}% | Form: ${player.form}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showFDRAnalysis() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure FDR calculator is initialized
            if (!window.transferSimPro.fdrCalculator) {
                window.transferSimPro.initializeFDRCalculator();
            }
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>📅 Advanced FDR Calculator</h2>
                    
                    <div class="fdr-content">
                        <h3>Team Fixture Analysis</h3>
                        <div class="team-fdr-grid">
                            ${window.transferSimPro.teams.slice(0, 6).map(team => {
                                const fdr = window.transferSimPro.fdrCalculator.calculate(team.id);
                                return `
                                    <div class="fdr-card">
                                        <h4>${team.name}</h4>
                                        <div class="fdr-score" style="color: ${fdr.rating === 'Excellent' ? '#28a745' : fdr.rating === 'Good' ? '#ffc107' : '#dc3545'}">
                                            FDR: ${fdr.averageFDR}
                                        </div>
                                        <div class="fdr-rating">${fdr.rating}</div>
                                        <div class="fdr-recommendation">${fdr.recommendation}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showStrategySimulator() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure strategy simulator is initialized
            if (!window.transferSimPro.strategySimulator) {
                window.transferSimPro.initializeStrategySimulator();
            }
            
            const strategy = window.transferSimPro.strategySimulator.simulateStrategy();
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>🎮 Multi-week Transfer Strategy</h2>
                    
                    <div class="strategy-content">
                        <div class="strategy-summary">
                            <div class="summary-item">
                                <span>Total Hit Cost:</span>
                                <span style="color: #dc3545;">-${strategy.totalHitsCost} pts</span>
                            </div>
                            <div class="summary-item">
                                <span>Expected Gain:</span>
                                <span style="color: #28a745;">+${strategy.expectedPoints} pts</span>
                            </div>
                            <div class="summary-item">
                                <span>Net Benefit:</span>
                                <span style="color: ${strategy.netGain > 0 ? '#28a745' : '#dc3545'};">
                                    ${strategy.netGain > 0 ? '+' : ''}${strategy.netGain} pts
                                </span>
                            </div>
                        </div>
                        
                        <h3>Transfer Plan by Gameweek</h3>
                        <div class="strategy-timeline">
                            ${strategy.strategy.map(gw => `
                                <div class="gameweek-plan">
                                    <h4>GW ${gw.gameweek}</h4>
                                    ${gw.transfers.map(t => `
                                        <div class="transfer-item">
                                            <span>OUT: ${t.out}</span>
                                            <span>→</span>
                                            <span>IN: ${t.in}</span>
                                            <span style="color: ${t.cost > 0 ? '#dc3545' : '#28a745'};">
                                                ${t.cost > 0 ? `-${t.cost}` : 'Free'}
                                            </span>
                                        </div>
                                    `).join('')}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showXGStats() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure advanced stats are initialized
            if (!window.transferSimPro.advancedStats) {
                window.transferSimPro.initializeAdvancedStats();
            }
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>📊 Expected Goals & Advanced Stats</h2>
                    
                    <div class="xg-content">
                        <h3>Top xG Performers</h3>
                        <div class="xg-grid">
                            ${window.transferSimPro.currentSquad[3].concat(window.transferSimPro.currentSquad[4])
                                .filter(p => p)
                                .slice(0, 6)
                                .map(player => {
                                    const xg = window.transferSimPro.advancedStats.getPlayerxG(player);
                                    const metrics = window.transferSimPro.advancedStats.getPerformanceMetrics(player);
                                    return `
                                        <div class="xg-card">
                                            <h4>${player.first_name} ${player.second_name}</h4>
                                            <div class="xg-stats">
                                                <div>xG: ${xg.xG}</div>
                                                <div>xA: ${xg.xA}</div>
                                                <div>xGI: ${xg.xGI}</div>
                                                <div>Shots: ${xg.shots}</div>
                                            </div>
                                            <div class="performance-indicator">
                                                ${metrics.overperforming ? '📈 Overperforming' : '📉 Underperforming'}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showCompetitorAnalysis() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure competitor analysis is initialized
            if (!window.transferSimPro.competitorAnalysis) {
                window.transferSimPro.initializeCompetitorAnalysis();
            }
            
            const analysis = window.transferSimPro.competitorAnalysis.analyzeRivals();
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>🏆 Mini-league Competitor Analysis</h2>
                    
                    <div class="competitor-content">
                        <div class="your-position">
                            <h3>Your Position</h3>
                            <div class="position-stats">
                                <div>Rank: ${analysis.yourRank}</div>
                                <div>Points to Leader: ${analysis.pointsToLeader}</div>
                                <div>Catch Probability: ${analysis.catchProbability.toFixed(1)}%</div>
                            </div>
                        </div>
                        
                        <h3>Top Rivals</h3>
                        <div class="rivals-list">
                            ${analysis.rivals.map(rival => `
                                <div class="rival-card">
                                    <div class="rival-rank">#${rival.rank}</div>
                                    <div class="rival-info">
                                        <div>${rival.name}</div>
                                        <div>${rival.points} pts | TV: £${rival.teamValue.toFixed(1)}m</div>
                                        <div>Captain Success: ${rival.captainSuccess}%</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showChipOptimizer() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure chip optimizer is initialized
            if (!window.transferSimPro.chipOptimizer) {
                window.transferSimPro.initializeChipOptimizer();
            }
            
            const recommendations = window.transferSimPro.chipOptimizer.optimizeChipTiming();
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>🎯 Chip Strategy Optimizer</h2>
                    
                    <div class="chip-content">
                        ${Object.entries(recommendations).map(([chip, data]) => `
                            <div class="chip-recommendation">
                                <h3>${chip}</h3>
                                <div class="chip-timing">
                                    <div class="optimal-gw">GW ${data.optimalGameweek}</div>
                                    <div class="expected-points">+${data.expectedPoints} pts</div>
                                    <div class="confidence">Confidence: ${data.confidence}%</div>
                                </div>
                                <div class="chip-reasoning">${data.reasoning}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showOwnershipHeatmap() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure ownership analysis is initialized
            if (!window.transferSimPro.ownershipAnalysis) {
                window.transferSimPro.initializeOwnershipAnalysis();
            }
            
            const heatmap = window.transferSimPro.ownershipAnalysis.generateHeatmap();
            const gems = window.transferSimPro.ownershipAnalysis.findHiddenGems();
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>🗺️ Ownership Heatmap & Hidden Gems</h2>
                    
                    <div class="ownership-content">
                        <h3>Position Ownership Distribution</h3>
                        <div class="heatmap-grid">
                            ${Object.entries(heatmap).map(([pos, data]) => `
                                <div class="heatmap-position">
                                    <h4>${pos}</h4>
                                    <div class="ownership-bars">
                                        <div>High (>30%): ${data.high} players</div>
                                        <div>Medium (10-30%): ${data.medium} players</div>
                                        <div>Low (5-10%): ${data.low} players</div>
                                        <div>Differential (<5%): ${data.differential} players</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <h3>💎 Hidden Gems (TSB < 2%)</h3>
                        <div class="gems-list">
                            ${gems.map(player => `
                                <div class="gem-card">
                                    <div>${player.first_name} ${player.second_name}</div>
                                    <div>PPG: ${player.points_per_game} | TSB: ${player.selected_by_percent}%</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showCaptainOptimizer() {
            if (!window.transferSimPro) {
                console.log('Transfer Simulator Pro not initialized');
                return;
            }
            
            // Ensure captain optimizer is initialized
            if (!window.transferSimPro.captainOptimizer) {
                window.transferSimPro.initializeCaptainOptimizer();
            }
            
            const captaincy = window.transferSimPro.captainOptimizer.optimizeCaptaincy();
            
            const modal = document.createElement('div');
            modal.className = 'advanced-modal';
            modal.innerHTML = `
                <div class="modal-content advanced-modal-content">
                    <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <h2>👑 AI Captain Optimizer</h2>
                    
                    <div class="captain-content">
                        ${captaincy.recommended ? `
                            <div class="captain-recommendations">
                                <div class="captain-pick">
                                    <h3>🎯 Recommended Captain</h3>
                                    <div class="captain-player">
                                        <div>${captaincy.recommended.player.first_name} ${captaincy.recommended.player.second_name}</div>
                                        <div>Expected: ${captaincy.recommended.expectedPoints.toFixed(1)} pts</div>
                                        <div>Confidence: ${captaincy.recommended.confidence}%</div>
                                    </div>
                                </div>
                                
                                ${captaincy.viceCaptain ? `
                                    <div class="captain-pick">
                                        <h3>🥈 Vice Captain</h3>
                                        <div class="captain-player">
                                            <div>${captaincy.viceCaptain.player.first_name} ${captaincy.viceCaptain.player.second_name}</div>
                                            <div>Expected: ${captaincy.viceCaptain.expectedPoints.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${captaincy.differential ? `
                                    <div class="captain-pick">
                                        <h3>🎲 Differential Pick</h3>
                                        <div class="captain-player">
                                            <div>${captaincy.differential.player.first_name} ${captaincy.differential.player.second_name}</div>
                                            <div>EO: ${captaincy.differential.effectiveOwnership.toFixed(1)}%</div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : '<p>Add midfielders and forwards to your squad for captain recommendations</p>'}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Floating Action Button Toggle
        function toggleFabMenu() {
            const fabMenu = document.getElementById('fabMenu');
            fabMenu.classList.toggle('active');
        }

        // Close FAB menu when clicking outside
        document.addEventListener('click', (e) => {
            const fabMenu = document.getElementById('fabMenu');
            const floatingMenu = document.querySelector('.floating-menu');
            if (fabMenu && !floatingMenu.contains(e.target)) {
                fabMenu.classList.remove('active');
            }
        });

        // Debug function to test all features
        function testAllFeatures() {
            console.log('🧪 Testing All Advanced Features...');
            
            const features = [
                'aiPredictor', 'priceTracker', 'squadComparison', 'fdrCalculator',
                'strategySimulator', 'advancedStats', 'competitorAnalysis',
                'chipOptimizer', 'ownershipAnalysis', 'captainOptimizer',
                'chemistryCalculator', 'marketSentiment', 'wildcardPlanner',
                'injuryRiskAssessment', 'historicalTrends', 'fixtureAnalyzer',
                'performancePredictor'
            ];
            
            let working = 0;
            let failed = 0;
            
            features.forEach(feature => {
                if (window.transferSimPro && window.transferSimPro[feature]) {
                    console.log(`✅ ${feature} is initialized`);
                    working++;
                } else {
                    console.log(`❌ ${feature} is NOT initialized`);
                    failed++;
                }
            });
            
            console.log(`📊 Results: ${working} working, ${failed} failed out of ${features.length} features`);
            
            if (failed > 0) {
                console.log('🔧 Attempting to fix failed features...');
                window.transferSimPro.initializeAllAdvancedSystems();
                window.transferSimPro.initializeAdvancedFeatures();
            }
            
            return { working, failed, total: features.length };
        }

        // Initialize
        window.transferSimPro = new TransferSimulatorPro();
        
        // Ensure FPLDataService is available globally
        if (typeof FPLDataService === 'undefined') {
            console.error('FPLDataService not found! Loading fallback...');
            // Define a minimal FPLDataService if not available
            window.FPLDataService = class {
                getMockBootstrapData() {
                    return {
                        elements: [],
                        teams: []
                    };
                }
            };
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded - Initializing Transfer Simulator Pro...');
            
            try {
                // Initialize immediately with embedded data
                window.transferSimPro.init();
                
                // Check if data loaded successfully
                if (!window.transferSimPro.allPlayers || window.transferSimPro.allPlayers.length === 0) {
                    console.warn('No player data available yet, using fallback data');
                    // Don't show alert - let the app continue with fallback data
                }
                
                console.log(`Transfer Simulator Pro initialized with ${window.transferSimPro.allPlayers.length} players`);
                
            } catch (error) {
                console.error('Failed to initialize Transfer Simulator Pro:', error);
                // Don't show alert - silently log the error
                console.log('Will continue with limited functionality');
            }
            
            // Test features in development mode
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                setTimeout(() => {
                    console.log('Running feature test in development mode...');
                    testAllFeatures();
                }, 2000);
            }
        });
        // Animate transfer statistics on scroll
        function animateTransferStats() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Animate spending bars
                        const spendingBars = entry.target.querySelectorAll('.spending-fill');
                        spendingBars.forEach((bar, index) => {
                            const widths = ['100%', '95%', '88%', '82%', '75%'];
                            setTimeout(() => {
                                bar.style.width = widths[index] || '70%';
                            }, index * 100);
                        });
                        
                        // Animate route bars
                        const routeBars = entry.target.querySelectorAll('.route-fill');
                        routeBars.forEach((bar, index) => {
                            const widths = ['43%', '38%', '12%', '7%'];
                            setTimeout(() => {
                                bar.style.width = widths[index] || '5%';
                            }, index * 150);
                        });
                        
                        // Animate numbers
                        const statNumbers = entry.target.querySelectorAll('.trend-value');
                        statNumbers.forEach(num => {
                            const finalValue = num.textContent;
                            let currentValue = 0;
                            const increment = parseFloat(finalValue) / 20;
                            const timer = setInterval(() => {
                                currentValue += increment;
                                if (currentValue >= parseFloat(finalValue)) {
                                    num.textContent = finalValue;
                                    clearInterval(timer);
                                } else {
                                    num.textContent = finalValue.includes('£') ? 
                                        `£${currentValue.toFixed(1)}M` : 
                                        Math.floor(currentValue).toString();
                                }
                            }, 50);
                        });
                        
                        observer.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.3 });
            
            const statsSection = document.querySelector('.transfer-stats-section');
            if (statsSection) {
                observer.observe(statsSection);
            }
        }
        
        // Initialize animations when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', animateTransferStats);
        } else {
            animateTransferStats();
        }
    </script>
    <script src="./auth-service.js"></script>
    <script src="./premium-access-control.js"></script>
    <script src="./membership-popup.js"></script>
</body>
</html>