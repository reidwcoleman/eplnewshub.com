<!DOCTYPE html>
<html>
<head>
    <title>Test FPL Paragraph Parsing</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-area { background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .result { background: white; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #10b981; }
        button { background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; }
        textarea { width: 100%; height: 100px; padding: 10px; border-radius: 8px; border: 1px solid #ddd; }
    </style>
</head>
<body>
    <h1>üß† FPL Paragraph Parsing Test</h1>
    
    <div class="test-area">
        <h3>Enter a complex paragraph about FPL players:</h3>
        <textarea id="testInput" placeholder="Example: Haaland scored twice and got 12 points, while Palmer is now on penalties for Chelsea and scored a penalty. Meanwhile, Salah picked up an injury and is out for 2 weeks, but Gordon's price rose to 7.6m last night due to his great form."></textarea>
        <button onclick="testParsing()">üîç Parse Information</button>
    </div>
    
    <div id="results"></div>

    <script>
        // Copy the parsing functions from fpl-ai-assistant.html
        function parseComplexInformation(text) {
            const results = [];
            
            // Enhanced player database with more variations
            const playerDatabase = {
                'haaland': ['haaland', 'erling', 'norwegian', 'city striker', 'man city forward', 'erling haaland'],
                'salah': ['salah', 'mo', 'mohamed', 'egyptian', 'liverpool winger', 'mohamed salah', 'mo salah'],
                'palmer': ['palmer', 'cole', 'chelsea midfielder', 'cole palmer', 'blues midfielder'],
                'saka': ['saka', 'bukayo', 'arsenal winger', 'bukayo saka', 'gunners winger'],
                'son': ['son', 'heung-min', 'spurs forward', 'korean', 'son heung-min', 'tottenham forward'],
                'watkins': ['watkins', 'ollie', 'villa striker', 'aston villa', 'ollie watkins', 'villa forward'],
                'isak': ['isak', 'alexander', 'newcastle striker', 'swedish', 'alexander isak', 'toon striker'],
                'gordon': ['gordon', 'anthony', 'newcastle winger', 'anthony gordon', 'toon winger'],
                'cunha': ['cunha', 'matheus', 'wolves striker', 'matheus cunha', 'wolves forward'],
                'mbeumo': ['mbeumo', 'bryan', 'brentford winger', 'bryan mbeumo', 'bees winger'],
                'eze': ['eze', 'eberechi', 'palace midfielder', 'crystal palace', 'eberechi eze'],
                'foden': ['foden', 'phil', 'city midfielder', 'phil foden', 'man city mid'],
                'bruno': ['bruno', 'fernandes', 'united midfielder', 'man united', 'bruno fernandes'],
                'kane': ['kane', 'harry', 'bayern striker', 'england', 'harry kane', 'bayern forward'],
                'rashford': ['rashford', 'marcus', 'united forward', 'marcus rashford', 'man united forward'],
                'nunez': ['nunez', 'darwin', 'liverpool striker', 'darwin nunez', 'reds striker'],
                'maddison': ['maddison', 'james', 'spurs midfielder', 'james maddison', 'tottenham mid'],
                'martinelli': ['martinelli', 'gabriel', 'arsenal winger', 'gabriel martinelli', 'gunners winger'],
                'jesus': ['jesus', 'gabriel', 'arsenal striker', 'gabriel jesus', 'gunners striker'],
                'mudryk': ['mudryk', 'mykhailo', 'chelsea winger', 'mykhailo mudryk', 'blues winger'],
                'havertz': ['havertz', 'kai', 'arsenal striker', 'kai havertz', 'gunners striker'],
                'odegaard': ['odegaard', 'martin', 'arsenal captain', 'martin odegaard', 'gunners captain'],
                'rice': ['rice', 'declan', 'arsenal midfielder', 'declan rice', 'gunners midfielder'],
                'white': ['white', 'ben', 'arsenal defender', 'ben white', 'gunners defender'],
                'gabriel': ['gabriel', 'magalhaes', 'arsenal defender', 'gabriel magalhaes', 'gunners defender'],
                'pickford': ['pickford', 'jordan', 'everton keeper', 'jordan pickford', 'everton goalkeeper'],
                'pope': ['pope', 'nick', 'newcastle keeper', 'nick pope', 'toon keeper'],
                'alisson': ['alisson', 'liverpool keeper', 'brazilian', 'alisson becker', 'reds keeper'],
                'ederson': ['ederson', 'city keeper', 'brazilian', 'ederson moraes', 'city goalkeeper']
            };
            
            // Smart text segmentation with multiple strategies
            const segments = [];
            
            // Strategy 1: Split by sentences 
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 5);
            segments.push(...sentences);
            
            // Strategy 2: Split by coordinating conjunctions (while, meanwhile, but, however)
            const coordPhrases = text.split(/(?:\s+(?:while|meanwhile|but|however|also|additionally)\s+)/i).filter(s => s.trim().length > 5);
            segments.push(...coordPhrases);
            
            // Strategy 3: Split by commas when they separate different topics
            const commaPhrases = text.split(/,\s+(?=\w+\s+(?:scored|got|is|was|will|has|have))/i).filter(s => s.trim().length > 10);
            segments.push(...commaPhrases);
            
            // Strategy 4: Split by "and" when it connects different players/topics
            const andPhrases = text.split(/\s+and\s+(?=\w+\s+(?:scored|got|is|was|will|has|have))/i).filter(s => s.trim().length > 10);
            segments.push(...andPhrases);
            
            // Clean and deduplicate segments
            const cleanSegments = segments
                .map(s => s.replace(/^[,;.\s]+|[,;.\s]+$/g, '').trim()) // Remove leading/trailing punctuation
                .filter(s => s.length > 5) // Minimum length
                .filter((s, i, arr) => arr.indexOf(s) === i); // Remove duplicates
            
            console.log('All text segments after smart splitting:', cleanSegments);
            
            // Analyze each segment for player information
            cleanSegments.forEach(segment => {
                const analysis = analyzeTextSegment(segment, playerDatabase);
                if (analysis.isValid) {
                    results.push(analysis);
                }
            });
            
            // If no specific player info found, treat entire text as general
            if (results.length === 0) {
                results.push({
                    type: 'general',
                    text: text,
                    player: null,
                    data: {},
                    isValid: true
                });
            }
            
            console.log('Parsed information results:', results);
            return results;
        }

        function analyzeTextSegment(segment, playerDatabase) {
            const lower = segment.toLowerCase();
            let foundPlayer = null;
            let playerKey = null;
            
            // Find player in segment
            for (const [key, variations] of Object.entries(playerDatabase)) {
                for (const variation of variations) {
                    if (lower.includes(variation)) {
                        foundPlayer = key.charAt(0).toUpperCase() + key.slice(1);
                        playerKey = key;
                        break;
                    }
                }
                if (foundPlayer) break;
            }
            
            // Extract numerical data
            const data = extractPlayerData(segment);
            
            // Determine if this segment contains useful information
            const hasUsefulInfo = foundPlayer || 
                                segment.length > 15 || 
                                /\d+/.test(segment) ||
                                /(injured|out|fit|available|penalty|captain|goal|assist|point)/i.test(segment);
            
            return {
                type: foundPlayer ? 'player' : 'general',
                text: segment.trim(),
                player: foundPlayer,
                playerKey: playerKey,
                data: data,
                isValid: hasUsefulInfo,
                confidence: calculateConfidence(segment, foundPlayer)
            };
        }

        function calculateConfidence(segment, foundPlayer) {
            let confidence = 0.3; // Base confidence
            
            if (foundPlayer) confidence += 0.4;
            if (/\d+/.test(segment)) confidence += 0.2; // Contains numbers
            if (/(goal|assist|point|price|injured)/i.test(segment)) confidence += 0.3;
            if (segment.length > 20) confidence += 0.1;
            
            return Math.min(confidence, 1.0);
        }

        function extractPlayerData(info) {
            const data = {};
            
            // Points patterns
            const pointsPatterns = [
                /(\d+)\s*points?/i,
                /scored\s*(\d+)\s*points?/i,
                /got\s*(\d+)\s*points?/i,
                /earned\s*(\d+)\s*points?/i
            ];
            
            for (const pattern of pointsPatterns) {
                const match = info.match(pattern);
                if (match) {
                    data.points = parseInt(match[1]);
                    break;
                }
            }
            
            // Goals patterns  
            const goalPatterns = [
                /(\d+)\s*goals?/i,
                /scored\s*(\d+)\s*(?:goals?)?/i,
                /netted\s*(\d+)/i,
                /(\d+)\s*(?:goal|strike)s?/i
            ];
            
            for (const pattern of goalPatterns) {
                const match = info.match(pattern);
                if (match && !info.toLowerCase().includes('point')) { // Avoid confusing "scored 12 points" with goals
                    data.goals = parseInt(match[1]);
                    break;
                }
            }
            
            // Assists patterns
            const assistPatterns = [
                /(\d+)\s*assists?/i,
                /provided\s*(\d+)\s*assists?/i,
                /set up\s*(\d+)/i,
                /(\d+)\s*(?:assist|setup)s?/i
            ];
            
            for (const pattern of assistPatterns) {
                const match = info.match(pattern);
                if (match) {
                    data.assists = parseInt(match[1]);
                    break;
                }
            }
            
            // Price patterns
            const pricePatterns = [
                /(?:price|cost|value).*?¬£?(\d+\.\d+)m?/i,
                /¬£(\d+\.\d+)m/i,
                /(\d+\.\d+)m.*?(?:price|cost)/i,
                /rose to\s*¬£?(\d+\.\d+)m?/i,
                /fell to\s*¬£?(\d+\.\d+)m?/i
            ];
            
            for (const pattern of pricePatterns) {
                const match = info.match(pattern);
                if (match) {
                    data.price = parseFloat(match[1]);
                    break;
                }
            }
            
            // Status patterns (injury, fitness, etc.)
            if (/(?:injured|hurt|out|unavailable|doubt)/i.test(info)) {
                data.status = 'injured';
            } else if (/(?:fit|available|ready|back)/i.test(info)) {
                data.status = 'fit';
            }
            
            // Special roles (penalties, captain, etc.)
            if (/(?:penalty|penalties|pen)/i.test(info)) {
                data.penalties = true;
            }
            
            if (/(?:captain|captaincy)/i.test(info)) {
                data.captain = true;
            }
            
            // Clean room patterns (bench, starting, rotation)
            if (/(?:benched|bench|substitute)/i.test(info)) {
                data.starting = false;
            } else if (/(?:starting|first team|xi)/i.test(info)) {
                data.starting = true;
            }
            
            console.log('Extracted data from "' + info + '":', data);
            return data;
        }

        function testParsing() {
            const text = document.getElementById('testInput').value;
            const results = parseComplexInformation(text);
            
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h3>üîç Parsing Results:</h3>';
            
            results.forEach((result, index) => {
                const div = document.createElement('div');
                div.className = 'result';
                div.innerHTML = `
                    <strong>${index + 1}. ${result.type.toUpperCase()}${result.player ? ` - ${result.player}` : ''}</strong><br>
                    üìù Text: "${result.text}"<br>
                    üìä Data extracted: ${JSON.stringify(result.data)}<br>
                    üéØ Confidence: ${Math.round(result.confidence * 100)}%
                `;
                resultsDiv.appendChild(div);
            });
        }
    </script>
</body>
</html>