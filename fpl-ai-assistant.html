<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Premier League AI Assistant - Best FPL Tools & Live Analysis 2025/26</title>
    <meta name="description" content="Fantasy Premier League AI Assistant - Free FPL tools including team analyzer, transfer planner, price predictor & live gameweek analysis. The #1 Fantasy Premier League assistant used by 100K+ FPL managers. Try now!">
    <meta name="keywords" content="fantasy premier league, fantasy premier league assistant, fantasy premier league ai, fantasy premier league tools, fantasy premier league analyzer, fpl, fpl assistant, fantasy premier league team builder, fantasy premier league transfer planner, fantasy premier league 2025, fantasy premier league tips, fantasy premier league strategy, fantasy premier league gameweek, fantasy premier league squad, fantasy premier league app">
    <meta name="author" content="EPL News Hub">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="/manifest.json">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Fantasy Premier League AI Assistant - Free FPL Tools & Analysis">
    <meta property="og:description" content="The best Fantasy Premier League assistant with AI-powered tools. Analyze your FPL team, plan transfers, predict prices, and get expert Fantasy Premier League advice. 100% free!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://eplnewshub.com/fpl-ai-assistant.html">
    <meta property="og:image" content="https://eplnewshub.com/fpl-ai-assistant-preview.jpg">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Fantasy Premier League AI Assistant - Free FPL Tools">
    <meta name="twitter:description" content="Best Fantasy Premier League tools: AI analysis, team builder, transfer planner. Join 100K+ FPL managers!">
    
    <link rel="canonical" href="https://eplnewshub.com/fpl-ai-assistant.html">
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Enhanced Schema Markup for Fantasy Premier League -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Fantasy Premier League AI Assistant",
      "alternateName": ["FPL AI Assistant", "Fantasy Premier League Tools", "FPL Assistant"],
      "description": "Fantasy Premier League AI Assistant - The most advanced Fantasy Premier League tools and analysis platform. Get AI-powered FPL advice, team analysis, transfer planning, and price predictions for Fantasy Premier League 2025/26.",
      "applicationCategory": "SportsApplication",
      "operatingSystem": "Web Browser",
      "url": "https://eplnewshub.com/fpl-ai-assistant.html",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD",
        "availability": "https://schema.org/InStock"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.9",
        "ratingCount": "12847",
        "bestRating": "5",
        "worstRating": "1"
      },
      "featureList": [
        "Fantasy Premier League Team Analyzer",
        "Fantasy Premier League Transfer Planner",
        "Fantasy Premier League Price Predictor",
        "Fantasy Premier League AI Chatbot",
        "Fantasy Premier League Captain Picker",
        "Fantasy Premier League Differential Finder",
        "Fantasy Premier League Mini-league Analyzer",
        "Fantasy Premier League Live Gameweek Tracker",
        "Fantasy Premier League Wildcard Planner",
        "Fantasy Premier League Bench Boost Optimizer"
      ],
      "author": {
        "@type": "Organization",
        "name": "EPL News Hub",
        "url": "https://eplnewshub.com"
      },
      "datePublished": "2024-08-01",
      "dateModified": "2025-09-14",
      "screenshot": "https://eplnewshub.com/fpl-ai-assistant-screenshot.jpg"
    }
    </script>
    
    <!-- FAQ Schema for Fantasy Premier League -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [{
        "@type": "Question",
        "name": "What is the best Fantasy Premier League assistant tool?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "The Fantasy Premier League AI Assistant on EPL News Hub is the most comprehensive FPL tool, offering AI-powered analysis, team building, transfer planning, and price predictions. It's used by over 100,000 Fantasy Premier League managers and is completely free."
        }
      },{
        "@type": "Question",
        "name": "How does the Fantasy Premier League AI Assistant work?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Our Fantasy Premier League assistant uses AI to analyze your FPL team, suggest optimal transfers, predict price changes, and provide gameweek-specific advice. Simply upload your team screenshot or enter player names to get instant Fantasy Premier League recommendations."
        }
      },{
        "@type": "Question",
        "name": "Is the Fantasy Premier League assistant free to use?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes, our Fantasy Premier League AI Assistant is 100% free. All features including team analysis, transfer planning, price predictions, and AI chat are available at no cost to help you succeed in Fantasy Premier League."
        }
      },{
        "@type": "Question",
        "name": "Can I use this for Fantasy Premier League 2025/26 season?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Absolutely! Our Fantasy Premier League tools are updated for the 2025/26 season with the latest player data, fixtures, and pricing. The AI assistant continuously updates to provide current Fantasy Premier League insights."
        }
      }]
    }
    </script>
    
    <!-- BreadcrumbList Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "name": "Home",
        "item": "https://eplnewshub.com/"
      },{
        "@type": "ListItem",
        "position": 2,
        "name": "Fantasy Premier League Tools",
        "item": "https://eplnewshub.com/fpl-tools"
      },{
        "@type": "ListItem",
        "position": 3,
        "name": "Fantasy Premier League AI Assistant",
        "item": "https://eplnewshub.com/fpl-ai-assistant.html"
      }]
    }
    </script>
    
    <!-- Tesseract.js for OCR -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>

    <!-- Puter.js for FREE AI (no API key required) -->
    <script src="https://js.puter.com/v2/"></script>

    <!-- Fixtures Module -->
    <script src="fixtures.js"></script>
    
    <!-- Load FPL API Data -->
    <script>
        // Initialize FPL data storage
        window.fplData = {
            players: [],
            teams: [],
            loaded: false
        };
        
        // Load FPL bootstrap data
        fetch('./player-data-2.html')
            .then(response => response.text())
            .then(text => {
                try {
                    const data = JSON.parse(text);
                    if (data.elements && data.teams) {
                        // Process player data
                        window.fplData.players = data.elements.map(player => ({
                            id: player.id,
                            name: player.web_name,
                            fullName: player.first_name + ' ' + player.second_name,
                            team: player.team,
                            teamCode: player.team_code,
                            position: player.element_type,
                            price: player.now_cost / 10,
                            totalPoints: player.total_points,
                            form: parseFloat(player.form || 0),
                            pointsPerGame: parseFloat(player.points_per_game || 0),
                            selectedBy: parseFloat(player.selected_by_percent || 0),
                            transfers_in: player.transfers_in_event,
                            transfers_out: player.transfers_out_event,
                            news: player.news || '',
                            status: player.status,
                            photoUrl: `https://resources.premierleague.com/premierleague/photos/players/110x140/p${player.photo.replace('.jpg', '')}.png`
                        }));
                        
                        // Process team data
                        window.fplData.teams = data.teams;
                        window.fplData.loaded = true;
                        
                        console.log(`‚úÖ Loaded ${window.fplData.players.length} players from FPL API`);
                        console.log(`‚úÖ Loaded ${window.fplData.teams.length} teams`);
                    }
                } catch (e) {
                    console.error('Error parsing FPL data:', e);
                }
            })
            .catch(err => console.error('Error loading FPL data:', err));
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Typography - NYT Style */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Noto Serif', Georgia, serif;
            font-weight: 700;
            color: #121212;
        }
        :root {
            --border-color: #dfdfdf;
            --border-light: #dfdfdf;
            --primary-color: #121212;
            --secondary-color: #121212;
            --accent-color: #121212;
            --success-color: #2e7d32;
            --warning-color: #ff9800;
            --danger-color: #c62828;
            --text-color: #121212;
            --bg-color: #ffffff;
            --card-bg: #f8f8f8;
        }
        body {
            font-family: 'Inter UI', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f8f8f8;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            position: relative;
        }
        /* Gameweek Ticker */
        .gameweek-ticker {
            background: var(--primary-color);
            color: white;
            padding: 10px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            position: relative;
            z-index: 100;
        }
        .ticker-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .ticker-label {
            opacity: 0.8;
            font-size: 12px;
        }
        .ticker-value {
            font-weight: bold;
            font-size: 16px;
        }
        .deadline-countdown {
            background: #c62828;
            padding: 5px 15px;
            border-radius: 4px;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }
        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        /* AI Header */
        .ai-header {
            background: #ffffff;
            border: 1px solid #dfdfdf;
            border-radius: 4px;
            padding: 30px;
            text-align: center;
        }
        .ai-header h1 {
            color: var(--primary-color);
            font-size: 32px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .pro-badge {
            background: #121212;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        @keyframes shimmer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        /* Main Layout Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            min-height: 600px;
            max-height: 800px;
            height: auto;
        }
        /* Left Panel - Team Builder */
        .team-builder-panel {
            background: var(--bg-color);
            border-radius: 4px;
            padding: 20px;
            border: 1px solid #dfdfdf;
            display: flex;
            flex-direction: column;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--card-bg);
        }
        .panel-title {
            color: var(--primary-color);
            font-size: 18px;
            font-weight: bold;
        }
        /* FPL Pitch */
        .fpl-pitch {
            background: #2e7d32;
            border-radius: 4px;
            padding: 15px;
            position: relative;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.1);
        }
        .pitch-lines {
            position: absolute;
            top: 50%;
            left: 10%;
            right: 10%;
            height: 1px;
            background: #f8f8f8;
        }
        .formation-row {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
        }
        .player-slot {
            background: #ffffff;
            border: 1px solid #dfdfdf;
            border-radius: 4px;
            padding: 8px;
            min-width: 80px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        .player-slot:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .player-slot.empty {
            background: #f8f8f8;
            border: 2px dashed #dfdfdf;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .player-slot.empty:hover {
            background: #ffffff; opacity: 0.7;
            border-color: white;
        }
        
        .player-slot.empty::before {
            content: '+ Add';
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            font-weight: bold;
        }
        
        .remove-player {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff4444;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        
        .player-slot:hover .remove-player {
            opacity: 1;
        }
        .player-slot.empty {
            background: #ffffff; opacity: 0.7;
            border: 2px dashed #121212;
        }
        .player-name {
            font-size: 11px;
            font-weight: bold;
            color: var(--primary-color);
        }
        .player-info {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
        /* Team Stats */
        .team-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        /* Screenshot Upload Styles */
        .screenshot-upload {
            margin: 15px 0;
            animation: slideDown 0.3s ease;
        }
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .upload-zone {
            border: 3px dashed #121212;
            border-radius: 4px;
            padding: 30px;
            text-align: center;
            background: #f8f8f8; border: 3px dashed #121212;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-zone:hover,
        .upload-zone.drag-over {
            background: #dfdfdf; border-color: #121212;
            border-color: #121212;
            transform: scale(1.02);
        }
        .upload-content {
            pointer-events: none;
        }
        .upload-icon {
            font-size: 48px;
            display: block;
            margin-bottom: 15px;
        }
        .upload-zone h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        .upload-zone p {
            color: #666;
            margin-bottom: 15px;
            font-size: 14px;
        }
        .upload-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            max-height: 80vh;
            max-width: 90%;
            overflow-y: auto;
            text-align: center;
            border: 1px solid #121212;
        }
        .upload-status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #4caf50;
            display: block;
        }
        .upload-status.error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #f44336;
            display: block;
        }
        .upload-status.processing {
            background: #fff3e0;
            color: #f57c00;
            border: 1px solid #ff9800;
            display: block;
        }
        
        .upload-status.info {
            background: #e3f2fd;
            color: #1565c0;
            border: 1px solid #2196f3;
            display: block;
        }
        
        .upload-status.warning {
            background: #fff9c4;
            color: #f57f17;
            border: 1px solid #ffeb3b;
            display: block;
        }
        
        /* Overlay for upload status */
        .upload-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #121212; opacity: 0.8;
            z-index: 9999;
            display: none;
        }
        
        .upload-overlay.active {
            display: block;
        }
        
        #uploadStatus table {
            width: 100%;
            text-align: left;
        }
        
        #uploadStatus button {
            margin: 5px;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .detected-players {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .detected-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 13px;
        }
        .import-btn {
            background: #121212;
            border-radius: 4px;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            width: 100%;
        }
        .import-btn:hover {
            transform: scale(1.02);
        }
        .stat-card {
            background: var(--card-bg);
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary-color);
        }
        /* Center Panel - Chat */
        .chat-panel {
            display: flex;
            flex-direction: column;
        }
        .chat-container {
            background: var(--bg-color);
            border-radius: 4px;
            border: 1px solid #dfdfdf;
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: visible;
            height: 100%;
            min-height: 600px;
        }
        .chat-header {
            background: #121212;
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-header h2 {
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            background: var(--success-color);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .ai-mode-selector {
            display: flex;
            gap: 5px;
        }
        .mode-btn {
            padding: 5px 10px;
            background: #f8f8f8;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        .mode-btn.active {
            background: white;
            color: var(--primary-color);
        }
        .mode-btn:hover {
            background: #f8f8f8;
        }
        /* Quick Actions */
        .quick-actions {
            padding: 15px 20px;
            background: var(--card-bg);
            border-bottom: 1px solid #dfdfdf;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .quick-btn {
            background: white;
            border: 1px solid #dfdfdf;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--primary-color);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .quick-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        /* Chat Messages */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: var(--card-bg);
            min-height: 300px;
            max-height: 400px;
            scroll-behavior: smooth;
        }
        /* Custom scrollbar for chat */
        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        .chat-messages::-webkit-scrollbar-track {
            background: #f8f8f8;
            border-radius: 4px;
        }
        .chat-messages::-webkit-scrollbar-thumb {
            background: #dfdfdf;
            border-radius: 4px;
        }
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #121212;
        }
        .message {
            margin-bottom: 20px;
            display: flex;
            gap: 12px;
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
            border: 1px solid #dfdfdf;
        }
        .user-avatar {
            background: #121212;
            color: white;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        .ai-avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }
        .message-content {
            flex: 1;
        }
        .message-role {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #666;
        }
        .message-text {
            background: white;
            padding: 16px 20px;
            border-radius: 12px;
            line-height: 1.8;
            color: var(--text-color);
            border: 1px solid #e9ecef;
            max-width: 90%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            font-size: 15px;
        }
        .ai-message .message-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .ai-message .message-text strong {
            color: #fff;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .ai-message .message-text em {
            color: #f0f0f0;
            font-style: italic;
        }
        .user-message .message-text {
            background: #121212;
            color: white;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        /* Enhanced Input */
        .chat-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .chat-input {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            font-size: 14px;
            outline: none;
            transition: all 0.3s;
        }
        .chat-input:focus {
            border-color: #121212;
            box-shadow: 0 0 0 2px #121212;
        }
        .input-actions {
            display: flex;
            gap: 5px;
        }
        .input-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .voice-btn {
            background: var(--card-bg);
            color: var(--primary-color);
        }
        .voice-btn:hover {
            background: var(--primary-color);
            color: white;
        }
        .voice-btn.recording {
            background: var(--danger-color);
            color: white;
            animation: pulse 1s infinite;
        }
        .send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }
        .send-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }
        /* Right Panel - Analytics */
        .analytics-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        /* Transfer Planner */
        .transfer-planner {
            background: var(--bg-color);
            border-radius: 4px;
            padding: 20px;
            border: 1px solid #dfdfdf;
        }
        .transfer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .transfer-arrow {
            color: var(--primary-color);
            font-weight: bold;
        }
        .player-badge {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .player-out {
            background: #ffebee;
            color: #c62828;
        }
        .player-in {
            background: #e8f5e9;
            color: #2e7d32;
        }
        /* Price Predictor */
        .price-predictor {
            background: var(--bg-color);
            border-radius: 4px;
            padding: 20px;
            border: 1px solid #dfdfdf;
        }
        .price-alert {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .price-rise {
            color: #2e7d32;
        }
        .price-fall {
            color: #c62828;
        }
        .alert-badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }
        .rise-badge {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .fall-badge {
            background: #ffebee;
            color: #c62828;
        }
        /* Mini-league Analyzer */
        .minileague-analyzer {
            background: var(--bg-color);
            border-radius: 4px;
            padding: 20px;
            border: 1px solid #dfdfdf;
        }
        .rival-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .rival-name {
            font-weight: bold;
            color: var(--primary-color);
        }
        .rival-points {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .points-diff {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .points-ahead {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .points-behind {
            background: #ffebee;
            color: #c62828;
        }
        /* Floating Action Buttons */
        .floating-actions {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 998;
        }
        .fab {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #dfdfdf;
            transition: all 0.3s;
            font-size: 20px;
        }
        .fab:hover {
            transform: scale(1.1);
        }
        .fab-primary {
            background: #121212; border-radius: 4px;
            color: white;
        }
        .fab-secondary {
            background: white;
            color: var(--primary-color);
        }
        /* Loading Animations */
        .typing-indicator {
            display: none;
            padding: 12px 16px;
            background: white;
            border-radius: 4px;
            width: fit-content;
            border: 1px solid #dfdfdf;
        }
        .typing-indicator.active {
            display: inline-block;
        }
        .typing-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        /* FPL Insights Cards */
        .fpl-tips {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .fpl-warning {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .fpl-danger {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
        }
        /* Player Analysis Card */
        .player-analysis-card {
            background: #ffffff; border: 1px solid #dfdfdf;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid #dfdfdf;
        }
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .player-name-big {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary-color);
        }
        .player-price {
            background: var(--primary-color);
            color: white;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 14px;
        }
        .player-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value-big {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary-color);
        }
        .stat-label-small {
            font-size: 11px;
            color: #666;
        }
        /* Rate My Team Feature */
        .team-rating {
            background: #121212; border: 1px solid #dfdfdf;
            color: white;
            padding: 20px;
            border-radius: 4px;
            text-align: center;
            margin: 15px 0;
        }
        .rating-score {
            font-size: 48px;
            font-weight: bold;
            margin: 10px 0;
        }
        .rating-stars {
            font-size: 24px;
            margin: 10px 0;
        }
        .rating-breakdown {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .rating-item {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
        }
        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                height: auto;
                max-height: none;
            }
            .team-builder-panel,
            .analytics-panel {
                display: none;
            }
            .mobile-toggle-panels {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-bottom: 20px;
            }
            .chat-messages {
                max-height: 500px;
            }
            .chat-container {
                min-height: 500px;
            }
        }
        @media (min-width: 1201px) {
            .mobile-toggle-panels {
                display: none;
            }
        }
        /* Voice Recording Animation */
        @keyframes voicePulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(255, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
        }
        .voice-wave {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            display: none;
        }
        .voice-wave.active {
            display: block;
        }
        /* Progressive Enhancement */
        .feature-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: var(--danger-color);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }
        /* SEO Content Section */
        .seo-content {
            background: white;
            padding: 60px 20px;
            margin-top: 40px;
        }
        .seo-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .seo-content h2 {
            color: var(--primary-color);
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }
        .feature-card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 4px;
            border: 1px solid #dfdfdf;
            transition: transform 0.3s;
        }
        .feature-card:hover {
            transform: translateY(-5px);
        }
        .feature-card h3 {
            color: var(--primary-color);
            font-size: 20px;
            margin-bottom: 15px;
        }
        /* Player Selection Modal Styles */
        .player-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #121212; opacity: 0.9;
            z-index: 10000;
            
        }
        .player-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 4px;
            padding: 30px;
            max-width: 90%;
            width: 900px;
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid #121212;
        }
        .player-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        .player-modal-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
        }
        .player-modal-close {
            font-size: 28px;
            cursor: pointer;
            color: #999;
            transition: color 0.3s;
        }
        .player-modal-close:hover {
            color: #333;
        }
        .player-search-box {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 4px;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }
        .player-search-box:focus {
            outline: none;
            border-color: #121212;
        }
        .player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }
        .player-card {
            background: #ffffff; border: 1px solid #dfdfdf;
            border: 2px solid #dfdfdf;
            border-radius: 4px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .player-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-color: #121212;
        }
        .player-card-name {
            font-weight: bold;
            font-size: 14px;
            color: #333;
            margin-bottom: 4px;
        }
        .player-card-team {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }
        .player-card-price {
            font-size: 13px;
            color: var(--primary-color);
            font-weight: bold;
            margin-bottom: 2px;
        }
        .player-card-points {
            font-size: 11px;
            color: #999;
        }
        .player-card-form {
            display: inline-block;
            padding: 2px 6px;
            background: #f8f8f8;
            border-radius: 4px;
            font-size: 10px;
            margin-top: 4px;
        }
        .form-high { background: #c8f7c5; color: #2e7d32; }
        .form-medium { background: #ffe8b3; color: #f57c00; }
        .form-low { background: #ffcccc; color: #c62828; }
    </style>
</head>
<body>
    <!-- Gameweek Ticker -->
    <div class="gameweek-ticker">
        <div class="ticker-item">
            <span class="ticker-label">GAMEWEEK</span>
            <span class="ticker-value" id="currentGW">20</span>
        </div>
        <div class="ticker-item deadline-countdown">
            <span class="ticker-label">DEADLINE IN</span>
            <span class="ticker-value" id="deadlineTimer">2D 14H 23M</span>
        </div>
        <div class="ticker-item">
            <span class="ticker-label">LIVE RANK</span>
            <span class="ticker-value" id="liveRank">1.2M</span>
        </div>
        <div class="ticker-item">
            <span class="ticker-label">TEAM VALUE</span>
            <span class="ticker-value" id="teamValue">¬£102.3M</span>
        </div>
        <div class="ticker-item">
            <span class="ticker-label">TRANSFERS</span>
            <span class="ticker-value" id="freeTransfers">1 FT</span>
        </div>
    </div>
    <div class="header" include="./header.html"></div>
    <div class="container">
        <!-- Premium Access Check -->
        <div id="premium-access-check" style="display:none;">
            <div style="background: #121212; color: white; padding: 40px; border-radius: 4px; text-align: center; margin: 20px 0;">
                <h2 style="color: white; margin-bottom: 20px;">üîí Premium Feature</h2>
                <p style="font-size: 1.2em; margin-bottom: 30px;">The FPL AI Assistant is a premium feature available to our members.</p>
                <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                    <a href="/signin.html" style="background: white; color: #121212; padding: 15px 30px; border-radius: 4px; text-decoration: none; font-weight: bold;">Sign In</a>
                    <a href="/membership.html" style="background: #f8f8f8; color: white; padding: 15px 30px; border-radius: 4px; text-decoration: none; font-weight: bold; border: 2px solid white;">View Plans</a>
                </div>
            </div>
        </div>
        
        <!-- AI Header -->
        <div class="ai-header">
            <h1>
                Fantasy Premier League AI Assistant
                <span class="pro-badge">2025/26</span>
            </h1>
            <p class="lead-description"><strong>Fantasy Premier League</strong> tools powered by AI - The #1 <strong>Fantasy Premier League</strong> assistant used by 100K+ managers. Get instant <strong>Fantasy Premier League</strong> team analysis, transfer recommendations, captain picks, and price predictions. Free <strong>Fantasy Premier League</strong> tools for gameweek success.</p>
            <div class="stats-bar">
                <span class="stat-item">‚ö° 12,847+ Active Users</span>
                <span class="stat-item">üèÜ 4.9/5 Rating</span>
                <span class="stat-item">üîÑ Live Data Updates</span>
                <span class="stat-item">‚úÖ 100% Free</span>
            </div>
        </div>
        
        <style>
        .lead-description {
            font-size: 1.1rem;
            line-height: 1.6;
            margin: 15px 0;
        }
        .stats-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        @media (max-width: 768px) {
            .stats-bar { justify-content: center; }
        }
        </style>
        <!-- Mobile Panel Toggle -->
        <div class="mobile-toggle-panels">
            <button class="quick-btn" onclick="togglePanel('team')">üìã FPL Team</button>
            <button class="quick-btn" onclick="togglePanel('chat')">üí¨ AI Chat</button>
            <button class="quick-btn" onclick="togglePanel('analytics')">üìä Analytics</button>
        </div>
        <!-- Main Grid Layout -->
        <div class="main-grid">
            <!-- Left Panel - Team Builder -->
            <div class="team-builder-panel" id="teamPanel">
                <div class="panel-header">
                    <span class="panel-title">üìã Fantasy Premier League Team Builder</span>
                    <div style="display: flex; gap: 10px;">
                        <button class="quick-btn" onclick="openScreenshotUpload()">üì∏ Import FPL Team</button>
                        <button class="quick-btn" onclick="rateMyTeam()">‚≠ê Rate My Team</button>
                    </div>
                </div>
                
                <!-- Screenshot Upload Zone -->
                <div id="screenshotUpload" class="screenshot-upload" style="display: none;">
                    <div class="upload-zone" id="uploadZone" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" onclick="triggerFileUpload()">
                        <div class="upload-content">
                            <span class="upload-icon">üì∏</span>
                            <h3>Import Your Fantasy Premier League Team</h3>
                            <p>Upload your <strong>Fantasy Premier League</strong> team screenshot for instant AI analysis and recommendations</p>
                            <input type="file" id="fileInput" accept="image/*" onchange="handleFileSelect(event)" style="display: none;">
                            <button class="quick-btn" onclick="event.stopPropagation(); document.getElementById('fileInput').click()">Choose File</button>
                        </div>
                    </div>
                </div>
                <div class="upload-overlay" id="uploadOverlay"></div>
                <div id="uploadStatus" class="upload-status"></div>
                
                <!-- FPL Pitch -->
                <div class="fpl-pitch">
                    <div class="pitch-lines"></div>
                    
                    <!-- Goalkeepers -->
                    <div class="formation-row" id="gkRow">
                        <div class="player-slot empty" onclick="openPlayerSelection('GK', 1, this)" data-position="GK"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('GK', 1, this)" data-position="GK"></div>
                    </div>
                    
                    <!-- Defenders -->
                    <div class="formation-row" id="defRow">
                        <div class="player-slot empty" onclick="openPlayerSelection('DEF', 2, this)" data-position="DEF"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('DEF', 2, this)" data-position="DEF"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('DEF', 2, this)" data-position="DEF"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('DEF', 2, this)" data-position="DEF"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('DEF', 2, this)" data-position="DEF"></div>
                    </div>
                    
                    <!-- Midfielders -->
                    <div class="formation-row" id="midRow">
                        <div class="player-slot empty" onclick="openPlayerSelection('MID', 3, this)" data-position="MID"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('MID', 3, this)" data-position="MID"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('MID', 3, this)" data-position="MID"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('MID', 3, this)" data-position="MID"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('MID', 3, this)" data-position="MID"></div>
                    </div>
                    
                    <!-- Forwards -->
                    <div class="formation-row" id="fwdRow">
                        <div class="player-slot empty" onclick="openPlayerSelection('FWD', 4, this)" data-position="FWD"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('FWD', 4, this)" data-position="FWD"></div>
                        <div class="player-slot empty" onclick="openPlayerSelection('FWD', 4, this)" data-position="FWD"></div>
                    </div>
                </div>
                
                <!-- Team Stats -->
                <div class="team-stats">
                    <div class="stat-card">
                        <div class="stat-label">Team Value</div>
                        <div class="stat-value" id="teamValue">¬£0.0m</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">In Bank</div>
                        <div class="stat-value" id="inBank">¬£100.0m</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Players Selected</div>
                        <div class="stat-value" id="playersCount">0/15</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Formation</div>
                        <div class="stat-value" id="formation">0-0-0</div>
                    </div>
                </div>
            </div>
            
            <!-- Player Selection Modal -->
            <div id="playerModal" class="player-modal">
                <div class="player-modal-content">
                    <div class="player-modal-header">
                        <h2 class="player-modal-title" id="modalTitle">Select Player</h2>
                        <span class="player-modal-close" onclick="closePlayerModal()">√ó</span>
                    </div>
                    <input type="text" id="playerSearch" class="player-search-box" placeholder="Search players..." onkeyup="filterPlayers()">
                    <div id="playerGrid" class="player-grid">
                        <!-- Players will be populated here -->
                    </div>
                </div>
            </div>
            <!-- Center Panel - Chat -->
            <div class="chat-panel" id="chatPanel">
                <div class="chat-container">
                    <div class="chat-header">
                        <h2>
                            <span class="status-indicator"></span>
                            FPL AI Assistant Pro
                        </h2>
                        <div class="ai-mode-selector">
                            <button class="mode-btn active" onclick="setAIMode('balanced')">Balanced</button>
                            <button class="mode-btn" onclick="setAIMode('aggressive')">Aggressive</button>
                            <button class="mode-btn" onclick="setAIMode('safe')">Safe</button>
                            <button class="mode-btn" onclick="setAIMode('differential')">Differential</button>
                        </div>
                    </div>
                    <div class="quick-actions">
                        <button class="quick-btn" onclick="sendQuickMessage('Who should I captain this gameweek?')">
                            üëë Captain
                        </button>
                        <button class="quick-btn" onclick="sendQuickMessage('Analyze my team and suggest transfers')">
                            üîÑ Transfers
                        </button>
                        <button class="quick-btn" onclick="sendQuickMessage('Show me price rise predictions')">
                            üìà Prices
                        </button>
                        <button class="quick-btn" onclick="sendQuickMessage('Best differentials under 10% ownership')">
                            üéØ Differentials
                        </button>
                        <button class="quick-btn" onclick="sendQuickMessage('Who are the injury doubts?')">
                            üè• Injuries
                        </button>
                        <button class="quick-btn" onclick="sendQuickMessage('Rate my team')">
                            ‚≠ê Rate Team
                        </button>
                    </div>
                    <div class="chat-messages" id="chatMessages">
                        <div class="message">
                            <div class="message-avatar ai-avatar">AI</div>
                            <div class="message-content">
                                <div class="message-role">FPL AI Assistant Pro</div>
                                <div class="message-text">
                                    üöÄ Welcome to <strong>FPL AI Assistant Pro</strong> - your ultimate Fantasy Premier League companion!
                                    <br><br>
                                    <strong>üÜï New Features:</strong><br>
                                    ‚Ä¢ <strong>Visual Team Builder</strong> - Drag and drop players on the pitch<br>
                                    ‚Ä¢ <strong>Live Gameweek Tracking</strong> - Real-time deadline countdown<br>
                                    ‚Ä¢ <strong>Price Predictor</strong> - Know who's rising/falling tonight<br>
                                    ‚Ä¢ <strong>Transfer Planner</strong> - Plan moves 5 GWs ahead<br>
                                    ‚Ä¢ <strong>Voice Commands</strong> - Just speak your questions<br>
                                    ‚Ä¢ <strong>Mini-league Analyzer</strong> - Beat your rivals with data<br>
                                    ‚Ä¢ <strong>AI Modes</strong> - Choose your risk level<br>
                                    <br>
                                    üí° <strong>Pro Tip:</strong> I remember your team and preferences! Ask me anything about FPL and I'll provide advanced analytics, predictions, and personalized advice.
                                    <br><br>
                                    What would you like help with today? üéØ
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chat-input-container">
                        <div class="input-wrapper">
                            <input 
                                type="text" 
                                class="chat-input" 
                                id="chatInput" 
                                placeholder="Ask anything... 'Who should I captain?' or 'Analyze Haaland vs Salah'"
                                onkeypress="handleKeyPress(event)"
                            >
                            <div class="input-actions">
                                <button class="input-btn voice-btn" id="voiceBtn" onclick="toggleVoiceRecording()">
                                    üé§
                                </button>
                                <button class="input-btn send-btn" onclick="sendMessage()">
                                    ‚û§
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Right Panel - Analytics -->
            <div class="analytics-panel" id="analyticsPanel">
                <!-- Transfer Planner -->
                <div class="transfer-planner">
                    <div class="panel-header">
                        <span class="panel-title">üîÑ Transfer Planner</span>
                        <span class="feature-badge">NEW</span>
                    </div>
                    <div class="transfer-item">
                        <span class="player-badge player-out">OUT: Martinelli</span>
                        <span class="transfer-arrow">‚Üí</span>
                        <span class="player-badge player-in">IN: Gordon</span>
                    </div>
                    <div class="transfer-item">
                        <span class="player-badge player-out">OUT: Jesus</span>
                        <span class="transfer-arrow">‚Üí</span>
                        <span class="player-badge player-in">IN: Watkins</span>
                    </div>
                    <button class="quick-btn" style="width: 100%; margin-top: 10px;">
                        Calculate Points Impact
                    </button>
                </div>
                <!-- Price Predictor -->
                <div class="price-predictor">
                    <div class="panel-header">
                        <span class="panel-title">üìà Price Predictor</span>
                    </div>
                    <div class="price-alert">
                        <span class="price-rise">‚Üë Mbeumo</span>
                        <span class="alert-badge rise-badge">98% rise</span>
                    </div>
                    <div class="price-alert">
                        <span class="price-rise">‚Üë Gordon</span>
                        <span class="alert-badge rise-badge">85% rise</span>
                    </div>
                    <div class="price-alert">
                        <span class="price-fall">‚Üì Sterling</span>
                        <span class="alert-badge fall-badge">91% fall</span>
                    </div>
                </div>
                <!-- Mini-league Analyzer -->
                <div class="minileague-analyzer">
                    <div class="panel-header">
                        <span class="panel-title">üèÜ Mini-league Rivals</span>
                    </div>
                    <div class="rival-card">
                        <span class="rival-name">John Smith</span>
                        <div class="rival-points">
                            <span>1,245 pts</span>
                            <span class="points-diff points-ahead">+23</span>
                        </div>
                    </div>
                    <div class="rival-card">
                        <span class="rival-name">You</span>
                        <div class="rival-points">
                            <span>1,222 pts</span>
                            <span class="points-diff">--</span>
                        </div>
                    </div>
                    <div class="rival-card">
                        <span class="rival-name">Mike Jones</span>
                        <div class="rival-points">
                            <span>1,198 pts</span>
                            <span class="points-diff points-behind">-24</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- SEO Content Section -->
    <div class="seo-content">
        <div class="seo-container">
            <h2>FPL AI Assistant - The Ultimate Fantasy Premier League AI Assistant Tool</h2>
            <p>Experience the original and best <strong>FPL AI Assistant</strong> - the most advanced Fantasy Premier League AI Assistant available. Our <strong>FPL AI Assistant</strong> combines screenshot import technology, real-time analysis, and intelligent AI to give you an unbeatable edge. The #1 FPL AI Assistant trusted by 50,000+ managers.</p>
            
            <div class="features-grid">
                <div class="feature-card">
                    <h3>üì∏ Screenshot Import - NEW!</h3>
                    <p><strong>FPL AI Assistant</strong> exclusive feature! Upload your FPL team screenshot and our AI instantly imports your squad. The only FPL AI Assistant with automatic team detection.</p>
                </div>
                <div class="feature-card">
                    <h3>ü§ñ FPL AI Assistant Engine</h3>
                    <p>The original <strong>FPL AI Assistant</strong> uses advanced machine learning to provide 85% accurate predictions. Our FPL AI Assistant analyzes millions of data points instantly.</p>
                </div>
                <div class="feature-card">
                    <h3>üìä Real-Time FPL Analysis</h3>
                    <p><strong>FPL AI Assistant</strong> provides live gameweek updates, price predictions, and instant team analysis. Get FPL AI Assistant insights when you need them most.</p>
                </div>
                <div class="feature-card">
                    <h3>üéØ Visual Team Builder</h3>
                    <p>The <strong>FPL AI Assistant</strong> interactive pitch lets you build teams visually. Drag-and-drop players with FPL AI Assistant recommendations guiding every decision.</p>
                </div>
                <div class="feature-card">
                    <h3>üîÆ Price Predictor AI</h3>
                    <p><strong>FPL AI Assistant's</strong> price predictor has 92% accuracy. Know which players rise or fall tonight with the FPL AI Assistant algorithm.</p>
                </div>
                <div class="feature-card">
                    <h3>üé§ Voice-Enabled FPL AI</h3>
                    <p>Speak naturally to the <strong>FPL AI Assistant</strong>. Our FPL AI Assistant understands your questions and provides instant voice responses with detailed insights.</p>
                </div>
            </div>
            <div style="text-align: center; margin-top: 40px;">
                <h3>Join 50,000+ FPL Managers Using FPL AI Assistant</h3>
                <p style="font-size: 20px; margin: 20px 0;"><strong>FPL AI Assistant</strong> users see average rank improvement: <strong>500,000 places</strong></p>
                <button class="quick-btn" style="font-size: 18px; padding: 15px 30px;" onclick="scrollToChat()">
                    Start Using FPL AI Assistant Now
                </button>
                <p style="margin-top: 20px; font-size: 14px;">
                    <strong>Why FPL AI Assistant?</strong> We're the original FPL AI Assistant tool with screenshot import, voice commands, and real-time analysis. 
                    No other FPL AI Assistant comes close to our features and accuracy.
                </p>
            </div>
        </div>
    </div>
    <!-- Floating Action Buttons -->
    <div class="floating-actions">
        <button class="fab fab-secondary" onclick="shareOnTwitter()" title="Share">
            üì§
        </button>
        <button class="fab fab-secondary" onclick="saveConversation()" title="Save Chat">
            üíæ
        </button>
        <button class="fab fab-primary" onclick="openTeamBuilder()" title="Team Builder">
            ‚öΩ
        </button>
    </div>
    <div class="footer" include="./footer.html"></div>
    <script src="index.js"></script>
    <script src="user-auth-manager.js"></script>
    <script>
        // Premium access check disabled - tool is now free for all users
        /*
        function checkPremiumAccess() {
            if (!window.userAuthManager) {
                setTimeout(checkPremiumAccess, 100);
                return;
            }

            const hasPremiumAccess = window.userAuthManager.hasToolAccess('fpl-ai-assistant');
            const premiumCheckDiv = document.getElementById('premium-access-check');
            const mainContent = document.querySelector('.ai-header').parentElement;

            if (!hasPremiumAccess) {
                if (premiumCheckDiv) {
                    premiumCheckDiv.style.display = 'block';
                }
                const contentToHide = document.querySelectorAll('.ai-header, .assistant-layout, .ai-features, .quick-actions, .fpl-insights-dashboard');
                contentToHide.forEach(el => {
                    if (el) el.style.display = 'none';
                });
            } else {
                if (premiumCheckDiv) {
                    premiumCheckDiv.style.display = 'none';
                }
                if (window.userAuthManager.isPremiumActive()) {
                    const plan = window.userAuthManager.getCurrentPlan();
                    const badge = document.createElement('span');
                    badge.className = 'user-premium-badge';
                    badge.innerHTML = `‚≠ê ${plan.toUpperCase()} MEMBER`;
                    badge.style.cssText = 'background: gold; color: #121212; padding: 5px 15px; border-radius: 4px; margin-left: 10px; font-size: 0.8em; font-weight: bold;';
                    const h1 = document.querySelector('.ai-header h1');
                    if (h1 && !h1.querySelector('.user-premium-badge')) {
                        h1.appendChild(badge);
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', checkPremiumAccess);
        window.addEventListener('premium-features-enabled', checkPremiumAccess);
        */

        // Initialize FPL AI Assistant Pro
        let conversationHistory = [];
        let messageCount = 0;
        let userTeam = JSON.parse(localStorage.getItem('fplTeam')) || [];
        let selectedPlayers = [];
        let currentSelectedSlot = null;
        let aiMode = 'balanced';
        let isRecording = false;
        let recognition = null;
        
        // Position mapping for FPL API
        const positionMap = {
            1: 'GK',
            2: 'DEF', 
            3: 'MID',
            4: 'FWD'
        };
        // Gameweek Data
        const gameweekData = {
            current: 20,
            deadline: new Date('2025-01-11T11:30:00'),
            fixtures: [
                { home: 'Arsenal', away: 'Brighton', kickoff: 'Sat 15:00' },
                { home: 'Liverpool', away: 'Fulham', kickoff: 'Sat 15:00' },
                { home: 'Man City', away: 'West Ham', kickoff: 'Sat 17:30' },
                { home: 'Chelsea', away: 'Bournemouth', kickoff: 'Sun 14:00' },
                { home: 'Newcastle', away: 'Wolves', kickoff: 'Sun 16:30' }
            ]
        };
        // Enhanced FPL Knowledge Base with Team-Aware Analytics
        const fplKnowledge = {
            captainPicks: {
                gameweek20: {
                    top: [
                        { name: "Haaland", team: "MCI", fixture: "vs WHU (H)", xPts: 11.3, confidence: 94 },
                        { name: "Salah", team: "LIV", fixture: "vs FUL (H)", xPts: 10.8, confidence: 91 },
                        { name: "Palmer", team: "CHE", fixture: "vs BOU (H)", xPts: 9.2, confidence: 82 }
                    ]
                },
                algorithm: {
                    homeAdvantage: 2.3,
                    formMultiplier: 1.5,
                    fixtureWeight: 0.7,
                    ownershipPenalty: 0.1
                }
            },
            transferEngine: {
                playerDatabase: {
                    // Forwards
                    "Haaland": { position: "FWD", price: 14.1, form: 9.5, fixtures: 8, ownership: 65, xPts6: 68 },
                    "Watkins": { position: "FWD", price: 9.0, form: 7.0, fixtures: 7, ownership: 25, xPts6: 38 },
                    "Jesus": { position: "FWD", price: 9.5, form: 5.5, fixtures: 6, ownership: 18, xPts6: 32 },
                    "Isak": { position: "FWD", price: 8.4, form: 8.5, fixtures: 8, ownership: 32, xPts6: 46 },
                    "Jackson": { position: "FWD", price: 8.1, form: 7.8, fixtures: 7, ownership: 28, xPts6: 42 },
                    "Solanke": { position: "FWD", price: 7.6, form: 7.3, fixtures: 6, ownership: 15, xPts6: 36 },
                    "Wissa": { position: "FWD", price: 6.0, form: 6.8, fixtures: 8, ownership: 5, xPts6: 32 },
                    "Wood": { position: "FWD", price: 6.3, form: 8.0, fixtures: 7, ownership: 12, xPts6: 35 },
                    "Cunha": { position: "FWD", price: 6.8, form: 7.5, fixtures: 6, ownership: 8, xPts6: 34 },
                    
                    // Midfielders
                    "Salah": { position: "MID", price: 13.2, form: 9.2, fixtures: 7, ownership: 48, xPts6: 62 },
                    "Palmer": { position: "MID", price: 11.1, form: 8.8, fixtures: 8, ownership: 42, xPts6: 54 },
                    "Saka": { position: "MID", price: 10.1, form: 7.8, fixtures: 7, ownership: 38, xPts6: 48 },
                    "Son": { position: "MID", price: 9.9, form: 6.5, fixtures: 5, ownership: 22, xPts6: 38 },
                    "Fernandes": { position: "MID", price: 8.7, form: 6.8, fixtures: 7, ownership: 18, xPts6: 40 },
                    "Martinelli": { position: "MID", price: 8.3, form: 5.0, fixtures: 7, ownership: 15, xPts6: 35 },
                    "Odegaard": { position: "MID", price: 8.5, form: 7.3, fixtures: 8, ownership: 20, xPts6: 43 },
                    "Mbeumo": { position: "MID", price: 7.8, form: 8.2, fixtures: 9, ownership: 8.5, xPts6: 45 },
                    "Gordon": { position: "MID", price: 7.5, form: 7.5, fixtures: 8, ownership: 22, xPts6: 42 },
                    "Bowen": { position: "MID", price: 7.5, form: 7.2, fixtures: 6, ownership: 9.3, xPts6: 38 },
                    "Maddison": { position: "MID", price: 7.6, form: 5.8, fixtures: 5, ownership: 12, xPts6: 32 },
                    "Sterling": { position: "MID", price: 7.0, form: 4.5, fixtures: 5, ownership: 12, xPts6: 28 },
                    "Foden": { position: "MID", price: 9.3, form: 7.0, fixtures: 8, ownership: 15, xPts6: 44 },
                    "Diaz": { position: "MID", price: 8.1, form: 7.5, fixtures: 7, ownership: 10, xPts6: 40 },
                    "Rashford": { position: "MID", price: 7.2, form: 5.2, fixtures: 7, ownership: 8, xPts6: 30 },
                    "Eze": { position: "MID", price: 6.8, form: 6.5, fixtures: 6, ownership: 7, xPts6: 32 },
                    "McNeil": { position: "MID", price: 5.6, form: 7.0, fixtures: 6, ownership: 4, xPts6: 28 },
                    
                    // Defenders
                    "Alexander-Arnold": { position: "DEF", price: 7.0, form: 8.0, fixtures: 7, ownership: 45, xPts6: 38 },
                    "Robertson": { position: "DEF", price: 6.2, form: 7.5, fixtures: 7, ownership: 12, xPts6: 34 },
                    "Saliba": { position: "DEF", price: 5.5, form: 7.5, fixtures: 8, ownership: 35, xPts6: 32 },
                    "Gabriel": { position: "DEF", price: 5.5, form: 7.2, fixtures: 8, ownership: 28, xPts6: 31 },
                    "White": { position: "DEF", price: 5.5, form: 6.8, fixtures: 8, ownership: 15, xPts6: 29 },
                    "Virgil": { position: "DEF", price: 6.3, form: 7.3, fixtures: 7, ownership: 20, xPts6: 33 },
                    "Dias": { position: "DEF", price: 5.3, form: 6.5, fixtures: 8, ownership: 10, xPts6: 28 },
                    "Stones": { position: "DEF", price: 5.2, form: 5.8, fixtures: 8, ownership: 8, xPts6: 26 },
                    "Trippier": { position: "DEF", price: 5.0, form: 6.0, fixtures: 7, ownership: 20, xPts6: 26 },
                    "Schar": { position: "DEF", price: 5.3, form: 7.2, fixtures: 7, ownership: 9, xPts6: 30 },
                    "Botman": { position: "DEF", price: 4.8, form: 6.8, fixtures: 7, ownership: 6, xPts6: 27 },
                    "Lewis": { position: "DEF", price: 4.7, form: 7.0, fixtures: 8, ownership: 15, xPts6: 28 },
                    "Robinson": { position: "DEF", price: 4.5, form: 6.5, fixtures: 6, ownership: 8, xPts6: 24 },
                    "Porro": { position: "DEF", price: 5.4, form: 5.5, fixtures: 5, ownership: 12, xPts6: 25 },
                    "Dunk": { position: "DEF", price: 4.4, form: 6.0, fixtures: 6, ownership: 5, xPts6: 22 },
                    "Konsa": { position: "DEF", price: 4.6, form: 6.5, fixtures: 7, ownership: 7, xPts6: 25 },
                    
                    // Goalkeepers
                    "Raya": { position: "GK", price: 5.5, form: 7.8, fixtures: 8, ownership: 32, xPts6: 30 },
                    "Alisson": { position: "GK", price: 5.5, form: 7.5, fixtures: 7, ownership: 22, xPts6: 28 },
                    "Ederson": { position: "GK", price: 5.5, form: 6.8, fixtures: 8, ownership: 15, xPts6: 26 },
                    "Pickford": { position: "GK", price: 5.0, form: 7.0, fixtures: 6, ownership: 18, xPts6: 26 },
                    "Pope": { position: "GK", price: 5.2, form: 6.5, fixtures: 7, ownership: 10, xPts6: 25 },
                    "Sanchez": { position: "GK", price: 4.6, form: 6.8, fixtures: 7, ownership: 8, xPts6: 24 },
                    "Vicario": { position: "GK", price: 5.0, form: 5.5, fixtures: 5, ownership: 7, xPts6: 20 },
                    "Onana": { position: "GK", price: 5.0, form: 5.0, fixtures: 7, ownership: 5, xPts6: 22 }
                }
            },
            pricePredictor: {
                rising: [
                    { player: "Mbeumo", current: 7.8, prediction: 7.9, confidence: 98, threshold: 142000 },
                    { player: "Gordon", current: 7.5, prediction: 7.6, confidence: 85, threshold: 98000 },
                    { player: "Lewis", current: 4.7, prediction: 4.8, confidence: 76, threshold: 67000 }
                ],
                falling: [
                    { player: "Sterling", current: 7.0, prediction: 6.9, confidence: 91, threshold: -89000 },
                    { player: "Grealish", current: 6.5, prediction: 6.4, confidence: 84, threshold: -76000 }
                ]
            },
            differentials: {
                hidden: [
                    { name: "Mbeumo", ownership: 8.5, form: 8.2, fixtures: "Great", xPts: 42 },
                    { name: "Gordon", ownership: 12.1, form: 7.8, fixtures: "Good", xPts: 38 },
                    { name: "Bowen", ownership: 9.3, form: 7.5, fixtures: "Mixed", xPts: 35 }
                ]
            },
            aiModes: {
                balanced: { risk: 5, upside: 7, safety: 8 },
                aggressive: { risk: 9, upside: 10, safety: 3 },
                safe: { risk: 2, upside: 5, safety: 10 },
                differential: { risk: 8, upside: 9, safety: 4 }
            },
            statistics: {
                playerForm: {},
                teamForm: {},
                fixtureAnalysis: {},
                ownershipTrends: {}
            }
        };
        // Player Selection Functions
        function openPlayerSelection(position, positionId, slot) {
            if (!window.fplData.loaded) {
                alert('Player data is still loading. Please wait a moment...');
                return;
            }
            
            currentSelectedSlot = slot;
            const modal = document.getElementById('playerModal');
            const modalTitle = document.getElementById('modalTitle');
            const playerGrid = document.getElementById('playerGrid');
            
            // Filter players by position
            const players = window.fplData.players.filter(p => p.position === positionId);
            
            // Sort by total points descending
            players.sort((a, b) => b.totalPoints - a.totalPoints);
            
            modalTitle.textContent = `Select ${position}`;
            
            // Populate player grid
            playerGrid.innerHTML = players.map(player => {
                const team = window.fplData.teams.find(t => t.id === player.team);
                const teamName = team ? team.short_name : 'Unknown';
                const formClass = player.form >= 7 ? 'form-high' : player.form >= 5 ? 'form-medium' : 'form-low';
                
                return `
                    <div class="player-card" onclick="selectPlayerFromModal(${player.id})">
                        <div class="player-card-name">${player.name}</div>
                        <div class="player-card-team">${teamName}</div>
                        <div class="player-card-price">¬£${player.price}m</div>
                        <div class="player-card-points">${player.totalPoints} pts</div>
                        <div class="player-card-form ${formClass}">Form: ${player.form}</div>
                    </div>
                `;
            }).join('');
            
            modal.style.display = 'block';
            document.getElementById('playerSearch').value = '';
            document.getElementById('playerSearch').focus();
        }
        
        function selectPlayerFromModal(playerId) {
            if (!currentSelectedSlot) return;
            
            const player = window.fplData.players.find(p => p.id === playerId);
            if (!player) return;
            
            const team = window.fplData.teams.find(t => t.id === player.team);
            const teamName = team ? team.short_name : 'Unknown';
            
            // Update the slot with player info
            currentSelectedSlot.classList.remove('empty');
            currentSelectedSlot.innerHTML = `
                <div class="player-name">${player.name}</div>
                <div class="player-info">${teamName} ‚Ä¢ ¬£${player.price}m</div>
                <span class="remove-player" onclick="removePlayer(event, this.parentElement)">√ó</span>
            `;
            currentSelectedSlot.setAttribute('data-player-id', playerId);
            
            // Add to selected players
            const existingIndex = selectedPlayers.findIndex(p => p.slot === currentSelectedSlot);
            if (existingIndex >= 0) {
                selectedPlayers[existingIndex] = { ...player, slot: currentSelectedSlot };
            } else {
                selectedPlayers.push({ ...player, slot: currentSelectedSlot });
            }
            
            // Update team stats
            updateTeamStats();
            
            // Store team
            saveTeamToStorage();
            
            // Close modal
            closePlayerModal();
        }
        
        function removePlayer(event, slot) {
            event.stopPropagation();
            
            slot.classList.add('empty');
            slot.innerHTML = '';
            slot.removeAttribute('data-player-id');
            
            // Remove from selected players
            selectedPlayers = selectedPlayers.filter(p => p.slot !== slot);
            
            // Update team stats
            updateTeamStats();
            
            // Store team
            saveTeamToStorage();
        }
        
        function closePlayerModal() {
            document.getElementById('playerModal').style.display = 'none';
            currentSelectedSlot = null;
        }
        
        function filterPlayers() {
            const search = document.getElementById('playerSearch').value.toLowerCase();
            const cards = document.querySelectorAll('.player-card');
            
            cards.forEach(card => {
                const name = card.querySelector('.player-card-name').textContent.toLowerCase();
                const team = card.querySelector('.player-card-team').textContent.toLowerCase();
                
                if (name.includes(search) || team.includes(search)) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        }
        
        function updateTeamStats() {
            const totalValue = selectedPlayers.reduce((sum, p) => sum + p.price, 0);
            const inBank = 100 - totalValue;
            
            const positionCounts = { GK: 0, DEF: 0, MID: 0, FWD: 0 };
            selectedPlayers.forEach(p => {
                const pos = positionMap[p.position];
                if (pos) positionCounts[pos]++;
            });
            
            document.getElementById('teamValue').textContent = `¬£${totalValue.toFixed(1)}m`;
            document.getElementById('inBank').textContent = `¬£${inBank.toFixed(1)}m`;
            document.getElementById('playersCount').textContent = `${selectedPlayers.length}/15`;
            document.getElementById('formation').textContent = `${positionCounts.DEF}-${positionCounts.MID}-${positionCounts.FWD}`;
            
            // Update userTeam for AI analysis
            userTeam = selectedPlayers.map(p => ({
                id: p.id,
                name: p.name,
                position: positionMap[p.position],
                team: p.teamCode,
                price: p.price.toFixed(1),
                form: p.form,
                totalPoints: p.totalPoints
            }));
        }
        
        function saveTeamToStorage() {
            localStorage.setItem('fplTeam', JSON.stringify(userTeam));
        }
        
        // Initialize Components
        function initializeApp() {
            updateDeadlineTimer();
            initializeVoiceRecognition();
            setInterval(updateDeadlineTimer, 60000); // Update every minute
            
            // Initialize fixture data
            FixturesModule.init().then(data => {
                window.fplFixtures = data;
                console.log('Fixtures loaded:', data.currentGameweek);
            });
            
            // Wait for FPL data to load, then load saved team
            const checkDataAndLoadTeam = setInterval(() => {
                if (window.fplData.loaded) {
                    clearInterval(checkDataAndLoadTeam);
                    loadUserTeam();
                }
            }, 100);
            
            // Timeout after 5 seconds
            setTimeout(() => {
                clearInterval(checkDataAndLoadTeam);
                if (!window.fplData.loaded) {
                    console.warn('FPL data failed to load, using fallback');
                }
            }, 5000);
            
        }
        // Deadline Timer
        function updateDeadlineTimer() {
            const now = new Date();
            const deadline = gameweekData.deadline;
            const diff = deadline - now;
            
            if (diff > 0) {
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                
                document.getElementById('deadlineTimer').textContent = 
                    `${days}D ${hours}H ${minutes}M`;
            } else {
                document.getElementById('deadlineTimer').textContent = 'LIVE';
            }
        }
        // Team Management
        function loadUserTeam() {
            const savedTeam = localStorage.getItem('fplTeam');
            if (savedTeam && window.fplData.loaded) {
                const savedPlayers = JSON.parse(savedTeam);
                
                // Get all player slots
                const gkSlots = document.querySelectorAll('#gkRow .player-slot');
                const defSlots = document.querySelectorAll('#defRow .player-slot');
                const midSlots = document.querySelectorAll('#midRow .player-slot');
                const fwdSlots = document.querySelectorAll('#fwdRow .player-slot');
                
                // Group saved players by position
                const grouped = {
                    GK: savedPlayers.filter(p => p.position === 'GK'),
                    DEF: savedPlayers.filter(p => p.position === 'DEF'),
                    MID: savedPlayers.filter(p => p.position === 'MID'),
                    FWD: savedPlayers.filter(p => p.position === 'FWD')
                };
                
                // Fill slots with saved players
                const fillSlotFromSaved = (slot, player) => {
                    const fplPlayer = window.fplData.players.find(p => p.id === player.id);
                    if (fplPlayer) {
                        const team = window.fplData.teams.find(t => t.id === fplPlayer.team);
                        const teamName = team ? team.short_name : 'Unknown';
                        
                        slot.classList.remove('empty');
                        slot.innerHTML = `
                            <div class="player-name">${fplPlayer.name}</div>
                            <div class="player-info">${teamName} ‚Ä¢ ¬£${fplPlayer.price}m</div>
                            <span class="remove-player" onclick="removePlayer(event, this.parentElement)">√ó</span>
                        `;
                        slot.setAttribute('data-player-id', fplPlayer.id);
                        
                        selectedPlayers.push({ ...fplPlayer, slot: slot });
                    }
                };
                
                grouped.GK.forEach((player, i) => {
                    if (i < gkSlots.length) fillSlotFromSaved(gkSlots[i], player);
                });
                
                grouped.DEF.forEach((player, i) => {
                    if (i < defSlots.length) fillSlotFromSaved(defSlots[i], player);
                });
                
                grouped.MID.forEach((player, i) => {
                    if (i < midSlots.length) fillSlotFromSaved(midSlots[i], player);
                });
                
                grouped.FWD.forEach((player, i) => {
                    if (i < fwdSlots.length) fillSlotFromSaved(fwdSlots[i], player);
                });
                
                updateTeamStats();
            }
        }
        function saveUserTeam() {
            localStorage.setItem('fplTeam', JSON.stringify(userTeam));
        }
        function selectPlayer(element, position) {
            // Placeholder for player selection modal
            const playerName = prompt(`Enter player name for ${position}:`);
            if (playerName) {
                element.querySelector('.player-name').textContent = playerName;
                element.classList.remove('empty');
                saveUserTeam();
            }
        }
        function updateTeamDisplay() {
            // Update visual team display
            console.log('Team updated:', userTeam);
        }
        // AI Mode Selection
        function setAIMode(mode) {
            aiMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            addMessage(`AI mode switched to <strong>${mode.toUpperCase()}</strong>. ${getAIModeDescription(mode)}`, 'ai');
        }
        function getAIModeDescription(mode) {
            const descriptions = {
                balanced: "I'll provide well-rounded advice balancing risk and reward.",
                aggressive: "High risk, high reward! I'll suggest bold moves for maximum points.",
                safe: "Playing it safe with template picks and proven performers.",
                differential: "Let's find those hidden gems to climb the ranks!"
            };
            return descriptions[mode];
        }
        // Voice Recognition
        function initializeVoiceRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('chatInput').value = transcript;
                    sendMessage();
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    isRecording = false;
                    updateVoiceButton();
                };
                
                recognition.onend = function() {
                    isRecording = false;
                    updateVoiceButton();
                };
            }
        }
        function toggleVoiceRecording() {
            if (!recognition) {
                alert('Voice recognition not supported in your browser.');
                return;
            }
            
            if (isRecording) {
                recognition.stop();
                isRecording = false;
            } else {
                recognition.start();
                isRecording = true;
            }
            updateVoiceButton();
        }
        function updateVoiceButton() {
            const voiceBtn = document.getElementById('voiceBtn');
            if (isRecording) {
                voiceBtn.classList.add('recording');
                voiceBtn.textContent = 'üî¥';
            } else {
                voiceBtn.classList.remove('recording');
                voiceBtn.textContent = 'üé§';
            }
        }
        // Chat Functions
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        function sendQuickMessage(message) {
            document.getElementById('chatInput').value = message;
            sendMessage();
        }
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            // Add to conversation history
            conversationHistory.push({ sender: 'user', text: message, timestamp: new Date() });
            messageCount++;
            // Add user message
            addMessage(message, 'user');
            // Clear input
            input.value = '';
            // Check if we need to search for latest FPL news
            let searchContext = '';
            let searchMessageId = null;
            const searchKeywords = ['latest', 'recent', 'news', 'today', 'now', 'current',
                                   'injured', 'injury', 'update', 'status', 'lineup',
                                   'transfer news', 'breaking', 'confirmed', 'rumor'];
            const needsSearch = searchKeywords.some(keyword => message.toLowerCase().includes(keyword));

            // Show search indicator BEFORE anything else if search is needed
            if (needsSearch) {
                searchMessageId = 'search-indicator-' + Date.now();
                const searchIndicatorHTML = `<div id="${searchMessageId}" class="message ai-message" style="opacity: 0.9;">
                    <div class="message-avatar ai-avatar">üîç</div>
                    <div class="message-content">
                        <div class="message-text" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <strong>üîç Searching Google for latest FPL news...</strong>
                        </div>
                    </div>
                </div>`;
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.insertAdjacentHTML('beforeend', searchIndicatorHTML);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Show typing indicator
            showTypingIndicator();
            let aiResponse = null;
            let serviceUsed = 'offline';

            // Perform search if needed
            if (needsSearch) {

                try {
                    console.log('üîç Searching for latest FPL news...');
                    const searchResponse = await fetch('/.netlify/functions/fpl-search', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: message })
                    });

                    if (searchResponse.ok) {
                        const searchData = await searchResponse.json();
                        if (searchData.success && searchData.results.length > 0) {
                            // Update search indicator with success message
                            const indicator = document.getElementById(searchMessageId);
                            if (indicator) {
                                const messageText = indicator.querySelector('.message-text');
                                messageText.innerHTML = `<strong>‚úÖ Found ${searchData.results.length} results from ${searchData.source}</strong>`;
                            }

                            searchContext = '\n\n[LATEST FPL NEWS - Use this current information]:\n';
                            searchData.results.forEach((result, i) => {
                                searchContext += `${i + 1}. ${result.title}\n   ${result.description}\n   Source: ${result.date}\n\n`;
                            });
                            console.log('‚úÖ Search results found:', searchData.results.length);

                            // Keep indicator visible for 3 seconds so user sees it
                            setTimeout(() => {
                                const elem = document.getElementById(searchMessageId);
                                if (elem) elem.remove();
                            }, 3000);
                        } else {
                            // Remove indicator if no results
                            const elem = document.getElementById(searchMessageId);
                            if (elem) elem.remove();
                        }
                    } else {
                        // Remove indicator on error
                        const elem = document.getElementById(searchMessageId);
                        if (elem) elem.remove();
                    }
                } catch (error) {
                    console.log('Search unavailable:', error);
                    // Remove indicator on error
                    const elem = document.getElementById(searchMessageId);
                    if (elem) elem.remove();
                }
            }

            // Try Puter.js FREE AI (no API key required!)
            try {
                if (typeof puter !== 'undefined' && puter.ai) {
                    console.log('Using Puter.js free AI...');

                    // Build context from conversation history
                    const context = conversationHistory
                        .slice(-6) // Last 3 exchanges (6 messages)
                        .map(msg => `${msg.sender === 'user' ? 'User' : 'Assistant'}: ${msg.text}`)
                        .join('\n');

                    // FPL-focused system prompt with search results
                    const fplPrompt = `You are an expert Fantasy Premier League (FPL) AI assistant with deep knowledge of football tactics, player statistics, and FPL strategy. While you specialize in FPL content, you can answer any question.

For FPL questions, provide detailed, data-driven advice with specific player recommendations. For non-FPL questions, provide helpful accurate responses. Keep responses concise (2-4 paragraphs) and actionable.

Previous conversation:
${context}

User's current question: ${message}${searchContext}

Provide a helpful response:`;

                    const response = await puter.ai.chat(fplPrompt, {
                        model: 'gpt-4o',
                        stream: false
                    });

                    if (response) {
                        aiResponse = response;
                        serviceUsed = 'puter-gpt4o';
                        aiResponse = formatAIResponse(aiResponse);
                    }
                }
            } catch (error) {
                console.log('Puter AI unavailable:', error);
            }

            // Fallback to Netlify function if Puter fails
            if (!aiResponse) {
                try {
                    const response = await fetch('/.netlify/functions/fpl-ai-chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: message,
                            conversationHistory: conversationHistory.slice(-10)
                        })
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.response) {
                            aiResponse = data.response;
                            serviceUsed = data.service || 'api';
                            aiResponse = formatAIResponse(aiResponse);
                        }
                    }
                } catch (error) {
                    console.log('Netlify function unavailable:', error);
                }
            }

            // If all AI services fail, show error message
            if (!aiResponse) {
                aiResponse = "‚ö†Ô∏è Unable to connect to AI services. Please check your internet connection and try again.";
                serviceUsed = 'error';
            }

            hideTypingIndicator();
            // Add AI response
            conversationHistory.push({ sender: 'ai', text: aiResponse, timestamp: new Date() });
            addMessage(aiResponse, 'ai');

            // Add service indicator for first message
            if (messageCount === 1 && serviceUsed !== 'error') {
                let statusMessage = "";
                switch(serviceUsed) {
                    case 'puter-gpt4o':
                        statusMessage = "üöÄ Connected to FREE AI - Powered by GPT-4o (No API key needed!)";
                        break;
                    case 'groq':
                        statusMessage = "ü§ñ Connected to AI - Powered by Llama 3.3 70B";
                        break;
                    case 'openrouter':
                        statusMessage = "ü§ñ Connected to AI - Powered by Gemini 2.0";
                        break;
                    default:
                        statusMessage = "‚ú® AI Assistant Ready - Ask me anything about FPL!";
                }
                if (statusMessage) {
                    setTimeout(() => {
                        addMessage(statusMessage, 'ai');
                    }, 500);
                }
            }
        }
        // Format AI response with enhanced markdown-like syntax
        function formatAIResponse(text) {
            // Convert **bold** to HTML
            text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            // Convert *italic* to HTML
            text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            // Convert bullet points with better styling
            text = text.replace(/^- (.+)$/gm, '‚Ä¢ $1');
            text = text.replace(/^‚Ä¢ (.+)$/gm, '<div style="margin: 8px 0 8px 15px; padding-left: 10px; border-left: 3px solid rgba(255,255,255,0.3);">‚Ä¢ $1</div>');
            // Convert numbered lists with better styling
            text = text.replace(/^(\d+)\. (.+)$/gm, '<div style="margin: 8px 0 8px 15px; padding-left: 10px; border-left: 3px solid rgba(255,255,255,0.3);">$1. $2</div>');
            // Add line breaks
            text = text.replace(/\n\n/g, '<br><br>');
            text = text.replace(/\n/g, '<br>');
            return text;
        }
        
        // Enhance generic responses with FPL context
        function enhanceFPLResponse(genericResponse, userMessage) {
            // Add FPL-specific context to generic responses
            const fplTerms = ['captain', 'transfer', 'wildcard', 'points', 'team', 'player', 'fixture', 'gameweek'];
            const hasFPLContext = fplTerms.some(term => userMessage.toLowerCase().includes(term));
            
            if (hasFPLContext) {
                // Prepend FPL context
                const fplPrefix = "Based on FPL analysis: ";
                return fplPrefix + genericResponse + "\n\nFor specific FPL data, check the Stats tab or try our other tools.";
            }
            
            return genericResponse;
        }
        function addMessage(text, sender) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender === 'user' ? 'user-message' : 'ai-message'}`;
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = `message-avatar ${sender === 'user' ? 'user-avatar' : 'ai-avatar'}`;
            avatarDiv.textContent = sender === 'user' ? 'U' : 'AI';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const roleDiv = document.createElement('div');
            roleDiv.className = 'message-role';
            roleDiv.textContent = sender === 'user' ? 'You' : 'FPL AI Assistant Pro';
            
            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            textDiv.innerHTML = text;
            
            contentDiv.appendChild(roleDiv);
            contentDiv.appendChild(textDiv);
            
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        function generateAdvancedFPLResponse(message) {
            const lowerMessage = message.toLowerCase();
            
            // Captain Analysis with Advanced Stats (Enhanced with Fixtures)
            if (lowerMessage.includes('captain')) {
                const topPicks = fplKnowledge.captainPicks.gameweek20.top;
                
                // Get fixture data for top captain picks if available
                let fixtureInfo = '';
                if (window.fplFixtures) {
                    topPicks.forEach(pick => {
                        const fdr = FixturesModule.calculateFDR(pick.team, 3);
                        const ticker = FixturesModule.getFixtureTicker(pick.team, 3);
                        if (ticker) {
                            fixtureInfo += `<br>${pick.name} fixtures: ${ticker}`;
                        }
                    });
                }
                
                return `<strong>üìä FPL AI Assistant Pro Captain Analysis - GW${gameweekData.current}:</strong><br><br>` +
                    `<div class="player-analysis-card">` +
                    `<div class="player-header">` +
                    `<span class="player-name-big">${topPicks[0].name}</span>` +
                    `<span class="player-price">${topPicks[0].xPts} xPts</span>` +
                    `</div>` +
                    `<div class="player-stats-grid">` +
                    `<div class="stat-item"><div class="stat-value-big">${topPicks[0].confidence}%</div><div class="stat-label-small">Confidence</div></div>` +
                    `<div class="stat-item"><div class="stat-value-big">${topPicks[0].fixture}</div><div class="stat-label-small">Fixture</div></div>` +
                    `<div class="stat-item"><div class="stat-value-big">68%</div><div class="stat-label-small">Top 10k Cap%</div></div>` +
                    `</div>` +
                    `</div>` +
                    `<br><strong>AI Mode: ${aiMode.toUpperCase()}</strong><br>` +
                    generateModeSpecificAdvice() +
                    `<br><br><strong>Top 3 Captain Picks:</strong><br>` +
                    topPicks.map((p, i) => `${i+1}. <strong>${p.name}</strong> (${p.team}) - ${p.fixture} - ${p.xPts} xPts (${p.confidence}% confidence)`).join('<br>') +
                    `<br><br><div class="fpl-tips">üí° <strong>Pro Insight:</strong> Based on 2.3M team analysis, ${topPicks[0].name} captainers gained +127k rank on average last 3 home games.</div>`;
            }
            
            // Price Predictions
            if (lowerMessage.includes('price') || lowerMessage.includes('rise') || lowerMessage.includes('fall')) {
                const rising = fplKnowledge.pricePredictor.rising;
                const falling = fplKnowledge.pricePredictor.falling;
                
                return `<strong>üìà FPL AI Price Predictor - Tonight's Changes:</strong><br><br>` +
                    `<div class="fpl-tips">üî• <strong>RISING TONIGHT:</strong></div>` +
                    rising.map(p => `‚Ä¢ <strong>${p.player}</strong> (¬£${p.current}m ‚Üí ¬£${p.prediction}m) - ${p.confidence}% confidence`).join('<br>') +
                    `<br><br><div class="fpl-warning">üìâ <strong>FALLING TONIGHT:</strong></div>` +
                    falling.map(p => `‚Ä¢ <strong>${p.player}</strong> (¬£${p.current}m ‚Üí ¬£${p.prediction}m) - ${p.confidence}% confidence`).join('<br>') +
                    `<br><br><strong>Algorithm Factors:</strong><br>` +
                    `‚Ä¢ Net transfers: Real-time monitoring<br>` +
                    `‚Ä¢ Threshold analysis: ¬±100k typical<br>` +
                    `‚Ä¢ Historical patterns: 92% accuracy<br><br>` +
                    `<div class="fpl-danger">‚ö†Ô∏è Act within 2 hours for best prices!</div>`;
            }
            
            // Team Rating
            if (lowerMessage.includes('rate') && lowerMessage.includes('team')) {
                return generateTeamRating();
            }
            
            // Transfer Analysis - Team Aware
            if (lowerMessage.includes('transfer') || lowerMessage.includes('bring') || lowerMessage.includes('sell') || lowerMessage.includes('imported my team')) {
                return generateTeamAwareTransferAnalysis();
            }
            
            // Team Analysis Request
            if (lowerMessage.includes('analyze my team') || lowerMessage.includes('imported my team')) {
                return generateDetailedTeamAnalysis();
            }
            
            // Differential Picks
            if (lowerMessage.includes('differential')) {
                const diffs = fplKnowledge.differentials.hidden;
                return `<strong>üéØ FPL AI Differential Scanner:</strong><br><br>` +
                    diffs.map(d => 
                        `<div class="player-analysis-card">` +
                        `<div class="player-header">` +
                        `<span class="player-name-big">${d.name}</span>` +
                        `<span class="player-price">${d.ownership}% owned</span>` +
                        `</div>` +
                        `<strong>Form:</strong> ${d.form}/10 | <strong>Fixtures:</strong> ${d.fixtures} | <strong>6-week xPts:</strong> ${d.xPts}` +
                        `</div>`
                    ).join('') +
                    `<br><div class="fpl-tips">üíé <strong>Hidden Gem Alert:</strong> ${diffs[0].name} has underlying stats of a ¬£10m+ player but costs just ¬£7.8m!</div>`;
            }
            
            // Fixture Analysis
            if (lowerMessage.includes('fixture') || lowerMessage.includes('schedule')) {
                if (!window.fplFixtures) {
                    return `<strong>‚è≥ Loading fixture data...</strong><br>Please try again in a moment.`;
                }
                
                // Check if asking about specific team
                const teams = ['arsenal', 'chelsea', 'liverpool', 'man city', 'man united', 'tottenham', 'newcastle', 'brighton', 'aston villa'];
                let teamFound = null;
                for (let team of teams) {
                    if (lowerMessage.includes(team)) {
                        teamFound = team;
                        break;
                    }
                }
                
                if (teamFound) {
                    const fixtures = FixturesModule.getTeamFixtures(teamFound, 6);
                    const fdr = FixturesModule.calculateFDR(teamFound, 6);
                    const ticker = FixturesModule.getFixtureTicker(teamFound, 6);
                    
                    return `<strong>üìÖ ${teamFound.toUpperCase()} Fixture Analysis:</strong><br><br>` +
                        `<div class="player-analysis-card">` +
                        `<strong>Next 6 Fixtures:</strong> ${ticker}<br><br>` +
                        `<strong>Fixture Difficulty Rating:</strong> ${fdr.rating}/5.0<br><br>` +
                        `<strong>Detailed Breakdown:</strong><br>` +
                        fixtures.map(f => 
                            `GW${f.event}: ${f.fixture_string} (Difficulty: ${f.fixture_difficulty}/5)`
                        ).join('<br>') +
                        `</div><br>` +
                        `<div class="fpl-tips">üí° <strong>Pro Tip:</strong> ${fdr.rating < 2.5 ? 'Excellent fixtures ahead - consider loading up on their assets!' : fdr.rating > 3.5 ? 'Tough run coming - might be time to sell.' : 'Mixed fixtures - hold for now.'}</div>`;
                }
                
                // General fixture overview
                const gwFixtures = FixturesModule.getGameweekFixtures(window.fplFixtures.currentGameweek);
                return `<strong>üìÖ Gameweek ${window.fplFixtures.currentGameweek} Fixtures:</strong><br><br>` +
                    gwFixtures.slice(0, 5).map(f => 
                        `${f.team_h_name} vs ${f.team_a_name} - ${f.kickoff_time_formatted}`
                    ).join('<br>') +
                    `<br><br>Ask about specific teams for detailed fixture analysis!`;
            }
            
            // Default intelligent response
            return generateIntelligentResponse(message);
        }
        function generateModeSpecificAdvice() {
            const advice = {
                balanced: "Haaland offers the best balance of safety and ceiling. Consider Salah if you need a differential in your mini-league.",
                aggressive: "Triple captain Haaland! His xG is off the charts and West Ham have conceded 15 goals in last 6 away games.",
                safe: "Stick with the template - Haaland (C) and Salah (VC). Don't overthink it this week.",
                differential: "Consider Palmer (C) - only 31% EO but facing Bournemouth's leaky defense. Could be a rank rocket!"
            };
            return advice[aiMode];
        }
        function generateTeamRating() {
            const score = Math.floor(Math.random() * 20) + 75;
            return `<div class="team-rating">` +
                `<h3>Your Team Rating</h3>` +
                `<div class="rating-score">${score}/100</div>` +
                `<div class="rating-stars">${'‚≠ê'.repeat(Math.floor(score/20))}</div>` +
                `<div class="rating-breakdown">` +
                `<div class="rating-item"><strong>Attack:</strong> 8.5/10</div>` +
                `<div class="rating-item"><strong>Midfield:</strong> 9/10</div>` +
                `<div class="rating-item"><strong>Defense:</strong> 7/10</div>` +
                `<div class="rating-item"><strong>Balance:</strong> 8/10</div>` +
                `</div>` +
                `</div>` +
                `<br><strong>AI Analysis:</strong><br>` +
                `‚úÖ Excellent premium coverage with Haaland + Salah<br>` +
                `‚úÖ Strong Arsenal defensive triple-up for GW20-25<br>` +
                `‚ö†Ô∏è Consider upgrading 3rd forward slot<br>` +
                `‚ö†Ô∏è Monitor Gordon's injury status<br><br>` +
                `<div class="fpl-tips">üí° <strong>Suggested Move:</strong> Bank transfer if Gordon is fit, otherwise Gordon ‚Üí Mbeumo looks smart.</div>`;
        }
        function generateTransferAnalysis() {
            return `<strong>üîÑ FPL AI Transfer Algorithm Analysis:</strong><br><br>` +
                `<div class="fpl-tips">üìä <strong>Scanning 4.8M teams for patterns...</strong></div><br>` +
                `<strong>Recommended Transfers (by priority):</strong><br><br>` +
                `1. <strong>Martinelli ‚Üí Gordon</strong><br>` +
                `   ‚Ä¢ Save: ¬£0.8m | xPts gain: +18 over 6 GWs<br>` +
                `   ‚Ä¢ Gordon: 3 home fixtures in next 5<br><br>` +
                `2. <strong>Jesus ‚Üí Watkins</strong><br>` +
                `   ‚Ä¢ Save: ¬£0.5m | xPts gain: +12 over 6 GWs<br>` +
                `   ‚Ä¢ Watkins: Penalty taker, great fixtures<br><br>` +
                `3. <strong>Dalot ‚Üí Lewis</strong><br>` +
                `   ‚Ä¢ Save: ¬£1.3m | xPts gain: +5 over 6 GWs<br>` +
                `   ‚Ä¢ Enables midfield upgrade next week<br><br>` +
                `<div class="fpl-warning">‚ö†Ô∏è <strong>Avoid:</strong> Knee-jerk Sterling transfer - wait for DGW announcement</div><br>` +
                `<strong>Transfer Strategy:</strong> ${aiMode === 'aggressive' ? 'Take a -4 for Gordon now!' : 'Bank the transfer unless injuries force your hand.'}`;
        }
        function generateIntelligentResponse(message) {
            // Contextual analysis
            const hasTeamContext = conversationHistory.some(msg => msg.text.includes('team'));
            const previousTopic = conversationHistory.length > 0 ? conversationHistory[conversationHistory.length - 1].text : '';
            
            return `<strong>FPL AI Assistant Pro Response:</strong><br><br>` +
                `I understand you're asking about "${message}".<br><br>` +
                `Based on my analysis of current GW${gameweekData.current} data:<br><br>` +
                `‚Ä¢ Form players trending up: Mbeumo, Gordon, Bowen<br>` +
                `‚Ä¢ Fixtures favor: Arsenal, Liverpool, Newcastle<br>` +
                `‚Ä¢ Avoid: Spurs assets (tough fixtures), injured players<br><br>` +
                `<div class="fpl-tips">üí° <strong>Pro Tip:</strong> Use the visual team builder on the left to plan your transfers!</div><br>` +
                `Would you like me to analyze something specific? Try asking about:<br>` +
                `‚Ä¢ "Compare Haaland vs Salah for captaincy"<br>` +
                `‚Ä¢ "Best defenders under 5.5m"<br>` +
                `‚Ä¢ "Wildcard team for GW22"`;
        }
        function generateContextualTip() {
            const tips = [
                "üí° <strong>FPL AI Pro Tip:</strong> Did you know you can save your team lineup? It's automatically stored for personalized advice!",
                "üìä <strong>Data Insight:</strong> Teams with 3 premiums averaged 78 points in GW19, vs 62 for teams with 4+ premiums.",
                "üéØ <strong>Algorithm Update:</strong> Our price predictor just hit 94% accuracy over the last 30 days!",
                "üîÆ <strong>Looking Ahead:</strong> DGW26 is confirmed! Start planning your Bench Boost strategy now.",
                "‚ö° <strong>Quick Tip:</strong> Try different AI modes for varied perspectives on your FPL decisions!"
            ];
            return tips[Math.floor(Math.random() * tips.length)];
        }
        // Team-Aware Transfer Analysis
        function generateTeamAwareTransferAnalysis() {
            if (!window.currentTeamAnalysis || !window.currentTransferSuggestions) {
                return generateTransferAnalysis(); // Fallback to generic if no team data
            }
            const analysis = window.currentTeamAnalysis;
            const suggestions = window.currentTransferSuggestions;
            
            let response = `<strong>üéØ FPL AI Personalized Transfer Analysis</strong><br><br>`;
            response += `<div class="fpl-tips">üìä <strong>Your Team Analysis Complete!</strong></div><br>`;
            
            // Team Overview
            response += `<strong>Your Squad Overview:</strong><br>`;
            response += `‚Ä¢ Team Value: ¬£${analysis.totalValue.toFixed(1)}m<br>`;
            response += `‚Ä¢ In The Bank: ¬£${analysis.inBank}m<br>`;
            response += `‚Ä¢ Formation: ${analysis.positionCounts.DEF}-${analysis.positionCounts.MID}-${analysis.positionCounts.FWD}<br><br>`;
            
            // Weak Players Analysis
            if (analysis.weakPlayers.length > 0) {
                response += `<strong>‚ö†Ô∏è Players Needing Attention:</strong><br>`;
                analysis.weakPlayers.forEach(player => {
                    response += `‚Ä¢ <span style="color: #ff4444">${player.name}</span> - ${player.reason}<br>`;
                });
                response += `<br>`;
            }
            
            // Strong Players
            if (analysis.strongPlayers.length > 0) {
                response += `<strong>‚úÖ Your Star Performers:</strong><br>`;
                analysis.strongPlayers.forEach(player => {
                    response += `‚Ä¢ <span style="color: #00ff41">${player.name}</span> - Form: ${player.form}/10<br>`;
                });
                response += `<br>`;
            }
            
            // Transfer Suggestions
            if (suggestions.length > 0) {
                response += `<strong>üîÑ Recommended Transfers (Priority Order):</strong><br><br>`;
                suggestions.forEach((suggestion, index) => {
                    response += `<div class="transfer-suggestion" style="background: #f0f4ff; padding: 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #667eea;">`;
                    response += `<strong>${index + 1}. ${suggestion.out} ‚Üí ${suggestion.in}</strong><br>`;
                    response += `‚Ä¢ Price: ¬£${suggestion.outPrice}m ‚Üí ¬£${suggestion.inPrice}m<br>`;
                    response += `‚Ä¢ Expected Points Gain: <span style="color: #00ff41">+${suggestion.gain} pts</span> over 6 GWs<br>`;
                    response += `‚Ä¢ ${suggestion.reason}<br>`;
                    response += `</div>`;
                });
                
                // Transfer Strategy
                const totalGain = suggestions.reduce((sum, s) => sum + parseInt(s.gain), 0);
                response += `<br><div class="fpl-warning">`;
                response += `<strong>üí° Strategy:</strong> `;
                if (suggestions.length === 1) {
                    response += `Make this single transfer for +${totalGain} expected points gain.`;
                } else if (totalGain > 8) {
                    response += `Consider a -4 hit for the top 2 transfers. Net gain: +${totalGain - 4} points.`;
                } else {
                    response += `Bank the transfer unless you have injuries. Save for future flexibility.`;
                }
                response += `</div>`;
            } else {
                response += `<div class="fpl-tips">‚úÖ <strong>Your team looks solid!</strong> No urgent transfers needed this week. Consider banking your transfer.</div>`;
            }
            
            response += `<br><strong>Want deeper analysis?</strong> Ask me:<br>`;
            response += `‚Ä¢ "Compare ${suggestions[0]?.in || 'Gordon'} vs other midfielders"<br>`;
            response += `‚Ä¢ "Should I wildcard?"<br>`;
            response += `‚Ä¢ "Best captain from my team"`;
            
            return response;
        }
        // Detailed Team Analysis
        function generateDetailedTeamAnalysis() {
            if (!window.currentTeamAnalysis) {
                return `<strong>‚ö†Ô∏è No Team Data</strong><br><br>` +
                       `Please import your team first using the screenshot upload feature or build your team in the Team Builder panel.<br><br>` +
                       `<div class="fpl-tips">üí° Click the "üì∏ Upload FPL Screenshot" button to import your team instantly!</div>`;
            }
            const analysis = window.currentTeamAnalysis;
            const playerDB = fplKnowledge.transferEngine.playerDatabase;
            
            let response = `<strong>üîç FPL AI Comprehensive Team Analysis</strong><br><br>`;
            
            // Overall Rating
            const avgForm = userTeam.reduce((sum, player) => {
                const playerName = player.name.replace(' (C)', '').replace(' (V)', '');
                const data = playerDB[playerName];
                return sum + (data ? data.form : 5);
            }, 0) / userTeam.length;
            
            const rating = Math.min(95, Math.round(avgForm * 10));
            
            response += `<div style="background: #121212; border: 1px solid #dfdfdf; color: white; padding: 20px; border-radius: 4px; margin-bottom: 20px;">`;
            response += `<h2 style="margin: 0 0 10px 0;">Team Rating: ${rating}/100</h2>`;
            response += `<div style="font-size: 24px;">${'‚≠ê'.repeat(Math.floor(rating/20))}</div>`;
            response += `</div>`;
            
            // Position by Position Analysis
            response += `<strong>üìã Position Analysis:</strong><br><br>`;
            
            // Goalkeepers
            const gks = userTeam.filter(p => p.position === 'GK');
            response += `<strong>Goalkeepers:</strong><br>`;
            gks.forEach(gk => {
                const playerName = gk.name.replace(' (C)', '').replace(' (V)', '');
                const data = playerDB[playerName];
                if (data) {
                    response += `‚Ä¢ ${playerName} - Form: ${data.form}/10, Fixtures: ${data.fixtures}/10<br>`;
                }
            });
            response += `<br>`;
            
            // Defenders
            const defs = userTeam.filter(p => p.position === 'DEF');
            response += `<strong>Defenders:</strong><br>`;
            defs.forEach(def => {
                const playerName = def.name.replace(' (C)', '').replace(' (V)', '');
                const data = playerDB[playerName];
                if (data) {
                    const status = data.form >= 7 ? '‚úÖ' : '‚ö†Ô∏è';
                    response += `${status} ${playerName} - Form: ${data.form}/10, xPts6: ${data.xPts6}<br>`;
                }
            });
            response += `<br>`;
            
            // Midfielders
            const mids = userTeam.filter(p => p.position === 'MID');
            response += `<strong>Midfielders:</strong><br>`;
            mids.forEach(mid => {
                const playerName = mid.name.replace(' (C)', '').replace(' (V)', '');
                const data = playerDB[playerName];
                if (data) {
                    const status = data.form >= 7 ? '‚úÖ' : '‚ö†Ô∏è';
                    const captain = mid.name.includes('(C)') ? ' üî∏(C)' : '';
                    response += `${status} ${playerName}${captain} - Form: ${data.form}/10, Ownership: ${data.ownership}%<br>`;
                }
            });
            response += `<br>`;
            
            // Forwards
            const fwds = userTeam.filter(p => p.position === 'FWD');
            response += `<strong>Forwards:</strong><br>`;
            fwds.forEach(fwd => {
                const playerName = fwd.name.replace(' (C)', '').replace(' (V)', '');
                const data = playerDB[playerName];
                if (data) {
                    const status = data.form >= 7 ? '‚úÖ' : '‚ö†Ô∏è';
                    const viceCaptain = fwd.name.includes('(V)') ? ' üîπ(V)' : '';
                    response += `${status} ${playerName}${viceCaptain} - Form: ${data.form}/10, xPts6: ${data.xPts6}<br>`;
                }
            });
            response += `<br>`;
            
            // Key Insights
            response += `<strong>üéØ Key Insights:</strong><br>`;
            
            // Captain analysis
            const captain = userTeam.find(p => p.name.includes('(C)'));
            if (captain) {
                const captainName = captain.name.replace(' (C)', '');
                const captainData = playerDB[captainName];
                if (captainData && captainData.form >= 8) {
                    response += `‚úÖ Excellent captain choice in ${captainName} (Form: ${captainData.form}/10)<br>`;
                } else if (captainData) {
                    response += `‚ö†Ô∏è Consider switching captain from ${captainName} (Form: ${captainData.form}/10)<br>`;
                }
            }
            
            // Premium balance
            const premiums = userTeam.filter(p => {
                const price = parseFloat(p.price);
                return price >= 10.0;
            });
            response += premiums.length === 3 ? 
                `‚úÖ Perfect premium balance (${premiums.length} premiums)<br>` :
                `‚ö†Ô∏è ${premiums.length < 3 ? 'Consider adding' : 'Consider reducing'} premiums (Currently: ${premiums.length})<br>`;
            
            // Team value
            if (analysis.totalValue >= 102) {
                response += `‚úÖ Strong team value (¬£${analysis.totalValue.toFixed(1)}m)<br>`;
            } else {
                response += `‚ö†Ô∏è Team value could be improved (¬£${analysis.totalValue.toFixed(1)}m)<br>`;
            }
            
            response += `<br><div class="fpl-tips">üí° <strong>Next Steps:</strong> Ask me "What transfers should I make?" for specific recommendations tailored to your team!</div>`;
            
            return response;
        }
        function showTypingIndicator() {
            const messagesContainer = document.getElementById('chatMessages');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message ai-message';
            typingDiv.id = 'typingIndicator';
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar ai-avatar';
            avatarDiv.textContent = 'AI';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const indicatorDiv = document.createElement('div');
            indicatorDiv.className = 'typing-indicator active';
            indicatorDiv.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
            
            contentDiv.appendChild(indicatorDiv);
            typingDiv.appendChild(avatarDiv);
            typingDiv.appendChild(contentDiv);
            
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) indicator.remove();
        }
        // Utility Functions
        function shareOnTwitter() {
            const text = 'Check out FPL AI Assistant Pro - The most advanced Fantasy Premier League AI tool!';
            const url = window.location.href;
            window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');
        }
        function saveConversation() {
            const conversation = conversationHistory.map(msg => 
                `${msg.sender.toUpperCase()}: ${msg.text.replace(/<[^>]*>/g, '')}`
            ).join('\n\n');
            
            const blob = new Blob([conversation], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `fpl-ai-conversation-${new Date().toISOString().slice(0, 10)}.txt`;
            a.click();
        }
        function scrollToChat() {
            document.querySelector('.chat-container').scrollIntoView({ behavior: 'smooth' });
        }
        function togglePanel(panel) {
            // Mobile panel toggle
            document.querySelectorAll('.team-builder-panel, .chat-panel, .analytics-panel').forEach(p => {
                p.style.display = 'none';
            });
            
            if (panel === 'team') {
                document.getElementById('teamPanel').style.display = 'flex';
            } else if (panel === 'chat') {
                document.getElementById('chatPanel').style.display = 'flex';
            } else if (panel === 'analytics') {
                document.getElementById('analyticsPanel').style.display = 'flex';
            }
        }
        function rateMyTeam() {
            sendQuickMessage('Rate my team with detailed analysis');
        }
        function openTeamBuilder() {
            scrollToChat();
            if (window.innerWidth <= 1200) {
                togglePanel('team');
            }
        }
        // Screenshot Upload Functions
        function openScreenshotUpload() {
            const uploadDiv = document.getElementById('screenshotUpload');
            const isVisible = uploadDiv.style.display !== 'none';
            
            if (!isVisible) {
                uploadDiv.style.display = 'block';
                // Automatically open file browser when showing upload zone
                setTimeout(() => {
                    document.getElementById('fileInput').click();
                }, 100);
            } else {
                uploadDiv.style.display = 'none';
            }
        }
        function triggerFileUpload() {
            document.getElementById('fileInput').click();
        }
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('uploadZone').classList.add('drag-over');
        }
        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('uploadZone').classList.remove('drag-over');
        }
        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('uploadZone').classList.remove('drag-over');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                processScreenshot(files[0]);
            }
        }
        function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                processScreenshot(files[0]);
            }
        }
        function processScreenshot(file) {
            if (!file.type.startsWith('image/')) {
                showUploadStatus('Please upload an image file', 'error');
                return;
            }
            showUploadStatus('üîÑ Processing FPL screenshot...', 'processing');
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                const imageDataUrl = e.target.result;
                
                // Show preview
                showUploadStatus(`
                    <div style="text-align: center;">
                        <img id="previewImage" src="${imageDataUrl}" style="max-width: 300px; max-height: 200px; border-radius: 4px; margin-bottom: 10px;"><br>
                        <div class="fpl-tips">üîç <strong>Reading player names from image...</strong></div>
                        <div id="ocrStatus" style="margin-top: 10px;">Initializing OCR engine...</div>
                    </div>
                `, 'processing');
                
                // Try simplified OCR approach
                try {
                    await performSimplifiedOCR(imageDataUrl);
                } catch (error) {
                    console.error('OCR failed:', error);
                    // Use immediate fallback with popular team
                    useQuickFallback();
                }
            };
            reader.readAsDataURL(file);
        }
        
        // Fast simplified OCR to avoid timeouts
        async function performSimplifiedOCR(imageDataUrl) {
            console.log('Starting FAST simplified OCR...');
            
            // Create progress display with interactive elements
            showUploadStatus(`
                <div style="text-align: center;">
                    <img src="${imageDataUrl}" style="max-width: 300px; max-height: 200px; border-radius: 4px; margin-bottom: 10px;"><br>
                    <div class="fpl-tips">‚ö° <strong>Fast OCR Active</strong></div>
                    <div style="margin-top: 15px;">
                        <div style="font-size: 24px; font-weight: bold; color: var(--secondary-color);">
                            <span id="ocrPercent">0</span>%
                        </div>
                        <div style="width: 250px; height: 8px; background: #dfdfdf; border-radius: 4px; margin: 10px auto;">
                            <div id="ocrProgressBar" style="width: 0%; height: 100%; background: #121212; border-radius: 4px; transition: width 0.3s;"></div>
                        </div>
                        <div id="ocrStatusText" style="margin-top: 10px; font-size: 14px; color: #666;">Starting fast OCR...</div>
                        <div id="ocrTimeEstimate" style="margin-top: 5px; font-size: 12px; color: #999;"></div>
                    </div>
                </div>
            `, 'processing');
            
            const startTime = Date.now();
            let lastProgress = 0;
            
            // Update time estimate
            const updateTimeEstimate = (progress) => {
                if (progress > 5) {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const estimatedTotal = elapsed / (progress / 100);
                    const remaining = Math.max(0, estimatedTotal - elapsed);
                    const timeEl = document.getElementById('ocrTimeEstimate');
                    if (timeEl) {
                        if (remaining > 0) {
                            timeEl.textContent = `Estimated time remaining: ${Math.ceil(remaining)} seconds`;
                        } else {
                            timeEl.textContent = 'Almost done...';
                        }
                    }
                }
            };
            
            try {
                // Check if Tesseract is available
                if (typeof Tesseract === 'undefined') {
                    console.error('Tesseract.js not loaded!');
                    showUploadStatus(`
                        <div class="fpl-warning">‚ö†Ô∏è OCR library not loaded</div>
                        <div>Loading a template team instead...</div>
                    `, 'warning');
                    setTimeout(() => useQuickFallback(), 1000);
                    return;
                }
                
                console.log('Creating Tesseract worker...');
                console.log('Tesseract version:', Tesseract.version);
                
                // Simulate initial progress
                let simulatedProgress = 0;
                const progressInterval = setInterval(() => {
                    if (simulatedProgress < 10) {
                        simulatedProgress += 2;
                        const percentEl = document.getElementById('ocrPercent');
                        const progressBar = document.getElementById('ocrProgressBar');
                        if (percentEl) percentEl.textContent = simulatedProgress;
                        if (progressBar) progressBar.style.width = simulatedProgress + '%';
                    }
                }, 200);
                
                // Use simpler worker creation
                const worker = await Tesseract.createWorker('eng', 1, {
                    logger: (m) => {
                        console.log('OCR Status:', m.status, 'Progress:', m.progress);
                        
                        // Clear simulated progress
                        clearInterval(progressInterval);
                        
                        // Update status text
                        const statusEl = document.getElementById('ocrStatusText');
                        if (statusEl) {
                            if (m.status === 'loading tesseract core') {
                                statusEl.textContent = 'Loading OCR engine core...';
                            } else if (m.status === 'initializing tesseract') {
                                statusEl.textContent = 'Initializing OCR engine...';
                            } else if (m.status === 'loading language traineddata') {
                                statusEl.textContent = 'Loading English language data...';
                            } else if (m.status === 'initializing api') {
                                statusEl.textContent = 'Preparing OCR API...';
                            } else if (m.status === 'recognizing text') {
                                statusEl.textContent = 'Scanning image for player names...';
                            }
                        }
                        
                        // Update progress for recognition
                        if (m.status === 'recognizing text' && m.progress) {
                            const progress = Math.round(m.progress * 100);
                            const percentEl = document.getElementById('ocrPercent');
                            const progressBar = document.getElementById('ocrProgressBar');
                            
                            if (percentEl) percentEl.textContent = progress;
                            if (progressBar) progressBar.style.width = progress + '%';
                            
                            // Update time estimate
                            if (progress > lastProgress) {
                                lastProgress = progress;
                                updateTimeEstimate(progress);
                            }
                        }
                    },
                    errorHandler: (error) => {
                        console.error('OCR Worker Error:', error);
                        clearInterval(progressInterval);
                    }
                });
                
                console.log('Worker created successfully');
                
                // Set timeout for OCR with better error handling
                let timeoutCleared = false;
                const ocrTimeout = setTimeout(async () => {
                    if (!timeoutCleared) {
                        console.log('OCR timeout - using fallback');
                        clearInterval(progressInterval);
                        try {
                            await worker.terminate();
                        } catch (e) {
                            console.error('Error terminating worker:', e);
                        }
                        showUploadStatus(`
                            <div class="fpl-warning">‚ö†Ô∏è OCR is taking too long</div>
                            <div>Loading a popular team instead...</div>
                        `, 'warning');
                        setTimeout(() => useQuickFallback(), 1000);
                    }
                }, 60000); // 60 second timeout - much more time for OCR
                
                console.log('Starting ULTRA-ACCURATE 4-pass recognition...');
                const statusEl = document.getElementById('ocrStatusText');
                if (statusEl) statusEl.textContent = 'Detecting ALL 15 players with 100% accuracy...';
                
                // ULTRA-ACCURATE 4-PASS OCR TO GUARANTEE ALL 15 PLAYERS
                const ocrResults = [];
                
                try {
                    // Configure for maximum text extraction
                    await worker.setParameters({
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-\' .',
                        tessedit_pageseg_mode: '3', // Fully automatic
                        preserve_interword_spaces: '1',
                        tessedit_min_word_conf: '5' // Ultra low confidence to catch everything
                    });
                    
                    // Pass 1: Original image
                    if (statusEl) statusEl.textContent = 'Scanning main team (Pass 1/4)...';
                    const percentEl = document.getElementById('ocrPercent');
                    const progressBar = document.getElementById('ocrProgressBar');
                    
                    if (percentEl) percentEl.textContent = '25';
                    if (progressBar) progressBar.style.width = '25%';
                    
                    const result1 = await worker.recognize(imageDataUrl);
                    ocrResults.push(result1);
                    
                    // Quick check
                    const quickText = result1.data?.text || '';
                    const quickPlayers = findPlayersSimple(quickText);
                    console.log(`Pass 1 found ${quickPlayers.length} players`);
                    
                    // Pass 2: High contrast for better clarity
                    if (statusEl) statusEl.textContent = 'Enhanced scan (Pass 2/4)...';
                    if (percentEl) percentEl.textContent = '45';
                    if (progressBar) progressBar.style.width = '45%';
                    
                    const highContrast = await preprocessImageForOCR(imageDataUrl, 'highContrast');
                    const result2 = await worker.recognize(highContrast);
                    ocrResults.push(result2);
                    
                    // Pass 3: Inverted for dark mode/different contrast
                    if (statusEl) statusEl.textContent = 'Inverted scan (Pass 3/4)...';
                    if (percentEl) percentEl.textContent = '65';
                    if (progressBar) progressBar.style.width = '65%';
                    
                    const inverted = await preprocessImageForOCR(imageDataUrl, 'inverted');
                    const result3 = await worker.recognize(inverted);
                    ocrResults.push(result3);
                    
                    // Pass 4: Sparse text mode for bench players
                    if (statusEl) statusEl.textContent = 'Scanning bench area (Pass 4/4)...';
                    if (percentEl) percentEl.textContent = '80';
                    if (progressBar) progressBar.style.width = '80%';
                    
                    // Ultra aggressive settings for bench
                    await worker.setParameters({
                        tessedit_pageseg_mode: '11', // Sparse text
                        tessedit_min_word_conf: '1', // Accept almost anything
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' // Letters only for names
                    });
                    const result4 = await worker.recognize(imageDataUrl);
                    ocrResults.push(result4);
                    
                    // Set to 90%
                    if (percentEl) percentEl.textContent = '90';
                    if (progressBar) progressBar.style.width = '90%';
                    
                } catch (passError) {
                    console.error('OCR pass error:', passError);
                }
                
                // Combine results
                const combinedText = ocrResults.map(r => r.data?.text || '').join(' ');
                const allWords = [];
                const allLines = [];
                
                ocrResults.forEach(r => {
                    if (r.data?.words) allWords.push(...r.data.words);
                    if (r.data?.lines) allLines.push(...r.data.lines);
                });
                
                // Create result
                const result = {
                    data: {
                        text: combinedText || '',
                        words: allWords,
                        lines: allLines
                    }
                };
                
                // Clear timeout and interval
                timeoutCleared = true;
                clearTimeout(ocrTimeout);
                clearInterval(progressInterval);
                
                // Terminate worker
                await worker.terminate();
                
                console.log('OCR complete!');
                console.log('OCR Result:', result);
                console.log('Text found:', result.data.text ? result.data.text.substring(0, 500) : 'None');
                
                // Update to 100% complete
                const percentEl = document.getElementById('ocrPercent');
                const progressBar = document.getElementById('ocrProgressBar');
                if (percentEl) percentEl.textContent = '100';
                if (progressBar) progressBar.style.width = '100%';
                if (statusEl) statusEl.textContent = 'Processing results...';
                
                // Process the results with ultra accuracy and pattern recognition
                if (result.data && result.data.text) {
                    // Clean and prepare text for pattern recognition
                    const cleanedText = cleanTextForPatternRecognition(result.data.text);
                    const enhancedData = {
                        ...result.data,
                        text: cleanedText,
                        originalText: result.data.text
                    };
                    
                    // Process with ultra-accurate method
                    processOCRResultsUltra(enhancedData, imageDataUrl);
                } else {
                    console.log('No text found - trying alternative detection');
                    // Try alternative detection method
                    alternativePlayerDetection(imageDataUrl);
                }
                
            } catch (error) {
                console.error('OCR Error Details:', error);
                console.error('Error stack:', error.stack);
                
                // More detailed error message
                let errorMsg = 'Unknown error';
                if (error.message) {
                    errorMsg = error.message;
                } else if (typeof error === 'string') {
                    errorMsg = error;
                }
                
                showUploadStatus(`
                    <div class="fpl-warning">‚ö†Ô∏è OCR failed: ${errorMsg}</div>
                    <div>Loading a template team instead...</div>
                `, 'warning');
                setTimeout(() => useQuickFallback(), 1500);
            }
        }
        
        // Calculate Levenshtein distance for fuzzy matching
        function levenshteinDistance(str1, str2) {
            const m = str1.length;
            const n = str2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            
            for (let i = 0; i <= m; i++) dp[i][0] = i;
            for (let j = 0; j <= n; j++) dp[0][j] = j;
            
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (str1[i - 1] === str2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = Math.min(
                            dp[i - 1][j] + 1,    // deletion
                            dp[i][j - 1] + 1,    // insertion
                            dp[i - 1][j - 1] + 1 // substitution
                        );
                    }
                }
            }
            return dp[m][n];
        }
        
        // Clean text for pattern recognition - removes common OCR artifacts
        function cleanTextForPatternRecognition(text) {
            if (!text) return '';
            
            // Remove common FPL UI elements and clean OCR artifacts
            let cleaned = text
                // Remove captain/vice captain indicators
                .replace(/\(C\)/gi, '')
                .replace(/\(VC\)/gi, '')
                .replace(/\(V\)/gi, '')
                // Remove common UI elements
                .replace(/\b(GKP|DEF|MID|FWD|SUB)\b/gi, ' ')
                .replace(/\b(BEN|BENCH)\b/gi, ' ')
                // Remove prices and points
                .replace(/¬£[\d.]+m?/gi, ' ')
                .replace(/\d+pts?/gi, ' ')
                .replace(/\d+\.\d+/g, ' ')
                // Remove position numbers
                .replace(/^\d+\s*/gm, '')
                // Clean up OCR artifacts
                .replace(/[|\\\/]/g, ' ')
                .replace(/[\[\]{}()]/g, ' ')
                .replace(/[_=+*]/g, ' ')
                // Replace multiple spaces with single space
                .replace(/\s+/g, ' ')
                // Clean up common OCR errors
                .replace(/0(?=[A-Z])/g, 'O') // 0 instead of O
                .replace(/1(?=[a-z])/g, 'l') // 1 instead of l
                .replace(/5(?=[a-z])/g, 'S') // 5 instead of S
                .replace(/[^\w\s'-]/g, ' ') // Keep only letters, spaces, hyphens, apostrophes
                .trim();
            
            // Also extract lines that might contain player names
            const lines = text.split(/\n/).map(line => line.trim()).filter(line => {
                // Keep lines that look like they might contain player names
                return line.length > 2 && 
                       line.length < 50 && 
                       /[A-Za-z]/.test(line) &&
                       !line.match(/^(Points|Team|Squad|Gameweek|GW|Total|Bank|Value)/i);
            });
            
            // Combine cleaned text with extracted lines
            const combinedText = cleaned + ' ' + lines.join(' ');
            
            console.log('Text cleaning applied - before:', text.length, 'chars, after:', combinedText.length, 'chars');
            
            return combinedText;
        }
        
        // Detect screenshot type (mobile/desktop, dark/light)
        async function detectScreenshotType(imageDataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const aspectRatio = img.width / img.height;
                    const isMobile = aspectRatio < 0.7; // Mobile screenshots are taller
                    
                    // Create canvas to sample colors
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    // Sample pixels to detect dark mode
                    const imageData = ctx.getImageData(0, 0, 100, 100);
                    const data = imageData.data;
                    let avgBrightness = 0;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        avgBrightness += (data[i] + data[i+1] + data[i+2]) / 3;
                    }
                    avgBrightness = avgBrightness / (data.length / 4);
                    
                    const isDark = avgBrightness < 128;
                    
                    resolve({
                        type: isMobile ? 'mobile' : 'desktop',
                        theme: isDark ? 'dark' : 'light',
                        width: img.width,
                        height: img.height
                    });
                };
                img.src = imageDataUrl;
            });
        }
        
        // Ultra preprocessing for maximum OCR accuracy
        async function ultraPreprocessImage(imageDataUrl, screenshotType) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Scale up significantly for better OCR
                    const scale = 4;
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    
                    // Apply best settings based on screenshot type
                    if (screenshotType.theme === 'dark') {
                        // For dark theme, invert colors first
                        ctx.filter = 'invert(1) contrast(1.5) brightness(1.2)';
                    } else {
                        // For light theme, increase contrast
                        ctx.filter = 'contrast(2) brightness(1.1) saturate(0)';
                    }
                    
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Get image data for pixel manipulation
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Apply aggressive thresholding for text
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        
                        // Aggressive threshold for text
                        let value;
                        if (screenshotType.theme === 'dark') {
                            // Inverted threshold for dark mode
                            value = gray > 110 ? 255 : 0;
                        } else {
                            // Normal threshold for light mode
                            value = gray < 140 ? 0 : 255;
                        }
                        
                        data[i] = value;
                        data[i + 1] = value;
                        data[i + 2] = value;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.src = imageDataUrl;
            });
        }
        
        // Alternative player detection when OCR fails
        function alternativePlayerDetection(imageDataUrl) {
            console.log('Using alternative player detection...');
            
            showUploadStatus(`
                <div class="fpl-warning">‚ö†Ô∏è OCR couldn't detect players clearly</div>
                <div>Would you like to:</div>
                <div style="margin-top: 15px;">
                    <button onclick="showInteractivePlayerSelection('${imageDataUrl}')" style="margin: 5px; padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Manually Select Players
                    </button>
                    <button onclick="useQuickFallback()" style="margin: 5px; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Load Popular Team
                    </button>
                </div>
            `, 'warning');
        }
        
        // Process OCR results with ultra accuracy
        function processOCRResultsUltra(ocrData, originalImage) {
            console.log('Processing OCR with simplified approach...');
            
            const text = ocrData.text || '';
            const words = ocrData.words || [];
            const lines = ocrData.lines || [];
            
            // Debug: Show raw OCR text
            console.log('=== RAW OCR TEXT ===');
            console.log(text);
            console.log('===================');
            
            // Wait for FPL data if needed
            if (!window.fplData || !window.fplData.loaded) {
                console.log('Waiting for FPL data...');
                setTimeout(() => {
                    if (window.fplData && window.fplData.loaded) {
                        processOCRResultsUltra(ocrData, originalImage);
                    } else {
                        useQuickFallback();
                    }
                }, 1000);
                return;
            }
            
            // Simple approach: Just find player names that exist in our database
            const foundPlayers = findPlayersSimple(text);
            
            if (foundPlayers.length > 0) {
                console.log(`Found ${foundPlayers.length} players`);
                showInteractiveVerification(foundPlayers, originalImage);
            } else {
                // Show debug mode
                showDebugMode(text, originalImage);
            }
        }
        
        // Preprocess image for better OCR accuracy on FPL screenshots
        async function preprocessImageForOCR(imageDataUrl, mode = 'highContrast') {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Scale up for better OCR (3x size for small text)
                    const scale = 3;
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    
                    // Draw with high quality
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Get image data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Process pixels based on mode
                    if (mode === 'highContrast') {
                        // High contrast black and white
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                            const value = gray < 128 ? 0 : 255;
                            data[i] = value;
                            data[i + 1] = value;
                            data[i + 2] = value;
                        }
                    } else if (mode === 'inverted') {
                        // Inverted colors for dark mode screenshots
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                            // Invert and threshold
                            const inverted = 255 - gray;
                            const value = inverted < 128 ? 0 : 255;
                            data[i] = value;
                            data[i + 1] = value;
                            data[i + 2] = value;
                        }
                    } else if (mode === 'enhanced') {
                        // Enhanced with better edge detection
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                            // Multi-level thresholding for text
                            let value;
                            if (gray < 90) value = 0;
                            else if (gray > 170) value = 255;
                            else value = gray < 130 ? 0 : 255;
                            data[i] = value;
                            data[i + 1] = value;
                            data[i + 2] = value;
                        }
                    } else {
                        // Adaptive threshold
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                            let value;
                            if (gray < 100) value = 0;
                            else if (gray > 200) value = 255;
                            else value = gray < 150 ? 0 : 255;
                            data[i] = value;
                            data[i + 1] = value;
                            data[i + 2] = value;
                        }
                    }
                    
                    // Put processed image back
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Add sharpening filter
                    ctx.filter = 'contrast(1.4) brightness(1.1)';
                    ctx.drawImage(canvas, 0, 0);
                    
                    // Return enhanced image
                    resolve(canvas.toDataURL('image/png'));
                };
                img.src = imageDataUrl;
            });
        }
        
        // Ultra-enhanced player finding with comprehensive nickname database
        function findPlayersSimple(text) {
            console.log('üöÄ Ultra-Enhanced OCR Detection - Finding all 15 players...');
            
            if (!window.fplData || !window.fplData.loaded) return [];
            
            // Comprehensive nickname database for FPL
            const nicknames = {
                // Common FPL abbreviations
                'TAA': 'Alexander-Arnold', 'TRENT': 'Alexander-Arnold',
                'ROBBO': 'Robertson', 'VVD': 'van Dijk', 'VIRGIL': 'van Dijk',
                'KDB': 'De Bruyne', 'DEBRUYNE': 'De Bruyne', 'KEVIN': 'De Bruyne',
                'BRUNO': 'Fernandes', 'BRUNO F': 'Fernandes',
                'MO': 'Salah', 'MOHAMED': 'Salah', 'SONNY': 'Son', 'SON': 'Heung-min',
                'RASHY': 'Rashford', 'RASH': 'Rashford', 'MARCUS': 'Rashford',
                'HAALAND': 'Haaland', 'ERLING': 'Haaland',
                'SAKA': 'Saka', 'BUKAYO': 'Saka',
                'MARTINELLI': 'Martinelli', 'GABI': 'Martinelli', 'GABRIEL M': 'Martinelli',
                'MITOMA': 'Mitoma', 'KAORU': 'Mitoma',
                'BOWEN': 'Bowen', 'JARROD': 'Bowen',
                'MADDISON': 'Maddison', 'MADDERS': 'Maddison', 'JAMES': 'Maddison',
                'WATKINS': 'Watkins', 'OLLIE': 'Watkins',
                'GORDON': 'Gordon', 'ANTHONY': 'Gordon',
                'PALMER': 'Palmer', 'COLE': 'Palmer',
                'ISAK': 'Isak', 'ALEX': 'Isak', 'ALEXANDER': 'Isak',
                'SOLANKE': 'Solanke', 'DOM': 'Solanke', 'DOMINIC': 'Solanke',
                'JACKSON': 'Jackson', 'NICOLAS': 'Jackson',
                'DARWIN': 'N√∫√±ez', 'NUNEZ': 'N√∫√±ez',
                'JOTA': 'Jota', 'DIOGO': 'Jota',
                'ALISSON': 'Alisson', 'ALI': 'Alisson',
                'EDERSON': 'Ederson', 'RAMSDALE': 'Ramsdale', 'AARON': 'Ramsdale',
                'POPE': 'Pope', 'NICK': 'Pope',
                'SANCHEZ': 'S√°nchez', 'ROBERT': 'S√°nchez',
                'RAYA': 'Raya', 'DAVID': 'Raya',
                'ONANA': 'Onana', 'ANDRE': 'Onana',
                'VICARIO': 'Vicario', 'GUGLIELMO': 'Vicario',
                // Common bench players
                'NETO': 'Neto', 'PEDRO': 'Neto',
                'ESR': 'Smith Rowe', 'SMITH ROWE': 'Smith Rowe', 'EMILE': 'Smith Rowe',
                'ROGERS': 'Rogers', 'MORGAN': 'Rogers',
                'ANDREAS': 'Pereira', 'PEREIRA': 'Pereira',
                'WARD': 'Ward', 'JOEL': 'Ward',
                'LIVRAMENTO': 'Livramento', 'TINO': 'Livramento', 'VALENTINO': 'Livramento',
                'COLWILL': 'Colwill', 'LEVI': 'Colwill',
                'KONSA': 'Konsa', 'EZRI': 'Konsa',
                'HALL': 'Hall', 'LEWIS': 'Hall',
                'GABRIEL': 'Gabriel', 'SALIBA': 'Saliba', 'WILLIAM': 'Saliba',
                'BURN': 'Burn', 'DAN': 'Burn',
                'BOTMAN': 'Botman', 'SVEN': 'Botman',
                'GUEHI': 'Gu√©hi', 'MARC': 'Gu√©hi',
                'ANDERSEN': 'Andersen', 'JOACHIM': 'Andersen',
                'DUNK': 'Dunk', 'LEWIS D': 'Dunk',
                // Goalkeeper subs
                'FABIANSKI': 'Fabia≈Ñski', 'LUKASZ': 'Fabia≈Ñski',
                'HENDERSON': 'Henderson', 'DEAN': 'Henderson',
                'STEELE': 'Steele', 'JASON': 'Steele',
                'TURNER': 'Turner', 'MATT': 'Turner',
                // Common misspellings/OCR errors
                'HALAND': 'Haaland', 'HALLAND': 'Haaland',
                'FERNANDES': 'Fernandes', 'BRUNO FERNANDES': 'Fernandes',
                'ALEXANDERARNOLD': 'Alexander-Arnold', 'ARNOLD': 'Alexander-Arnold',
                'DE BRUYNE': 'De Bruyne', 'VANDIJK': 'van Dijk', 'VAN DIJK': 'van Dijk'
            };
            
            const foundPlayers = [];
            const textUpper = text.toUpperCase();
            const addedPlayerIds = new Set();
            const unmatchedWords = [];
            
            // Split text multiple ways for better detection
            const lines = text.split(/[\n\r]+/);
            const words = textUpper.split(/[\s\n\r,.()¬£]+/).filter(w => w.length > 1);
            const allWords = text.split(/[\s\n\r,.()¬£]+/).filter(w => w.length > 1);
            
            console.log(`üìä Text analysis: ${lines.length} lines, ${words.length} words`);
            
            // Track which words we've matched
            const matchedWords = new Set();
            
            // Strategy 1: Check nicknames first (highest priority)
            console.log('üîç Strategy 1: Checking nicknames...');
            for (const [nick, playerName] of Object.entries(nicknames)) {
                if (textUpper.includes(nick)) {
                    const player = window.fplData.players.find(p => 
                        p.fullName.toUpperCase().includes(playerName.toUpperCase()) ||
                        p.name.toUpperCase().includes(playerName.toUpperCase())
                    );
                    if (player && !addedPlayerIds.has(player.id)) {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        foundPlayers.push({
                            position: positionMap[player.position],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id,
                            confidence: 95,
                            matchType: 'nickname'
                        });
                        addedPlayerIds.add(player.id);
                        matchedWords.add(nick);
                        console.log(`‚úÖ Nickname: ${nick} ‚Üí ${player.name}`);
                    }
                }
            }
            
            // Strategy 2: Check each line for player names
            console.log('üîç Strategy 2: Checking lines...');
            lines.forEach((line, idx) => {
                const lineUpper = line.toUpperCase().trim();
                if (lineUpper.length < 2) return;
                
                window.fplData.players.forEach(player => {
                    if (addedPlayerIds.has(player.id)) return;
                    
                    const playerName = player.name.toUpperCase();
                    const fullName = player.fullName.toUpperCase();
                    const lastName = fullName.split(' ').pop();
                    
                    if (lineUpper.includes(playerName) || 
                        (lastName.length > 3 && lineUpper.includes(lastName))) {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        foundPlayers.push({
                            position: positionMap[player.position],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id,
                            confidence: 90,
                            matchType: 'line'
                        });
                        addedPlayerIds.add(player.id);
                        matchedWords.add(playerName);
                        console.log(`‚úÖ Line ${idx+1}: ${player.name}`);
                    }
                });
            });
            
            // Strategy 3: Check each word individually
            console.log('üîç Strategy 3: Checking individual words...');
            words.forEach(word => {
                if (word.length < 3 || matchedWords.has(word)) return;
                
                window.fplData.players.forEach(player => {
                    if (addedPlayerIds.has(player.id)) return;
                    
                    const playerName = player.name.toUpperCase();
                    const fullName = player.fullName.toUpperCase();
                    const lastName = fullName.split(' ').pop();
                    const firstName = fullName.split(' ')[0];
                    
                    if (word === playerName) {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        foundPlayers.push({
                            position: positionMap[player.position],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id,
                            confidence: 100,
                            matchType: 'exact'
                        });
                        addedPlayerIds.add(player.id);
                        matchedWords.add(word);
                        console.log(`‚úÖ Exact word: ${player.name}`);
                    }
                    else if (word === lastName && lastName.length > 3) {
                        const sameLastName = window.fplData.players.filter(p => 
                            p.fullName.toUpperCase().endsWith(lastName)
                        );
                        if (sameLastName.length <= 2) {
                            const team = window.fplData.teams.find(t => t.id === player.team);
                            foundPlayers.push({
                                position: positionMap[player.position],
                                name: player.name,
                                team: team ? team.short_name : 'Unknown',
                                price: player.price.toFixed(1),
                                playerId: player.id,
                                confidence: 85,
                                matchType: 'lastName'
                            });
                            addedPlayerIds.add(player.id);
                            matchedWords.add(word);
                            console.log(`‚úÖ Last name: ${player.name}`);
                        }
                    }
                });
            });
            
            // Strategy 4: Common bench/budget players - always check these
            console.log(`üîç Strategy 4: Checking common bench players...`);
            
            const commonBenchPlayers = [
                'Steele', 'Ward', 'Matthews', 'Turner', 'Fabianski', 'Johnstone',
                'Livramento', 'Burn', 'Dunk', 'Andersen', 'Mitchell', 'Taylor', 'Kelly',
                'Andreas', 'Smith Rowe', 'Rogers', 'Brownhill', 'Reed', 'Elneny', 'Longstaff',
                'Archer', 'Greenwood', 'Morris', 'Brereton', 'Stansfield'
            ];
            
            commonBenchPlayers.forEach(name => {
                const nameUpper = name.toUpperCase();
                if (textUpper.includes(nameUpper)) {
                    const player = window.fplData.players.find(p => 
                        p.name.toUpperCase().includes(nameUpper) ||
                        p.fullName.toUpperCase().includes(nameUpper)
                    );
                    if (player && !addedPlayerIds.has(player.id)) {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        foundPlayers.push({
                            position: positionMap[player.position],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id,
                            confidence: 80,
                            matchType: 'benchPlayer'
                        });
                        addedPlayerIds.add(player.id);
                        matchedWords.add(nameUpper);
                        console.log(`‚úÖ Bench: ${player.name}`);
                    }
                }
            });
            
            // Strategy 5: Fuzzy matching with Levenshtein distance
            if (foundPlayers.length < 15) {
                console.log(`üîç Strategy 5: Fuzzy matching (need ${15-foundPlayers.length} more)...`);
                
                // Check each unmatched word with fuzzy matching
                words.forEach(word => {
                    if (word.length >= 3 && !matchedWords.has(word) && foundPlayers.length < 15) {
                        let bestMatch = null;
                        let bestDistance = Infinity;
                        
                        window.fplData.players.forEach(player => {
                            if (addedPlayerIds.has(player.id)) return;
                            
                            const playerName = player.name.toUpperCase();
                            const lastName = player.fullName.toUpperCase().split(' ').pop();
                            
                            // Calculate Levenshtein distance
                            const nameDistance = levenshteinDistance(word, playerName);
                            const lastNameDistance = levenshteinDistance(word, lastName);
                            const minDistance = Math.min(nameDistance, lastNameDistance);
                            
                            // Accept if distance is <= 2 (allows for OCR errors)
                            if (minDistance <= 2 && minDistance < bestDistance) {
                                bestDistance = minDistance;
                                bestMatch = player;
                            }
                        });
                        
                        if (bestMatch && !addedPlayerIds.has(bestMatch.id)) {
                            const team = window.fplData.teams.find(t => t.id === bestMatch.team);
                            foundPlayers.push({
                                position: positionMap[bestMatch.position],
                                name: bestMatch.name,
                                team: team ? team.short_name : 'Unknown',
                                price: bestMatch.price.toFixed(1),
                                playerId: bestMatch.id,
                                confidence: 70 - (bestDistance * 10),
                                matchType: 'fuzzy'
                            });
                            addedPlayerIds.add(bestMatch.id);
                            matchedWords.add(word);
                            console.log(`‚úÖ Fuzzy match: ${word} ‚Üí ${bestMatch.name} (distance: ${bestDistance})`);
                        }
                    }
                });
            }
            
            // Strategy 6: Fill remaining with most popular FPL players by position
            if (foundPlayers.length < 15) {
                console.log(`üîç Strategy 6: Adding popular players (need ${15-foundPlayers.length} more)...`);
                
                // Count positions we have
                const positionCounts = { GK: 0, DEF: 0, MID: 0, FWD: 0 };
                foundPlayers.forEach(p => positionCounts[p.position]++);
                
                // Popular players by position (most owned in FPL)
                const popularPlayers = {
                    GK: ['Raya', 'Alisson', 'Ederson', 'Pope', 'Sanchez', 'Steele'],
                    DEF: ['Alexander-Arnold', 'Robertson', 'Saliba', 'Gabriel', 'Trippier', 'Livramento', 'Dunk'],
                    MID: ['Salah', 'Palmer', 'Saka', 'Son', 'Gordon', 'Mbeumo', 'Andreas'],
                    FWD: ['Haaland', 'Watkins', 'Solanke', 'Jackson', 'Archer']
                };
                
                // Fill missing positions
                ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                    const needed = (pos === 'GK' ? 2 : pos === 'DEF' ? 5 : pos === 'MID' ? 5 : 3) - positionCounts[pos];
                    if (needed > 0) {
                        const popularList = popularPlayers[pos];
                        for (let i = 0; i < needed && i < popularList.length; i++) {
                            const playerName = popularList[i];
                            const player = window.fplData?.players.find(p => 
                                p.name.includes(playerName) && !addedPlayerIds.has(p.id)
                            );
                            if (player) {
                                const team = window.fplData.teams.find(t => t.id === player.team);
                                foundPlayers.push({
                                    position: pos,
                                    name: player.name,
                                    team: team ? team.short_name : 'Unknown',
                                    price: player.price.toFixed(1),
                                    playerId: player.id,
                                    confidence: 50,
                                    matchType: 'popular'
                                });
                                addedPlayerIds.add(player.id);
                                console.log(`‚úÖ Popular: ${player.name} (${pos})`);
                            }
                        }
                    }
                });
            }
            
            // Track unmatched words for hints
            allWords.forEach(word => {
                const wordUpper = word.toUpperCase();
                if (!matchedWords.has(wordUpper) && word.length > 2 && 
                    !['THE', 'AND', 'FOR', 'WITH', 'FROM', 'YOUR', 'TEAM', 'FPL', 'FANTASY', 
                      'PREMIER', 'LEAGUE', 'POINTS', 'PRICE', 'GAMEWEEK', 'GW'].includes(wordUpper)) {
                    unmatchedWords.push(word);
                }
            });
            
            // Store for later use
            window.unmatchedOCRWords = unmatchedWords.slice(0, 30);
            
            // Log position breakdown
            const positionCounts = { GK: 0, DEF: 0, MID: 0, FWD: 0 };
            foundPlayers.forEach(p => positionCounts[p.position]++);
            
            console.log(`‚ú® Detection complete: ${foundPlayers.length}/15 players found`);
            console.log(`üìç Positions - GK: ${positionCounts.GK}/2, DEF: ${positionCounts.DEF}/5, MID: ${positionCounts.MID}/5, FWD: ${positionCounts.FWD}/3`);
            
            if (unmatchedWords.length > 0 && foundPlayers.length < 15) {
                console.log(`‚ùì Unmatched words: ${unmatchedWords.slice(0, 10).join(', ')}`);
            }
            
            return foundPlayers;
        }
        
        // Show debug mode when OCR fails
        function showDebugMode(ocrText, originalImage) {
            console.log('Showing debug mode...');
            
            showUploadStatus(`
                <div style="text-align: center;">
                    <div class="fpl-warning">‚ö†Ô∏è OCR couldn't find players</div>
                    <div style="margin: 10px 0;">Here's what the OCR saw:</div>
                    <div style="max-height: 200px; overflow-y: auto; background: #f5f5f5; border: 1px solid #dfdfdf; border-radius: 4px; padding: 10px; text-align: left; font-family: monospace; font-size: 11px; margin: 10px 0;">
                        ${ocrText || 'No text detected'}
                    </div>
                    <div style="margin-top: 15px;">
                        <button onclick="tryManualEntry()" style="margin: 5px; padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Enter Players Manually
                        </button>
                        <button onclick="useQuickFallback()" style="margin: 5px; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Use Popular Team
                        </button>
                    </div>
                </div>
            `, 'warning');
        }
        
        // Manual entry mode
        window.tryManualEntry = function() {
            showUploadStatus(`
                <div style="text-align: center;">
                    <div class="fpl-tips">üìù <strong>Manual Player Entry</strong></div>
                    <div>Type player names (one per line):</div>
                    <textarea id="manualPlayerInput" style="width: 90%; height: 200px; margin: 10px 0; padding: 10px; border: 1px solid #dfdfdf; border-radius: 4px; font-family: monospace;" 
                              placeholder="Example:
Haaland
Salah
Palmer
Saka
..."></textarea>
                    <div>
                        <button onclick="processManualEntry()" style="margin: 5px; padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Process Names
                        </button>
                    </div>
                </div>
            `, 'info');
        };
        
        // Add missing players manually
        window.addMissingPlayers = function() {
            const currentPlayers = window.detectedPlayersForVerification || [];
            const missingCount = 15 - currentPlayers.length;
            
            let html = `
                <div style="text-align: center;">
                    <div class="fpl-tips">üîç <strong>Add ${missingCount} Missing Players</strong></div>
                    <div style="margin: 10px 0;">Enter the missing player names (usually bench players):</div>
                    <textarea id="missingPlayerInput" style="width: 90%; height: 150px; margin: 10px 0; padding: 10px; border: 1px solid #dfdfdf; border-radius: 4px; font-family: monospace;" 
                              placeholder="Example:\nNeto\nFerguson\nLewis"></textarea>
                    <div style="margin-top: 10px;">
                        <button onclick="processMissingPlayers()" style="margin: 5px; padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Add These Players
                        </button>
                        <button onclick="showInteractiveVerification(window.detectedPlayersForVerification, null)" style="margin: 5px; padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Back
                        </button>
                    </div>
            `;
            
            // Show unmatched words as hints
            if (window.unmatchedOCRWords && window.unmatchedOCRWords.length > 0) {
                html += `
                    <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 4px; text-align: left;">
                        <strong>Hint - unmatched text from screenshot:</strong><br>
                        <small style="color: #666; font-family: monospace;">${window.unmatchedOCRWords.join(', ')}</small>
                    </div>
                `;
            }
            
            html += `</div>`;
            
            showUploadStatus(html, 'info');
        };
        
        // Process the missing players
        window.processMissingPlayers = function() {
            const input = document.getElementById('missingPlayerInput').value;
            if (!input.trim()) return;
            
            const names = input.split('\n').filter(n => n.trim());
            const foundPlayers = [];
            const notFound = [];
            
            names.forEach(name => {
                const nameUpper = name.trim().toUpperCase();
                
                // Find in database - be more flexible
                const player = window.fplData.players.find(p => {
                    const pName = p.name.toUpperCase();
                    const pFullName = p.fullName.toUpperCase();
                    const pLastName = pFullName.split(' ').pop();
                    
                    return pName === nameUpper ||
                           pFullName === nameUpper ||
                           pLastName === nameUpper ||
                           pName.includes(nameUpper) ||
                           (nameUpper.length > 3 && pFullName.includes(nameUpper));
                });
                
                if (player) {
                    const team = window.fplData.teams.find(t => t.id === player.team);
                    foundPlayers.push({
                        position: positionMap[player.position],
                        name: player.name,
                        team: team ? team.short_name : 'Unknown',
                        price: player.price.toFixed(1),
                        playerId: player.id,
                        confidence: 100
                    });
                } else {
                    notFound.push(name);
                }
            });
            
            // Combine with existing detected players
            const allPlayers = [...window.detectedPlayersForVerification, ...foundPlayers];
            
            if (notFound.length > 0) {
                alert(`Could not find: ${notFound.join(', ')}\nPlease check the spelling.`);
            }
            
            // Show updated verification
            window.detectedPlayersForVerification = allPlayers;
            showInteractiveVerification(allPlayers, null);
        };
        
        // Process manually entered names
        window.processManualEntry = function() {
            const input = document.getElementById('manualPlayerInput').value;
            if (!input.trim()) return;
            
            const names = input.split('\n').filter(n => n.trim());
            const foundPlayers = [];
            
            names.forEach(name => {
                const nameUpper = name.trim().toUpperCase();
                
                // Find in database
                const player = window.fplData.players.find(p => 
                    p.name.toUpperCase() === nameUpper ||
                    p.fullName.toUpperCase().includes(nameUpper) ||
                    p.fullName.split(' ').pop().toUpperCase() === nameUpper
                );
                
                if (player) {
                    const team = window.fplData.teams.find(t => t.id === player.team);
                    foundPlayers.push({
                        position: positionMap[player.position],
                        name: player.name,
                        team: team ? team.short_name : 'Unknown',
                        price: player.price.toFixed(1),
                        playerId: player.id,
                        confidence: 100
                    });
                }
            });
            
            if (foundPlayers.length > 0) {
                showInteractiveVerification(foundPlayers, null);
            } else {
                alert('No players found. Please check the names and try again.');
            }
        };
        
        // Ultra-accurate OCR text processing
        function processOCRTextUltra(text, words, lines) {
            console.log('Ultra-accurate OCR text processing...');
            
            const detectedPlayers = [];
            
            // Ensure FPL data is loaded
            if (!window.fplData || !window.fplData.loaded) {
                console.log('FPL data not ready');
                useQuickFallback();
                return detectedPlayers;
            }
            
            // Clean and normalize the text - keep more characters for FPL
            const cleanedText = text.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim().toUpperCase();
            const textLines = text.split(/[\r\n]+/).filter(l => l.trim().length > 0);
            const textWords = cleanedText.split(/\s+/).filter(w => w.length > 1);
            
            // Also extract potential player names by patterns
            const potentialNames = [];
            
            // Pattern 1: Capital letter followed by lowercase letters (typical names)
            const namePattern1 = /[A-Z][a-z]+/g;
            const matches1 = text.match(namePattern1) || [];
            potentialNames.push(...matches1.map(m => m.toUpperCase()));
            
            // Pattern 2: All caps words (some players shown in all caps)
            const namePattern2 = /[A-Z]{3,}/g;
            const matches2 = text.match(namePattern2) || [];
            potentialNames.push(...matches2);
            
            // Pattern 3: Look for patterns like "Name (C)" or "Name (V)"
            const captainPattern = /([A-Za-z\s\-]+)\s*\([CV]\)/g;
            const captainMatches = text.match(captainPattern) || [];
            captainMatches.forEach(match => {
                const name = match.replace(/\s*\([CV]\)/, '').trim();
                potentialNames.push(name.toUpperCase());
            });
            
            console.log('Cleaned text:', cleanedText);
            console.log('Text lines:', textLines);
            console.log('Text words:', textWords);
            console.log('Potential player names found:', potentialNames);
            
            // Enhanced FPL player database with common OCR mistakes
            const playerDatabase = {
                // Forwards
                'HAALAND': ['HAALAND', 'ERLING', 'E.HAALAND', 'E HAALAND', 'HALAND', 'HALAAND', 'HAALAND'],
                'WATKINS': ['WATKINS', 'OLLIE', 'O.WATKINS', 'O WATKINS'],
                'ISAK': ['ISAK', 'ALEXANDER', 'A.ISAK', 'A ISAK'],
                'JACKSON': ['JACKSON', 'NICOLAS', 'N.JACKSON', 'N JACKSON'],
                'SOLANKE': ['SOLANKE', 'DOMINIC', 'D.SOLANKE', 'D SOLANKE'],
                'DARWIN': ['DARWIN', 'NUNEZ', 'DARWIN NUNEZ', 'D.NUNEZ', 'D NUNEZ'],
                'JESUS': ['JESUS', 'GABRIEL', 'G.JESUS', 'G JESUS', 'GABRIEL JESUS'],
                'TONEY': ['TONEY', 'IVAN', 'I.TONEY', 'I TONEY'],
                'WOOD': ['WOOD', 'CHRIS', 'C.WOOD', 'C WOOD'],
                // Midfielders
                'SALAH': ['SALAH', 'MOHAMED', 'MO SALAH', 'M.SALAH', 'M SALAH', 'MO'],
                'PALMER': ['PALMER', 'COLE', 'C.PALMER', 'C PALMER', 'COLE PALMER'],
                'SAKA': ['SAKA', 'BUKAYO', 'B.SAKA', 'B SAKA'],
                'SON': ['SON', 'HEUNG-MIN', 'SON HEUNG-MIN', 'H.SON', 'H SON', 'SONNY'],
                'FERNANDES': ['FERNANDES', 'BRUNO', 'B.FERNANDES', 'B FERNANDES', 'BRUNO F'],
                'FODEN': ['FODEN', 'PHIL', 'P.FODEN', 'P FODEN'],
                'GORDON': ['GORDON', 'ANTHONY', 'A.GORDON', 'A GORDON'],
                'MBEUMO': ['MBEUMO', 'BRYAN', 'B.MBEUMO', 'B MBEUMO'],
                'BOWEN': ['BOWEN', 'JARROD', 'J.BOWEN', 'J BOWEN'],
                'MARTINELLI': ['MARTINELLI', 'GABRIEL', 'G.MARTINELLI', 'GABI'],
                'ODEGAARD': ['ODEGAARD', 'MARTIN', 'M.ODEGAARD', '√òDEGAARD'],
                'RASHFORD': ['RASHFORD', 'MARCUS', 'M.RASHFORD', 'M RASHFORD'],
                'MADDISON': ['MADDISON', 'JAMES', 'J.MADDISON', 'J MADDISON', 'MADDERS'],
                'RICE': ['RICE', 'DECLAN', 'D.RICE', 'D RICE'],
                'HAVERTZ': ['HAVERTZ', 'KAI', 'K.HAVERTZ', 'K HAVERTZ'],
                'DIAZ': ['DIAZ', 'LUIS', 'L.DIAZ', 'L DIAZ', 'LUCHO'],
                'JOTA': ['JOTA', 'DIOGO', 'D.JOTA', 'D JOTA'],
                // Defenders
                'ALEXANDER-ARNOLD': ['ALEXANDER-ARNOLD', 'TAA', 'TRENT', 'T.ALEXANDER-ARNOLD', 'TRENT AA'],
                'ROBERTSON': ['ROBERTSON', 'ANDY', 'ROBBO', 'A.ROBERTSON', 'A ROBERTSON'],
                'VIRGIL': ['VIRGIL', 'VAN DIJK', 'VVD', 'V.VAN DIJK', 'VANDIJK'],
                'SALIBA': ['SALIBA', 'WILLIAM', 'W.SALIBA', 'W SALIBA'],
                'GABRIEL': ['GABRIEL', 'GABRIEL M', 'GABRIEL MAG', 'G.MAGALHAES'],
                'WHITE': ['WHITE', 'BEN', 'B.WHITE', 'B WHITE'],
                'TRIPPIER': ['TRIPPIER', 'KIERAN', 'K.TRIPPIER', 'K TRIPPIER', 'TRIPPS'],
                'DIAS': ['DIAS', 'RUBEN', 'R.DIAS', 'R DIAS'],
                'STONES': ['STONES', 'JOHN', 'J.STONES', 'J STONES'],
                'WALKER': ['WALKER', 'KYLE', 'K.WALKER', 'K WALKER'],
                'GVARDIOL': ['GVARDIOL', 'JOSKO', 'J.GVARDIOL', 'J GVARDIOL'],
                'ROMERO': ['ROMERO', 'CRISTIAN', 'C.ROMERO', 'C ROMERO', 'CUTI'],
                'PORRO': ['PORRO', 'PEDRO', 'P.PORRO', 'P PORRO'],
                'UDOGIE': ['UDOGIE', 'DESTINY', 'D.UDOGIE', 'D UDOGIE'],
                // Goalkeepers
                'ALISSON': ['ALISSON', 'ALISSON B', 'ALISSON BECKER', 'A.BECKER'],
                'EDERSON': ['EDERSON', 'EDERSON M', 'E.MORAES'],
                'RAYA': ['RAYA', 'DAVID', 'D.RAYA', 'D RAYA'],
                'MARTINEZ': ['MARTINEZ', 'EMI', 'E.MARTINEZ', 'EMILIANO', 'EMI MARTINEZ'],
                'PICKFORD': ['PICKFORD', 'JORDAN', 'J.PICKFORD', 'J PICKFORD'],
                'POPE': ['POPE', 'NICK', 'N.POPE', 'N POPE'],
                'ONANA': ['ONANA', 'ANDRE', 'A.ONANA', 'A ONANA'],
                'VICARIO': ['VICARIO', 'GUGLIELMO', 'G.VICARIO', 'G VICARIO']
            };
            
            // Flatten all variations for searching
            const allPlayerVariations = [];
            Object.entries(playerDatabase).forEach(([key, variations]) => {
                variations.forEach(v => allPlayerVariations.push({ key, variation: v }));
            });
            
            // First pass: Look for exact matches of player variations
            const foundByExact = [];
            
            // Check in cleaned text
            allPlayerVariations.forEach(({ key, variation }) => {
                if (cleanedText.includes(variation)) {
                    console.log(`‚úÖ Found player variation in text: ${variation} -> ${key}`);
                    if (!foundByExact.find(f => f.key === key)) {
                        foundByExact.push({ key, variation });
                    }
                }
            });
            
            // Also check in potential names
            potentialNames.forEach(name => {
                allPlayerVariations.forEach(({ key, variation }) => {
                    if (name === variation || name.includes(variation) || variation.includes(name)) {
                        console.log(`‚úÖ Found in potential names: ${name} matches ${variation} -> ${key}`);
                        if (!foundByExact.find(f => f.key === key)) {
                            foundByExact.push({ key, variation, source: 'pattern' });
                        }
                    }
                });
            });
            
            // Also check individual lines for better accuracy
            textLines.forEach(line => {
                const lineUpper = line.toUpperCase().trim();
                allPlayerVariations.forEach(({ key, variation }) => {
                    if (lineUpper.includes(variation) || lineUpper === variation) {
                        console.log(`‚úÖ Found in line: ${variation} -> ${key}`);
                        if (!foundByExact.find(f => f.key === key)) {
                            foundByExact.push({ key, variation });
                        }
                    }
                });
            });
            
            // Calculate Levenshtein distance for fuzzy matching
            function levenshteinDistance(str1, str2) {
                const matrix = [];
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                return matrix[str2.length][str1.length];
            }
            
            // First, try to match the common players we found
            const playerMatches = [];
            
            // Priority matching for players we explicitly found
            foundByExact.forEach(({ key, variation }) => {
                // Find the player in database
                const player = window.fplData.players.find(p => {
                    const nameUpper = p.name.toUpperCase();
                    const fullNameUpper = p.fullName.toUpperCase();
                    
                    // Check against all variations for this player
                    const variations = playerDatabase[key] || [];
                    return variations.some(v => 
                        nameUpper.includes(v) || 
                        fullNameUpper.includes(v) ||
                        v.includes(nameUpper) ||
                        (key === 'ALEXANDER-ARNOLD' && p.name === 'Alexander-Arnold') ||
                        (key === 'VIRGIL' && p.name === 'Virgil') ||
                        (key === 'DARWIN' && p.fullName.includes('Darwin')) ||
                        (key === 'GABRIEL' && p.name === 'Gabriel' && p.team === 1) || // Arsenal Gabriel
                        (key === 'JESUS' && p.name === 'Jesus' && p.team === 1) // Arsenal Jesus
                    );
                });
                
                if (player) {
                    playerMatches.push({ player, confidence: 100 });
                    console.log(`‚úÖ Matched: ${variation} ‚Üí ${player.fullName} (${player.name})`);
                } else {
                    console.log(`‚ö†Ô∏è Could not match ${variation} (${key}) to database`);
                }
            });
            
            // Then check all players for matches
            window.fplData.players.forEach(player => {
                // Skip if already found
                if (playerMatches.find(m => m.player.id === player.id)) return;
                
                const playerName = player.name.toUpperCase();
                const playerFullName = player.fullName.toUpperCase();
                const lastName = playerFullName.split(' ').pop();
                
                // Check for exact matches in text
                if (cleanedText.includes(playerName)) {
                    playerMatches.push({ player, confidence: 95 });
                    console.log(`Exact name match: ${player.name}`);
                    return;
                }
                
                if (cleanedText.includes(playerFullName)) {
                    playerMatches.push({ player, confidence: 95 });
                    console.log(`Exact full name match: ${player.fullName}`);
                    return;
                }
                
                // Check for last name matches (for unique last names)
                if (lastName.length > 4 && cleanedText.includes(lastName)) {
                    // Check it's not part of another word
                    const regex = new RegExp(`\\b${lastName}\\b`);
                    if (regex.test(cleanedText)) {
                        playerMatches.push({ player, confidence: 85 });
                        console.log(`Last name match: ${player.name} (${lastName})`);
                        return;
                    }
                }
                
                // Only do fuzzy matching if we have few exact matches
                if (playerMatches.length < 15) {
                    textWords.forEach(word => {
                        if (word.length < 4) return;
                        
                        // Check similarity with player name
                        const nameDistance = levenshteinDistance(word, playerName);
                        const lastNameDistance = levenshteinDistance(word, lastName);
                        
                        // Very close matches only (1 character different)
                        if (nameDistance === 1 && playerName.length > 4) {
                            playerMatches.push({ player, confidence: 70 });
                            console.log(`Close match: ${word} ‚Üí ${player.name} (distance: ${nameDistance})`);
                        } else if (lastNameDistance === 1 && lastName.length > 5) {
                            playerMatches.push({ player, confidence: 65 });
                            console.log(`Close last name: ${word} ‚Üí ${player.name} (${lastName})`);
                        }
                    });
                }
            });
            
            // Sort by confidence and remove duplicates
            playerMatches.sort((a, b) => b.confidence - a.confidence);
            const uniquePlayers = new Map();
            
            playerMatches.forEach(match => {
                if (!uniquePlayers.has(match.player.id)) {
                    uniquePlayers.set(match.player.id, match);
                }
            });
            
            // Convert to detected players format
            uniquePlayers.forEach(match => {
                const player = match.player;
                const team = window.fplData.teams.find(t => t.id === player.team);
                
                detectedPlayers.push({
                    position: positionMap[player.position],
                    name: player.name,
                    team: team ? team.short_name : 'Unknown',
                    price: player.price.toFixed(1),
                    playerId: player.id,
                    confidence: match.confidence
                });
            });
            
            console.log(`Found ${detectedPlayers.length} players from OCR`);
            console.log('Detected players:', detectedPlayers.map(p => `${p.name} (${p.confidence}%)`) );
            
            return detectedPlayers;
            
            // Validate detected players for accuracy
            const highConfidencePlayers = detectedPlayers.filter(p => p.confidence >= 85);
            const mediumConfidencePlayers = detectedPlayers.filter(p => p.confidence >= 70 && p.confidence < 85);
            const lowConfidencePlayers = detectedPlayers.filter(p => p.confidence < 70);
            
            // Additional validation: Check if players make sense together
            const validateTeamComposition = (players) => {
                const positions = { GK: 0, DEF: 0, MID: 0, FWD: 0 };
                players.forEach(p => positions[p.position]++);
                
                // FPL requires: 2 GK, 5 DEF, 5 MID, 3 FWD
                const isValid = positions.GK <= 2 && positions.DEF <= 5 && 
                               positions.MID <= 5 && positions.FWD <= 3;
                
                if (!isValid) {
                    console.log('Team composition validation failed:', positions);
                }
                return isValid;
            };
            
            console.log(`High confidence: ${highConfidencePlayers.length}, Medium: ${mediumConfidencePlayers.length}, Low: ${lowConfidencePlayers.length}`);
            
            // Build team with high confidence players first
            let finalTeam = [];
            
            // Add all high confidence players
            finalTeam.push(...highConfidencePlayers);
            
            // Add medium confidence players if needed
            if (finalTeam.length < 15) {
                const needed = 15 - finalTeam.length;
                finalTeam.push(...mediumConfidencePlayers.slice(0, needed));
            }
            
            // Only use low confidence if really needed
            if (finalTeam.length < 11) {
                const needed = 11 - finalTeam.length;
                finalTeam.push(...lowConfidencePlayers.slice(0, needed));
            }
            
            if (finalTeam.length >= 11) {
                // Validate team composition
                const isValidTeam = validateTeamComposition(finalTeam);
                
                if (!isValidTeam) {
                    console.log('Invalid team composition - attempting to fix...');
                    // Try to fix by removing duplicates or wrong positions
                    finalTeam = fixTeamComposition(finalTeam);
                }
                
                // Success! Display the detected team with confirmation
                const avgConfidence = Math.round(finalTeam.reduce((sum, p) => sum + p.confidence, 0) / finalTeam.length);
                
                showUploadStatus(`
                    <div class="fpl-tips">‚úÖ <strong>Successfully detected ${finalTeam.length} players!</strong></div>
                    <div>Confidence: ${avgConfidence}% average</div>
                    <div style="margin-top: 10px;">
                        <details>
                            <summary style="cursor: pointer; color: var(--secondary-color);">View detected players ‚ñº</summary>
                            <div style="margin-top: 10px; max-height: 200px; overflow-y: auto; font-size: 12px;">
                                ${finalTeam.map(p => `${p.position}: ${p.name} (${p.team}) - ${p.confidence}%`).join('<br>')}
                            </div>
                        </details>
                    </div>
                `, 'success');
                
                // Ensure we have exactly 15 players
                if (finalTeam.length > 15) {
                    finalTeam = finalTeam.slice(0, 15);
                } else if (finalTeam.length < 15) {
                    // Add some popular players to complete
                    completeWithTemplate(finalTeam);
                    return;
                }
                
                displayDetectedPlayers(finalTeam);
            } else if (finalTeam.length > 0) {
                // Partial success - show what we found and complete with template
                showUploadStatus(`
                    <div class="fpl-tips">‚úÖ Found ${finalTeam.length} players with good confidence</div>
                    <div>Adding popular players to complete your 15-player squad...</div>
                `, 'processing');
                setTimeout(() => completeWithTemplate(finalTeam), 1000);
            } else {
                // No reliable players found - try one more strategy
                console.log('No reliable players detected - trying fallback OCR strategy...');
                
                // Try to find any player names at all
                const anyPlayers = findAnyPlayersInText(cleanedText);
                
                if (anyPlayers.length > 0) {
                    console.log('Found some players with fallback strategy:', anyPlayers);
                    showUploadStatus(`
                        <div class="fpl-tips">‚úÖ Found ${anyPlayers.length} players using fallback detection</div>
                        <div>Completing team with popular picks...</div>
                    `, 'processing');
                    setTimeout(() => completeWithTemplate(anyPlayers), 1000);
                } else {
                    // Final fallback - manual selection
                    showUploadStatus(`
                        <div class="fpl-warning">‚ö†Ô∏è Could not detect players from screenshot</div>
                        <div>Please select players manually or try a clearer screenshot...</div>
                    `, 'warning');
                    setTimeout(() => {
                        showManualPlayerSelection();
                    }, 1500);
                }
            }
        }
        
        // Advanced OCR text processing with position awareness
        function processOCRTextAdvanced(text, words, lines, originalImage) {
            console.log('Advanced OCR processing...');
            
            const detectedPlayers = [];
            
            // Wait for FPL data
            if (!window.fplData || !window.fplData.loaded) {
                console.log('Waiting for FPL data...');
                setTimeout(() => {
                    if (window.fplData && window.fplData.loaded) {
                        processOCRTextAdvanced(text, words, lines, originalImage);
                    } else {
                        useQuickFallback();
                    }
                }, 2000);
                return;
            }
            
            // Create a map of all player names for faster lookup
            const playerMap = new Map();
            window.fplData.players.forEach(player => {
                // Add various name formats
                playerMap.set(player.name.toUpperCase(), player);
                playerMap.set(player.fullName.toUpperCase(), player);
                
                // Add last name only for unique cases
                const lastName = player.fullName.split(' ').pop();
                if (lastName.length > 4) {
                    playerMap.set(lastName.toUpperCase(), player);
                }
                
                // Add common abbreviations
                if (player.name === 'Alexander-Arnold') {
                    playerMap.set('TAA', player);
                    playerMap.set('TRENT', player);
                }
                if (player.name === 'Virgil') {
                    playerMap.set('VAN DIJK', player);
                    playerMap.set('VVD', player);
                }
            });
            
            // Process lines with position context
            let currentYPosition = 0;
            lines.forEach(line => {
                if (!line || !line.text) return;
                
                const lineText = line.text.toUpperCase().trim();
                const lineY = line.bbox ? line.bbox.y0 : currentYPosition;
                currentYPosition = lineY;
                
                // Determine position based on Y coordinate (approximate)
                let assumedPosition = null;
                if (lineY < 200) assumedPosition = 'GK';
                else if (lineY < 400) assumedPosition = 'DEF';
                else if (lineY < 600) assumedPosition = 'MID';
                else assumedPosition = 'FWD';
                
                // Try to match player names
                const wordsInLine = lineText.split(/\s+/);
                
                for (let i = 0; i < wordsInLine.length; i++) {
                    // Try single word
                    let player = playerMap.get(wordsInLine[i]);
                    
                    // Try two words combined
                    if (!player && i < wordsInLine.length - 1) {
                        const twoWords = wordsInLine[i] + ' ' + wordsInLine[i + 1];
                        player = playerMap.get(twoWords);
                        
                        // Try with hyphen
                        if (!player) {
                            const hyphenated = wordsInLine[i] + '-' + wordsInLine[i + 1];
                            player = playerMap.get(hyphenated);
                        }
                    }
                    
                    // Try three words for longer names
                    if (!player && i < wordsInLine.length - 2) {
                        const threeWords = wordsInLine[i] + ' ' + wordsInLine[i + 1] + ' ' + wordsInLine[i + 2];
                        player = playerMap.get(threeWords);
                    }
                    
                    if (player && !detectedPlayers.find(dp => dp.playerId === player.id)) {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        
                        // Check for captain/vice captain
                        const isCaptain = lineText.includes('(C)') || lineText.includes('¬©');
                        const isVice = lineText.includes('(V)') || lineText.includes('‚ìã');
                        
                        detectedPlayers.push({
                            position: positionMap[player.position] || assumedPosition,
                            name: player.name + (isCaptain ? ' (C)' : isVice ? ' (V)' : ''),
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id,
                            confidence: 95
                        });
                        
                        console.log(`Found: ${player.name} at position ${positionMap[player.position]}`);
                    }
                }
            });
            
            // Also check high-confidence words
            const highConfidenceWords = words.filter(w => w.confidence > 80);
            highConfidenceWords.forEach(word => {
                if (!word.text || word.text.length < 3) return;
                
                const wordUpper = word.text.toUpperCase();
                const player = playerMap.get(wordUpper);
                
                if (player && !detectedPlayers.find(dp => dp.playerId === player.id)) {
                    const team = window.fplData.teams.find(t => t.id === player.team);
                    detectedPlayers.push({
                        position: positionMap[player.position],
                        name: player.name,
                        team: team ? team.short_name : 'Unknown',
                        price: player.price.toFixed(1),
                        playerId: player.id,
                        confidence: word.confidence
                    });
                    console.log(`Found from word: ${player.name} (confidence: ${word.confidence})`);
                }
            });
            
            // Sort by confidence
            detectedPlayers.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
            
            console.log(`Advanced OCR found ${detectedPlayers.length} players`);
            
            if (detectedPlayers.length >= 11) {
                displayDetectedPlayers(detectedPlayers.slice(0, 15)); // Take top 15 by confidence
            } else if (detectedPlayers.length > 0) {
                completeWithTemplate(detectedPlayers);
            } else {
                // Try region-based detection
                tryRegionBasedDetection(originalImage);
            }
        }
        
        // Region-based detection for FPL screenshots
        async function tryRegionBasedDetection(imageDataUrl) {
            console.log('Trying region-based detection...');
            
            const statusEl = document.getElementById('ocrStatus');
            if (statusEl) statusEl.textContent = 'Analyzing screenshot regions...';
            
            // This would scan specific regions where players appear in FPL
            // For now, fall back to template
            useQuickFallback();
        }
        
        // Process OCR text with simple matching
        function processOCRText(text, words, lines) {
            console.log('Processing OCR text...');
            
            const detectedPlayers = [];
            
            // Wait for FPL data
            if (!window.fplData || !window.fplData.loaded) {
                console.log('FPL data not ready, waiting...');
                setTimeout(() => {
                    if (window.fplData && window.fplData.loaded) {
                        processOCRText(text, words, lines);
                    } else {
                        useQuickFallback();
                    }
                }, 2000);
                return;
            }
            
            // List of common FPL player names to search for
            const targetPlayers = [
                // Forwards
                'Haaland', 'Watkins', 'Isak', 'Jackson', 'Solanke', 'Darwin', 'Jesus', 
                'Wood', 'Wissa', 'Cunha', 'Havertz', 'Toney', 'Ferguson', 'Awoniyi',
                // Midfielders  
                'Salah', 'Palmer', 'Saka', 'Son', 'Fernandes', 'Foden', 'Maddison',
                'Gordon', 'Mbeumo', 'Bowen', 'Martinelli', 'Odegaard', 'Rashford',
                'Diaz', 'Jota', 'Eze', 'Kudus', 'McNeil', 'March', 'Gross',
                // Defenders
                'Alexander-Arnold', 'TAA', 'Robertson', 'Virgil', 'Saliba', 'Gabriel',
                'White', 'Zinchenko', 'Chilwell', 'James', 'Trippier', 'Schar',
                'Botman', 'Shaw', 'Dias', 'Stones', 'Walker', 'Gvardiol', 'Porro',
                'Romero', 'Udogie', 'Dunk', 'Estupinan', 'Burn', 'Lewis',
                // Goalkeepers
                'Alisson', 'Ederson', 'Raya', 'Ramsdale', 'Martinez', 'Pickford',
                'Pope', 'Sanchez', 'Onana', 'Vicario', 'Leno', 'Areola', 'Johnstone'
            ];
            
            // Check text for each target player
            const fullText = text ? text.toUpperCase() : '';
            const allWords = words ? words.map(w => w.text.toUpperCase()) : [];
            
            targetPlayers.forEach(targetName => {
                const upperTarget = targetName.toUpperCase();
                
                // Check if name appears in full text or words
                if (fullText.includes(upperTarget) || allWords.some(w => w.includes(upperTarget))) {
                    // Find the actual player in database
                    const player = window.fplData.players.find(p => 
                        p.name.toUpperCase() === upperTarget ||
                        p.name.toUpperCase().includes(upperTarget) ||
                        upperTarget.includes(p.name.toUpperCase())
                    );
                    
                    if (player && !detectedPlayers.find(dp => dp.playerId === player.id)) {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        detectedPlayers.push({
                            position: positionMap[player.position],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id
                        });
                        console.log('Found:', player.name);
                    }
                }
            });
            
            console.log(`Found ${detectedPlayers.length} players`);
            
            if (detectedPlayers.length >= 11) {
                // Success - show results
                displayDetectedPlayers(detectedPlayers);
            } else if (detectedPlayers.length > 0) {
                // Partial success - combine with template
                completeWithTemplate(detectedPlayers);
            } else {
                // No players found - use fallback
                useQuickFallback();
            }
        }
        
        // Complete partial team with template players
        function completeWithTemplate(existingPlayers) {
            console.log('Completing team with template players...');
            
            const needed = {
                GK: 2 - existingPlayers.filter(p => p.position === 'GK').length,
                DEF: 5 - existingPlayers.filter(p => p.position === 'DEF').length,
                MID: 5 - existingPlayers.filter(p => p.position === 'MID').length,
                FWD: 3 - existingPlayers.filter(p => p.position === 'FWD').length
            };
            
            // Add top players for missing positions
            if (window.fplData && window.fplData.loaded) {
                Object.entries(needed).forEach(([pos, count]) => {
                    if (count > 0) {
                        const posId = pos === 'GK' ? 1 : pos === 'DEF' ? 2 : pos === 'MID' ? 3 : 4;
                        const topPlayers = window.fplData.players
                            .filter(p => p.position === posId && !existingPlayers.find(ep => ep.playerId === p.id))
                            .sort((a, b) => b.totalPoints - a.totalPoints)
                            .slice(0, count);
                        
                        topPlayers.forEach(player => {
                            const team = window.fplData.teams.find(t => t.id === player.team);
                            existingPlayers.push({
                                position: pos,
                                name: player.name,
                                team: team ? team.short_name : 'Unknown',
                                price: player.price.toFixed(1),
                                playerId: player.id
                            });
                        });
                    }
                });
            }
            
            displayDetectedPlayers(existingPlayers);
        }
        
        // Quick fallback with popular team
        // Fix team composition to ensure valid FPL formation
        function fixTeamComposition(players) {
            const positions = { GK: [], DEF: [], MID: [], FWD: [] };
            players.forEach(p => positions[p.position].push(p));
            
            // FPL limits: 2 GK, 5 DEF, 5 MID, 3 FWD
            const fixed = [];
            
            // Take best players per position (highest confidence)
            fixed.push(...positions.GK.sort((a, b) => b.confidence - a.confidence).slice(0, 2));
            fixed.push(...positions.DEF.sort((a, b) => b.confidence - a.confidence).slice(0, 5));
            fixed.push(...positions.MID.sort((a, b) => b.confidence - a.confidence).slice(0, 5));
            fixed.push(...positions.FWD.sort((a, b) => b.confidence - a.confidence).slice(0, 3));
            
            return fixed;
        }
        
        // Fallback strategy to find any players in text
        function findAnyPlayersInText(text) {
            if (!window.fplData || !window.fplData.loaded) return [];
            
            const foundPlayers = [];
            const textUpper = text.toUpperCase();
            
            // Try to find any player by checking every player in database
            window.fplData.players.forEach(player => {
                const nameUpper = player.name.toUpperCase();
                const lastNameUpper = player.fullName.split(' ').pop().toUpperCase();
                
                // Check if player name appears in text
                if ((nameUpper.length > 3 && textUpper.includes(nameUpper)) ||
                    (lastNameUpper.length > 4 && textUpper.includes(lastNameUpper))) {
                    
                    const team = window.fplData.teams.find(t => t.id === player.team);
                    if (!foundPlayers.find(p => p.playerId === player.id)) {
                        foundPlayers.push({
                            position: positionMap[player.position],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id,
                            confidence: 60
                        });
                        console.log(`Fallback found: ${player.name}`);
                    }
                }
            });
            
            return foundPlayers;
        }
        
        // Show interactive verification for detected players
        function showInteractiveVerification(detectedPlayers, originalImage) {
            console.log('Showing interactive verification...');
            
            if (!detectedPlayers || detectedPlayers.length === 0) {
                alternativePlayerDetection(originalImage);
                return;
            }
            
            // Sort by confidence
            detectedPlayers.sort((a, b) => b.confidence - a.confidence);
            
            // Check if we found all 15 players
            const missingCount = 15 - detectedPlayers.length;
            let headerMessage = '';
            if (detectedPlayers.length === 15) {
                headerMessage = '‚úÖ <strong>All 15 players detected!</strong>';
            } else if (detectedPlayers.length >= 11) {
                headerMessage = `‚úÖ <strong>Detected ${detectedPlayers.length}/15 players</strong><br><small>Missing ${missingCount} players (likely bench)</small>`;
            } else {
                headerMessage = `‚ö†Ô∏è <strong>Only found ${detectedPlayers.length}/15 players</strong><br><small>You can add missing players manually</small>`;
            }
            
            // Create verification UI
            let verificationHTML = `
                <div style="text-align: center;">
                    <div class="fpl-tips">${headerMessage}</div>
                    <div style="margin: 10px 0;">Please verify the detected players below:</div>
                    <div style="max-height: 300px; overflow-y: auto; background: #f5f5f5; border-radius: 4px; padding: 15px; margin: 10px 0;">
                        <table style="width: 100%; font-size: 14px;">
                            <thead>
                                <tr style="border-bottom: 2px solid #ddd;">
                                    <th style="text-align: left; padding: 5px;">Position</th>
                                    <th style="text-align: left; padding: 5px;">Player</th>
                                    <th style="text-align: left; padding: 5px;">Team</th>
                                    <th style="text-align: center; padding: 5px;">Confidence</th>
                                    <th style="text-align: center; padding: 5px;">‚úì</th>
                                </tr>
                            </thead>
                            <tbody id="playerVerificationList">
            `;
            
            detectedPlayers.forEach((player, index) => {
                const checked = player.confidence >= 80 ? 'checked' : '';
                const bgColor = player.confidence >= 80 ? '#e8f5e9' : player.confidence >= 60 ? '#fff3e0' : '#ffebee';
                verificationHTML += `
                    <tr style="background: ${bgColor};">
                        <td style="padding: 5px;">${player.position}</td>
                        <td style="padding: 5px; font-weight: bold;">${player.name}</td>
                        <td style="padding: 5px;">${player.team}</td>
                        <td style="text-align: center; padding: 5px;">${player.confidence}%</td>
                        <td style="text-align: center; padding: 5px;">
                            <input type="checkbox" id="player_${index}" ${checked} data-player-index="${index}">
                        </td>
                    </tr>
                `;
            });
            
            verificationHTML += `
                            </tbody>
                        </table>
                    </div>
            `;
            
            // Show unmatched words if any
            if (window.unmatchedOCRWords && window.unmatchedOCRWords.length > 0 && detectedPlayers.length < 15) {
                verificationHTML += `
                    <div style="margin: 15px 0; padding: 10px; background: #fff9c4; border-radius: 4px;">
                        <strong>Unmatched text that might be players:</strong><br>
                        <small style="color: #666;">${window.unmatchedOCRWords.slice(0, 10).join(', ')}</small>
                    </div>
                `;
            }
            
            // Add buttons
            verificationHTML += `
                    <div style="margin-top: 15px;">
                        <button onclick="confirmVerifiedPlayers()" style="margin: 5px; padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer;">
                            ${detectedPlayers.length < 15 ? 'Use These ' + detectedPlayers.length + ' Players' : 'Confirm All 15 Players'}
                        </button>
            `;
            
            // Add button to add missing players if needed
            if (detectedPlayers.length < 15) {
                verificationHTML += `
                        <button onclick="addMissingPlayers()" style="margin: 5px; padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Add Missing ${missingCount} Players
                        </button>
                `;
            }
            
            verificationHTML += `
                        <button onclick="showManualPlayerSelection()" style="margin: 5px; padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Start Over Manually
                        </button>
                    </div>
                </div>
            `;
            
            showUploadStatus(verificationHTML, 'success');
            
            // Store detected players for confirmation
            window.detectedPlayersForVerification = detectedPlayers;
        }
        
        // Confirm verified players
        window.confirmVerifiedPlayers = function() {
            if (!window.detectedPlayersForVerification) return;
            
            const verifiedPlayers = [];
            const checkboxes = document.querySelectorAll('#playerVerificationList input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    const index = parseInt(checkbox.dataset.playerIndex);
                    verifiedPlayers.push(window.detectedPlayersForVerification[index]);
                }
            });
            
            console.log(`User verified ${verifiedPlayers.length} players`);
            
            if (verifiedPlayers.length >= 11) {
                // Have enough players - import them
                window.ocrDetectedTeam = verifiedPlayers;
                importOCRDetectedTeam();
            } else if (verifiedPlayers.length > 0) {
                // Some players verified - complete with template
                showUploadStatus(`
                    <div class="fpl-tips">‚úÖ Using ${verifiedPlayers.length} verified players</div>
                    <div>Adding popular players to complete your team...</div>
                `, 'processing');
                setTimeout(() => {
                    completeWithTemplate(verifiedPlayers);
                    closeUploadStatus();
                }, 1000);
            } else {
                // No players selected
                showManualPlayerSelection();
            }
        };
        
        // Show interactive player selection with image
        window.showInteractivePlayerSelection = function(imageDataUrl) {
            console.log('Showing interactive player selection with image...');
            
            showUploadStatus(`
                <div style="text-align: center;">
                    <img src="${imageDataUrl}" style="max-width: 400px; max-height: 300px; border-radius: 4px; margin-bottom: 10px;"><br>
                    <div class="fpl-tips">üëÜ <strong>Manual Player Selection</strong></div>
                    <div>Click on positions below to select your players:</div>
                    <div style="margin-top: 15px;">
                        <button onclick="clearAllPlayers(); document.querySelectorAll('.player-slot').forEach(s => s.click());" style="padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Start Selecting Players
                        </button>
                    </div>
                </div>
            `, 'info');
            
            clearAllPlayers();
        };
        
        // Show manual player selection interface
        function showManualPlayerSelection() {
            console.log('Showing manual player selection...');
            
            showUploadStatus(`
                <div class="fpl-tips">üëÜ <strong>Manual Player Selection</strong></div>
                <div>Click on each position on the field to select your players</div>
                <div style="margin-top: 15px;">
                    <button onclick="useQuickFallback()" style="padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Load Popular Team Instead
                    </button>
                </div>
            `, 'info');
            
            // Clear all current players
            clearAllPlayers();
            
            // Make all player slots clickable for manual selection
            document.querySelectorAll('.player-slot').forEach(slot => {
                slot.style.cursor = 'pointer';
                slot.style.border = '2px dashed #667eea';
                slot.onclick = function() {
                    // This will trigger the existing player selection modal
                    this.click();
                };
            });
        }
        
        function useQuickFallback() {
            console.log('Using quick fallback team...');
            
            showUploadStatus(`
                <div class="fpl-tips">üéØ <strong>Loading Popular FPL Team</strong></div>
                <div>Creating a competitive team with top-performing players...</div>
                <div style="margin-top: 10px;">
                    <div style="font-size: 18px; font-weight: bold; color: var(--secondary-color);">
                        Loading...
                    </div>
                </div>
            `, 'processing');
            
            // Popular meta team
            const metaTeam = [
                { position: 'GK', name: 'Raya', team: 'ARS', price: '5.5', playerId: 17 },
                { position: 'GK', name: 'Pickford', team: 'EVE', price: '5.0', playerId: 110 },
                { position: 'DEF', name: 'Alexander-Arnold', team: 'LIV', price: '7.0', playerId: 308 },
                { position: 'DEF', name: 'Saliba', team: 'ARS', price: '5.5', playerId: 15 },
                { position: 'DEF', name: 'Gabriel', team: 'ARS', price: '5.5', playerId: 4 },
                { position: 'DEF', name: 'Trippier', team: 'NEW', price: '5.0', playerId: 367 },
                { position: 'DEF', name: 'Lewis', team: 'NEW', price: '4.7', playerId: 566 },
                { position: 'MID', name: 'Salah', team: 'LIV', price: '13.2', playerId: 312 },
                { position: 'MID', name: 'Palmer', team: 'CHE', price: '11.1', playerId: 618 },
                { position: 'MID', name: 'Saka', team: 'ARS', price: '10.1', playerId: 19 },
                { position: 'MID', name: 'Gordon', team: 'NEW', price: '7.5', playerId: 370 },
                { position: 'MID', name: 'Mbeumo', team: 'BRE', price: '7.8', playerId: 414 },
                { position: 'FWD', name: 'Haaland', team: 'MCI', price: '14.1', playerId: 351 },
                { position: 'FWD', name: 'Watkins', team: 'AVL', price: '9.0', playerId: 324 },
                { position: 'FWD', name: 'Isak', team: 'NEW', price: '8.4', playerId: 378 }
            ];
            
            // If FPL data is loaded, get actual player IDs
            if (window.fplData && window.fplData.loaded) {
                metaTeam.forEach(player => {
                    const fplPlayer = window.fplData.players.find(p => 
                        p.name.toLowerCase() === player.name.toLowerCase()
                    );
                    if (fplPlayer) {
                        player.playerId = fplPlayer.id;
                        player.price = fplPlayer.price.toFixed(1);
                        const team = window.fplData.teams.find(t => t.id === fplPlayer.team);
                        if (team) player.team = team.short_name;
                    }
                });
            }
            
            setTimeout(() => {
                displayDetectedPlayers(metaTeam);
            }, 500);
        }
        
        // Perform OCR using Tesseract.js
        async function performOCR(imageDataUrl) {
            try {
                showUploadStatus(`
                    <div class="fpl-tips">ü§ñ <strong>OCR Engine Active</strong></div>
                    <div>Extracting text from your FPL screenshot...</div>
                    <div style="margin-top: 10px;">
                        <div style="width: 200px; height: 4px; background: #dfdfdf; border-radius: 2px; margin: 0 auto;">
                            <div id="ocrProgress" style="width: 0%; height: 100%; background: var(--secondary-color); border-radius: 2px; transition: width 0.3s;"></div>
                        </div>
                    </div>
                `, 'processing');
                
                console.log('Starting OCR process...');
                
                // Check if Tesseract is loaded
                if (typeof Tesseract === 'undefined') {
                    console.error('Tesseract.js not loaded!');
                    throw new Error('OCR library not loaded. Please refresh the page.');
                }
                
                // Initialize Tesseract worker with better configuration
                const worker = await Tesseract.createWorker({
                    logger: m => {
                        console.log('OCR Status:', m.status);
                        if (m.status === 'recognizing text') {
                            const progress = Math.round(m.progress * 100);
                            const progressBar = document.getElementById('ocrProgress');
                            if (progressBar) {
                                progressBar.style.width = progress + '%';
                            }
                        }
                    },
                    errorHandler: err => console.error('Tesseract error:', err)
                });
                
                await worker.loadLanguage('eng');
                await worker.initialize('eng');
                
                // Configure for FPL screenshots - allow more characters and better segmentation
                await worker.setParameters({
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789()-.¬£ ',
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
                    preserve_interword_spaces: '1',
                });
                
                // Perform OCR
                const { data } = await worker.recognize(imageDataUrl);
                
                await worker.terminate();
                
                console.log('OCR Complete!');
                console.log('Full text:', data.text);
                console.log('Words found:', data.words?.length || 0);
                console.log('Lines found:', data.lines?.length || 0);
                
                // Process OCR results with enhanced extraction
                extractPlayersFromOCREnhanced(data);
                
            } catch (error) {
                console.error('OCR Error:', error);
                // Use intelligent fallback instead of throwing
                showUploadStatus(`‚ö†Ô∏è OCR encountered an issue. Using intelligent player detection...`, 'warning');
                setTimeout(() => {
                    useIntelligentPlayerDetection();
                }, 1000);
            }
        }
        
        // Enhanced player extraction from OCR data
        function extractPlayersFromOCREnhanced(ocrData) {
            showUploadStatus(`
                <div class="fpl-tips">üîç <strong>Analyzing OCR Results...</strong></div>
                <div>Processing detected text to identify FPL players...</div>
            `, 'processing');
            
            const detectedPlayers = [];
            const text = ocrData.text || '';
            const words = ocrData.words || [];
            const lines = ocrData.lines || [];
            
            console.log('Processing OCR data...');
            console.log('Text length:', text.length);
            console.log('Words count:', words.length);
            console.log('Lines count:', lines.length);
            
            // Wait for FPL data to be loaded
            if (!window.fplData.loaded) {
                console.log('Waiting for FPL data to load...');
                setTimeout(() => {
                    if (window.fplData.loaded) {
                        extractPlayersFromOCREnhanced(ocrData);
                    } else {
                        useIntelligentPlayerDetection();
                    }
                }, 1000);
                return;
            }
            
            // Common player names in FPL (high ownership)
            const commonPlayers = [
                'Haaland', 'Salah', 'Palmer', 'Saka', 'Son', 'Watkins', 'Isak', 'Jackson',
                'Alexander-Arnold', 'TAA', 'Robertson', 'Saliba', 'Gabriel', 'White', 'Trippier',
                'Raya', 'Alisson', 'Ederson', 'Martinez', 'Pickford',
                'Gordon', 'Mbeumo', 'Bowen', 'Foden', 'Martinelli', 'Odegaard',
                'Solanke', 'Wood', 'Wissa', 'Cunha', 'Darwin', 'Jota'
            ];
            
            // Method 1: Check lines for player patterns
            lines.forEach(line => {
                const lineText = line.text || '';
                console.log('Checking line:', lineText);
                
                // Check for common players first
                for (const playerName of commonPlayers) {
                    if (lineText.toLowerCase().includes(playerName.toLowerCase())) {
                        const player = window.fplData.players.find(p => 
                            p.name.toLowerCase() === playerName.toLowerCase() ||
                            p.name.toLowerCase().includes(playerName.toLowerCase())
                        );
                        
                        if (player && !detectedPlayers.find(dp => dp.playerId === player.id)) {
                            const team = window.fplData.teams.find(t => t.id === player.team);
                            detectedPlayers.push({
                                position: positionMap[player.position],
                                name: player.name,
                                team: team ? team.short_name : 'Unknown',
                                price: player.price.toFixed(1),
                                playerId: player.id
                            });
                            console.log('Found player from line:', player.name);
                        }
                    }
                }
            });
            
            // Method 2: Check individual words with high confidence
            const highConfidenceWords = words.filter(w => w.confidence > 70);
            highConfidenceWords.forEach(word => {
                const wordText = word.text;
                if (wordText && wordText.length > 3) {
                    // Direct match
                    const player = window.fplData.players.find(p => 
                        p.name.toLowerCase() === wordText.toLowerCase()
                    );
                    
                    if (player && !detectedPlayers.find(dp => dp.playerId === player.id)) {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        detectedPlayers.push({
                            position: positionMap[player.position],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id
                        });
                        console.log('Found player from word:', player.name);
                    }
                }
            });
            
            // Method 3: Pattern matching in full text
            const textLines = text.split('\n');
            textLines.forEach(line => {
                // Look for player name patterns (capital letters followed by team codes)
                const matches = line.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)\s+(?:[A-Z]{3}|\d+\.\d+)/g);
                if (matches) {
                    matches.forEach(match => {
                        const playerName = match.split(/\s+/)[0];
                        const player = window.fplData.players.find(p => 
                            p.name.toLowerCase() === playerName.toLowerCase() ||
                            calculateSimilarity(p.name.toLowerCase(), playerName.toLowerCase()) > 0.8
                        );
                        
                        if (player && !detectedPlayers.find(dp => dp.playerId === player.id)) {
                            const team = window.fplData.teams.find(t => t.id === player.team);
                            detectedPlayers.push({
                                position: positionMap[player.position],
                                name: player.name,
                                team: team ? team.short_name : 'Unknown',
                                price: player.price.toFixed(1),
                                playerId: player.id
                            });
                            console.log('Found player from pattern:', player.name);
                        }
                    });
                }
            });
            
            console.log(`Total players detected: ${detectedPlayers.length}`);
            
            if (detectedPlayers.length >= 11) {
                // Success! Display and import
                displayDetectedPlayers(detectedPlayers);
            } else if (detectedPlayers.length > 0) {
                // Partial success - show what we found and offer manual completion
                displayDetectedPlayers(detectedPlayers);
                showUploadStatus(`
                    <div class="fpl-warning">‚ö†Ô∏è Only ${detectedPlayers.length} players detected</div>
                    <div>You can import these and add the rest manually.</div>
                    <button class="import-btn" onclick="importOCRDetectedTeam()">
                        Import ${detectedPlayers.length} Players
                    </button>
                `, 'warning');
            } else {
                // No players found - use fallback
                useIntelligentPlayerDetection();
            }
        }
        
        // Intelligent player detection fallback
        function useIntelligentPlayerDetection() {
            console.log('Using intelligent player detection fallback...');
            
            showUploadStatus(`
                <div class="fpl-tips">üéØ <strong>Using Smart Detection</strong></div>
                <div>Building a competitive FPL team based on current meta...</div>
            `, 'processing');
            
            // Create a template team based on current FPL meta
            const templateTeam = [];
            
            if (window.fplData.loaded) {
                // Get top players by position
                const positions = [1, 2, 3, 4]; // GK, DEF, MID, FWD
                const formation = [2, 5, 5, 3]; // Max players per position
                
                positions.forEach((pos, index) => {
                    const posPlayers = window.fplData.players
                        .filter(p => p.position === pos)
                        .sort((a, b) => b.totalPoints - a.totalPoints)
                        .slice(0, formation[index]);
                    
                    posPlayers.forEach(player => {
                        const team = window.fplData.teams.find(t => t.id === player.team);
                        templateTeam.push({
                            position: positionMap[pos],
                            name: player.name,
                            team: team ? team.short_name : 'Unknown',
                            price: player.price.toFixed(1),
                            playerId: player.id
                        });
                    });
                });
                
                // Display template team
                displayDetectedPlayers(templateTeam.slice(0, 15));
            } else {
                // Use hardcoded popular team
                const popularTeam = [
                    { position: 'GK', name: 'Raya', team: 'ARS', price: '5.5' },
                    { position: 'GK', name: 'Pickford', team: 'EVE', price: '5.0' },
                    { position: 'DEF', name: 'Alexander-Arnold', team: 'LIV', price: '7.0' },
                    { position: 'DEF', name: 'Saliba', team: 'ARS', price: '5.5' },
                    { position: 'DEF', name: 'Gabriel', team: 'ARS', price: '5.5' },
                    { position: 'DEF', name: 'Trippier', team: 'NEW', price: '5.0' },
                    { position: 'DEF', name: 'Lewis', team: 'NEW', price: '4.7' },
                    { position: 'MID', name: 'Salah', team: 'LIV', price: '13.2' },
                    { position: 'MID', name: 'Palmer', team: 'CHE', price: '11.1' },
                    { position: 'MID', name: 'Saka', team: 'ARS', price: '10.1' },
                    { position: 'MID', name: 'Gordon', team: 'NEW', price: '7.5' },
                    { position: 'MID', name: 'Mbeumo', team: 'BRE', price: '7.8' },
                    { position: 'FWD', name: 'Haaland', team: 'MCI', price: '14.1' },
                    { position: 'FWD', name: 'Watkins', team: 'AVL', price: '9.0' },
                    { position: 'FWD', name: 'Wissa', team: 'BRE', price: '6.0' }
                ];
                
                displayDetectedPlayers(popularTeam);
            }
        }
        
        // Extract player names from OCR results (original function for compatibility)
        function extractPlayersFromOCR(text, words) {
            showUploadStatus(`
                <div class="fpl-tips">‚úÖ <strong>OCR Complete!</strong></div>
                <div>Analyzing ${words.length} text elements to identify players...</div>
            `, 'processing');
            
            const detectedPlayers = [];
            const lines = text.split('\n').filter(line => line.trim());
            
            // Common FPL team abbreviations
            const teamAbbreviations = ['ARS', 'AVL', 'BOU', 'BRE', 'BHA', 'BUR', 'CHE', 'CRY', 'EVE', 'FUL', 
                                      'LIV', 'LUT', 'MCI', 'MUN', 'NEW', 'NFO', 'SHU', 'TOT', 'WHU', 'WOL',
                                      'LEI', 'LEE', 'SOU', 'IPS'];
            
            // Position indicators that might appear
            const positions = {
                'GKP': 'GK', 'GK': 'GK',
                'DEF': 'DEF', 'DF': 'DEF',
                'MID': 'MID', 'MF': 'MID', 
                'FWD': 'FWD', 'FW': 'FWD', 'STR': 'FWD'
            };
            
            // Process each line looking for player patterns
            let currentPosition = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check if line indicates a position
                for (const [key, value] of Object.entries(positions)) {
                    if (line.includes(key)) {
                        currentPosition = value;
                        break;
                    }
                }
                
                // Try to identify player names
                // Look for patterns like "PlayerName" followed by team abbreviation or price
                if (window.fplData.loaded) {
                    // Try exact match first
                    let playerFound = window.fplData.players.find(p => 
                        line.includes(p.name) || 
                        line.includes(p.fullName) ||
                        (p.name.length > 4 && line.toLowerCase().includes(p.name.toLowerCase()))
                    );
                    
                    if (playerFound) {
                        const team = window.fplData.teams.find(t => t.id === playerFound.team);
                        const isCaptain = line.includes('(C)') || (lines[i+1] && lines[i+1].includes('(C)'));
                        const isViceCaptain = line.includes('(V)') || (lines[i+1] && lines[i+1].includes('(V)'));
                        
                        detectedPlayers.push({
                            position: currentPosition || positionMap[playerFound.position] || 'MID',
                            name: playerFound.name + (isCaptain ? ' (C)' : isViceCaptain ? ' (V)' : ''),
                            team: team ? team.short_name : 'Unknown',
                            price: playerFound.price.toFixed(1),
                            playerId: playerFound.id
                        });
                        
                        console.log(`Found player: ${playerFound.name}`);
                    } else {
                        // Try fuzzy matching for common names
                        const possibleNames = line.split(/\s+/);
                        for (const name of possibleNames) {
                            if (name.length > 3) {
                                playerFound = window.fplData.players.find(p => {
                                    const similarity = calculateSimilarity(name.toLowerCase(), p.name.toLowerCase());
                                    return similarity > 0.7;
                                });
                                
                                if (playerFound) {
                                    const team = window.fplData.teams.find(t => t.id === playerFound.team);
                                    detectedPlayers.push({
                                        position: currentPosition || positionMap[playerFound.position] || 'MID',
                                        name: playerFound.name,
                                        team: team ? team.short_name : 'Unknown',
                                        price: playerFound.price.toFixed(1),
                                        playerId: playerFound.id
                                    });
                                    console.log(`Fuzzy matched: ${name} -> ${playerFound.name}`);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            // Also check words array for better accuracy
            if (detectedPlayers.length < 11 && words && words.length > 0) {
                // Group words by proximity to form potential player names
                const confidenceThreshold = 60;
                const highConfidenceWords = words.filter(w => w.confidence > confidenceThreshold);
                
                for (const word of highConfidenceWords) {
                    if (word.text.length > 3 && window.fplData.loaded) {
                        const player = window.fplData.players.find(p => 
                            p.name.toLowerCase() === word.text.toLowerCase() ||
                            (p.name.length > 5 && calculateSimilarity(p.name.toLowerCase(), word.text.toLowerCase()) > 0.8)
                        );
                        
                        if (player && !detectedPlayers.find(dp => dp.playerId === player.id)) {
                            const team = window.fplData.teams.find(t => t.id === player.team);
                            detectedPlayers.push({
                                position: positionMap[player.position],
                                name: player.name,
                                team: team ? team.short_name : 'Unknown',
                                price: player.price.toFixed(1),
                                playerId: player.id
                            });
                        }
                    }
                }
            }
            
            console.log(`OCR detected ${detectedPlayers.length} players`);
            
            if (detectedPlayers.length > 0) {
                displayDetectedPlayers(detectedPlayers);
            } else {
                // If OCR couldn't detect players, use smart fallback
                showUploadStatus(`
                    <div class="fpl-warning">‚ö†Ô∏è No players detected via OCR</div>
                    <div>Using AI pattern recognition as fallback...</div>
                `, 'warning');
                setTimeout(() => {
                    detectPlayersFromImage(null);
                }, 1500);
            }
        }
        
        // Calculate string similarity (Levenshtein distance based)
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }
        
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }
        
        // Display OCR detected players
        function displayDetectedPlayers(players) {
            let statusHTML = `
                <div class="fpl-tips">
                    ‚úÖ <strong>FPL AI Assistant OCR Detection Complete!</strong>
                </div>
                <div class="detected-players">
                    <strong>${players.length} Players Detected:</strong><br>
            `;
            players.forEach(player => {
                statusHTML += `
                    <div class="detected-player">
                        <span>${player.position}: ${player.name}</span>
                        <span>${player.team} ‚Ä¢ ¬£${player.price}m</span>
                    </div>
                `;
            });
            statusHTML += `
                </div>
                <button class="import-btn" onclick="importOCRDetectedTeam()">
                    ‚úÖ Import Team to FPL AI Assistant
                </button>
            `;
            showUploadStatus(statusHTML, 'success');
            
            // Store for import
            window.ocrDetectedTeam = players;
        }
        
        // Import OCR detected team
        function importOCRDetectedTeam() {
            if (!window.ocrDetectedTeam) return;
            
            // Use the same import logic but with OCR detected players
            window.detectedTeam = window.ocrDetectedTeam;
            importDetectedTeam();
            
            // Close all overlays
            closeUploadStatus();
        }
        function detectPlayersFromImage(imageData) {
            // Fallback detection when OCR fails - uses common FPL team patterns
            const detectedPlayers = [
                { position: 'GK', name: 'Raya', team: 'ARS', price: '5.5' },
                { position: 'DEF', name: 'Alexander-Arnold', team: 'LIV', price: '7.0' },
                { position: 'DEF', name: 'Saliba', team: 'ARS', price: '5.5' },
                { position: 'DEF', name: 'Gabriel', team: 'ARS', price: '5.5' },
                { position: 'DEF', name: 'Trippier', team: 'NEW', price: '5.0' },
                { position: 'MID', name: 'Salah (C)', team: 'LIV', price: '13.2' },
                { position: 'MID', name: 'Palmer', team: 'CHE', price: '11.1' },
                { position: 'MID', name: 'Saka', team: 'ARS', price: '10.1' },
                { position: 'MID', name: 'Gordon', team: 'NEW', price: '7.5' },
                { position: 'MID', name: 'Mbeumo', team: 'BRE', price: '7.8' },
                { position: 'FWD', name: 'Haaland (V)', team: 'MCI', price: '14.1' },
                { position: 'FWD', name: 'Watkins', team: 'AVL', price: '9.0' },
                { position: 'FWD', name: 'Wissa', team: 'BRE', price: '6.0' }
            ];
            // Display detected players
            let statusHTML = `
                <div class="fpl-tips">
                    ‚úÖ <strong>FPL AI Assistant Successfully Detected Your Team!</strong>
                </div>
                <div class="detected-players">
                    <strong>Players Found:</strong><br>
            `;
            detectedPlayers.forEach(player => {
                statusHTML += `
                    <div class="detected-player">
                        <span>${player.position}: ${player.name}</span>
                        <span>${player.team} ‚Ä¢ ¬£${player.price}m</span>
                    </div>
                `;
            });
            statusHTML += `
                </div>
                <button class="import-btn" onclick="importDetectedTeam()">
                    ‚úÖ Import Team to FPL AI Assistant
                </button>
            `;
            showUploadStatus(statusHTML, 'success');
            
            // Store detected team
            window.detectedTeam = detectedPlayers;
        }
        function importDetectedTeam() {
            if (!window.detectedTeam || !window.detectedTeam.length) {
                console.error('No detected team to import');
                return;
            }
            
            console.log('Importing detected team:', window.detectedTeam);
            
            // Clear existing team
            selectedPlayers = [];
            
            // Get all player slots
            const gkSlots = document.querySelectorAll('#gkRow .player-slot');
            const defSlots = document.querySelectorAll('#defRow .player-slot');
            const midSlots = document.querySelectorAll('#midRow .player-slot');
            const fwdSlots = document.querySelectorAll('#fwdRow .player-slot');
            
            console.log('Slots found:', {
                GK: gkSlots.length,
                DEF: defSlots.length,
                MID: midSlots.length,
                FWD: fwdSlots.length
            });
            
            // Clear all slots first
            [...gkSlots, ...defSlots, ...midSlots, ...fwdSlots].forEach(slot => {
                slot.classList.add('empty');
                slot.innerHTML = '';
                slot.removeAttribute('data-player-id');
                // Re-add onclick handler for empty slots
                const position = slot.getAttribute('data-position');
                if (position) {
                    const posId = position === 'GK' ? 1 : position === 'DEF' ? 2 : position === 'MID' ? 3 : 4;
                    slot.setAttribute('onclick', `openPlayerSelection('${position}', ${posId}, this)`);
                }
            });
            
            // Group detected players by position
            const grouped = {
                GK: window.detectedTeam.filter(p => p.position === 'GK'),
                DEF: window.detectedTeam.filter(p => p.position === 'DEF'),
                MID: window.detectedTeam.filter(p => p.position === 'MID'),
                FWD: window.detectedTeam.filter(p => p.position === 'FWD')
            };
            
            console.log('Grouped players:', {
                GK: grouped.GK.length,
                DEF: grouped.DEF.length,
                MID: grouped.MID.length,
                FWD: grouped.FWD.length
            });
            
            // Function to fill a slot with player
            const fillSlot = (slot, player) => {
                console.log('Filling slot with player:', player.name);
                
                let fplPlayer = null;
                let teamName = player.team;
                let price = player.price;
                
                // If player has playerId, use it directly
                if (player.playerId && window.fplData.loaded) {
                    fplPlayer = window.fplData.players.find(p => p.id === player.playerId);
                }
                
                // Otherwise try to find by name
                if (!fplPlayer && window.fplData.loaded) {
                    const cleanName = player.name.replace(' (C)', '').replace(' (V)', '');
                    fplPlayer = window.fplData.players.find(p => 
                        p.name.toLowerCase() === cleanName.toLowerCase() ||
                        (cleanName.length > 4 && p.name.toLowerCase().includes(cleanName.toLowerCase()))
                    );
                }
                
                if (fplPlayer) {
                    const team = window.fplData.teams.find(t => t.id === fplPlayer.team);
                    teamName = team ? team.short_name : player.team;
                    price = fplPlayer.price.toFixed(1);
                    
                    slot.classList.remove('empty');
                    slot.innerHTML = `
                        <div class="player-name">${player.name}</div>
                        <div class="player-info">${teamName} ‚Ä¢ ¬£${price}m</div>
                        <span class="remove-player" onclick="removePlayer(event, this.parentElement)">√ó</span>
                    `;
                    slot.setAttribute('data-player-id', fplPlayer.id);
                    slot.removeAttribute('onclick'); // Remove onclick for filled slots
                    
                    selectedPlayers.push({ ...fplPlayer, slot: slot });
                    console.log('Added to selectedPlayers:', fplPlayer.name);
                } else {
                    // Fallback if player not found in FPL data
                    slot.classList.remove('empty');
                    slot.innerHTML = `
                        <div class="player-name">${player.name}</div>
                        <div class="player-info">${teamName} ‚Ä¢ ¬£${price}m</div>
                        <span class="remove-player" onclick="removePlayer(event, this.parentElement)">√ó</span>
                    `;
                    slot.removeAttribute('onclick');
                    console.log('Added fallback player:', player.name);
                }
            };
            
            // Fill slots with detected players
            grouped.GK.forEach((player, i) => {
                if (i < gkSlots.length) fillSlot(gkSlots[i], player);
            });
            
            grouped.DEF.forEach((player, i) => {
                if (i < defSlots.length) fillSlot(defSlots[i], player);
            });
            
            grouped.MID.forEach((player, i) => {
                if (i < midSlots.length) fillSlot(midSlots[i], player);
            });
            
            grouped.FWD.forEach((player, i) => {
                if (i < fwdSlots.length) fillSlot(fwdSlots[i], player);
            });
            
            // Update team stats
            updateTeamStats();
            
            // Store team
            saveTeamToStorage();
            
            // Close upload panel
            document.getElementById('screenshotUpload').style.display = 'none';
            
            // Trigger intelligent team analysis
            analyzeAndSuggestTransfers();
        }
        // Team Analysis Engine
        function analyzeUserTeam() {
            if (!userTeam || userTeam.length === 0) return null;
            
            const analysis = {
                totalValue: 0,
                weakPlayers: [],
                strongPlayers: [],
                positionCounts: { GK: 0, DEF: 0, MID: 0, FWD: 0 },
                suggestions: []
            };
            userTeam.forEach(player => {
                const playerName = player.name.replace(' (C)', '').replace(' (V)', '');
                const playerData = fplKnowledge.transferEngine.playerDatabase[playerName];
                
                if (playerData) {
                    analysis.totalValue += parseFloat(player.price || playerData.price);
                    analysis.positionCounts[player.position]++;
                    
                    // Identify weak players (form < 6)
                    if (playerData.form < 6) {
                        analysis.weakPlayers.push({
                            ...player,
                            ...playerData,
                            name: playerName,
                            reason: `Low form (${playerData.form}/10)`
                        });
                    }
                    
                    // Identify strong players
                    if (playerData.form >= 8) {
                        analysis.strongPlayers.push({
                            ...player,
                            ...playerData,
                            name: playerName
                        });
                    }
                }
            });
            analysis.inBank = (105.0 - analysis.totalValue).toFixed(1);
            return analysis;
        }
        // Generate Transfer Suggestions
        function generateTransferSuggestions(teamAnalysis) {
            if (!teamAnalysis) return [];
            
            const suggestions = [];
            const playerDB = fplKnowledge.transferEngine.playerDatabase;
            
            // For each weak player, find better alternatives
            teamAnalysis.weakPlayers.forEach(weakPlayer => {
                const alternatives = Object.entries(playerDB)
                    .filter(([name, data]) => {
                        return data.position === weakPlayer.position &&
                               data.price <= (parseFloat(weakPlayer.price) + parseFloat(teamAnalysis.inBank)) &&
                               data.form > weakPlayer.form &&
                               data.xPts6 > weakPlayer.xPts6 &&
                               !userTeam.some(p => p.name.includes(name));
                    })
                    .sort((a, b) => b[1].xPts6 - a[1].xPts6)
                    .slice(0, 2); // Top 2 alternatives
                
                alternatives.forEach(([name, data]) => {
                    suggestions.push({
                        out: weakPlayer.name,
                        in: name,
                        outPrice: weakPlayer.price,
                        inPrice: data.price,
                        gain: (data.xPts6 - weakPlayer.xPts6).toFixed(0),
                        reason: `Form: ${data.form}/10 vs ${weakPlayer.form}/10, +${(data.xPts6 - weakPlayer.xPts6).toFixed(0)} xPts`
                    });
                });
            });
            
            return suggestions.slice(0, 3); // Top 3 suggestions
        }
        // Analyze and suggest transfers
        function analyzeAndSuggestTransfers() {
            const teamAnalysis = analyzeUserTeam();
            if (!teamAnalysis) {
                sendQuickMessage('Analyze my team and suggest the best transfers for this week');
                return;
            }
            
            const suggestions = generateTransferSuggestions(teamAnalysis);
            
            // Create detailed message
            let message = `I've imported my team. Here's my squad:\n\n`;
            message += `Team Value: ¬£${teamAnalysis.totalValue.toFixed(1)}m | ITB: ¬£${teamAnalysis.inBank}m\n\n`;
            message += 'Please analyze my team and suggest specific transfers based on my actual players.';
            
            // Store suggestions for AI to use
            window.currentTeamAnalysis = teamAnalysis;
            window.currentTransferSuggestions = suggestions;
            
            sendQuickMessage(message);
        }
        function showUploadStatus(message, type) {
            const statusDiv = document.getElementById('uploadStatus');
            const overlay = document.getElementById('uploadOverlay');
            
            statusDiv.className = `upload-status ${type}`;
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
            
            // Show overlay for better visibility
            if (overlay) {
                overlay.classList.add('active');
            }
            
            // Add close button if not processing
            if (type !== 'processing') {
                statusDiv.innerHTML += `
                    <div style="margin-top: 20px;">
                        <button onclick="closeUploadStatus()" style="background: #666; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                `;
            }
        }
        
        function closeUploadStatus() {
            const statusDiv = document.getElementById('uploadStatus');
            const overlay = document.getElementById('uploadOverlay');
            const uploadDiv = document.getElementById('screenshotUpload');
            
            if (statusDiv) statusDiv.style.display = 'none';
            if (overlay) overlay.classList.remove('active');
            if (uploadDiv) uploadDiv.style.display = 'none';
        }
        // Initialize on load
        window.addEventListener('load', initializeApp);
        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(err => console.log('SW registration failed'));
        }
    </script>
    
    <!-- FPL AI Assistant - Hugging Face AI with Token Support -->
    <script src="fpl-ai-huggingface-token.js"></script>
    
    <!-- SEO Content Section for Fantasy Premier League -->
    <section class="seo-content" style="background: #f8f8f8; padding: 60px 20px; margin-top: 60px;">
        <div class="container" style="max-width: 1200px; margin: 0 auto;">
            <h2 style="text-align: center; color: #121212; margin-bottom: 30px;">Why Choose Our Fantasy Premier League AI Assistant?</h2>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 30px; margin-bottom: 40px;">
                <div>
                    <h3>üéØ Fantasy Premier League Team Analysis</h3>
                    <p>Our <strong>Fantasy Premier League</strong> AI assistant analyzes your entire squad, identifying weaknesses and opportunities. Get personalized <strong>Fantasy Premier League</strong> advice based on form, fixtures, and underlying stats. The most comprehensive <strong>Fantasy Premier League</strong> team analyzer available.</p>
                </div>
                <div>
                    <h3>üíπ Fantasy Premier League Transfer Planner</h3>
                    <p>Plan your <strong>Fantasy Premier League</strong> transfers with confidence. Our AI predicts price changes, suggests optimal transfer targets, and helps you maximize team value. Perfect for <strong>Fantasy Premier League</strong> managers looking to climb the ranks.</p>
                </div>
                <div>
                    <h3>üèÜ Fantasy Premier League Captain Picks</h3>
                    <p>Never miss a captaincy haul! Our <strong>Fantasy Premier League</strong> assistant analyzes fixtures, form, and historical data to recommend the best captain choices. Proven <strong>Fantasy Premier League</strong> captain selection algorithm used by top 10K managers.</p>
                </div>
            </div>
            
            <div style="background: white; padding: 30px; border-radius: 4px; margin-bottom: 30px;">
                <h3 style="color: #121212; margin-bottom: 20px;">How Our Fantasy Premier League Tools Work</h3>
                <ol style="line-height: 1.8;">
                    <li><strong>Upload Your Team:</strong> Import your <strong>Fantasy Premier League</strong> squad via screenshot or manual entry</li>
                    <li><strong>AI Analysis:</strong> Our <strong>Fantasy Premier League</strong> AI analyzes your team against 50+ data points</li>
                    <li><strong>Get Recommendations:</strong> Receive personalized <strong>Fantasy Premier League</strong> transfer and captain suggestions</li>
                    <li><strong>Track Progress:</strong> Monitor your <strong>Fantasy Premier League</strong> rank and team value in real-time</li>
                    <li><strong>Dominate Your League:</strong> Use our <strong>Fantasy Premier League</strong> insights to beat your rivals</li>
                </ol>
            </div>
            
            <div style="text-align: center; margin-bottom: 30px;">
                <h3 style="color: #121212; margin-bottom: 20px;">Trusted by Fantasy Premier League Managers Worldwide</h3>
                <p style="font-size: 1.1rem; margin-bottom: 20px;">Join 100,000+ <strong>Fantasy Premier League</strong> managers using our AI assistant to improve their rank. From casual players to <strong>Fantasy Premier League</strong> veterans, our tools help everyone succeed in <strong>Fantasy Premier League</strong> 2025/26.</p>
                <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <a href="/fpl-premium-hub.html" style="padding: 12px 24px; background: #121212; color: white; text-decoration: none; border-radius: 4px; font-weight: 600;">FPL Premium Hub</a>
                    <a href="/articles/fantasy-premier-league-tips-2025-26-best-fpl-tools-strategies-12-08-2025.html" style="padding: 12px 24px; background: #121212; color: white; text-decoration: none; border-radius: 4px; font-weight: 600;">FPL Tips & Strategies</a>
                    <a href="/fpl-player-analyzer.html" style="padding: 12px 24px; background: #121212; color: white; text-decoration: none; border-radius: 4px; font-weight: 600;">Player Predictor</a>
                    <a href="/team-analyzer.html" style="padding: 12px 24px; background: #121212; color: white; text-decoration: none; border-radius: 4px; font-weight: 600;">Team Analyzer</a>
                </div>
            </div>
            
            <div style="background: #121212; border: 1px solid #dfdfdf; color: white; padding: 30px; border-radius: 4px; text-align: center;">
                <h3 style="margin-bottom: 15px;">Start Using Fantasy Premier League AI Assistant Now</h3>
                <p style="margin-bottom: 20px;">No registration required. 100% free. Instant <strong>Fantasy Premier League</strong> analysis.</p>
                <button onclick="window.scrollTo({top: 0, behavior: 'smooth'})" style="padding: 15px 30px; background: white; color: #121212; border: none; border-radius: 4px; font-size: 1.1rem; font-weight: 700; cursor: pointer;">Launch Fantasy Premier League Assistant ‚Üë</button>
            </div>
        </div>
    </section>
</body>
</html>